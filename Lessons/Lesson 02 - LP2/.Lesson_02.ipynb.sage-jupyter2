{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-69cf6489-ac39-4e31-939a-e82e02797206.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"},"toc":{"base_numbering":1,"nav_menu":{},"number_sections":true,"sideBar":true,"skip_h1_title":false,"title_cell":"Table of Contents","title_sidebar":"Contents","toc_cell":false,"toc_position":{"height":"calc(100% - 180px)","left":"10px","top":"150px","width":"313.789px"},"toc_section_display":true,"toc_window_display":true},"varInspector":{"cols":{"lenName":16,"lenType":16,"lenVar":40},"kernels_config":{"python":{"delete_cmd_postfix":"","delete_cmd_prefix":"del ","library":"var_list.py","varRefreshCmd":"print(var_dic_list())"},"r":{"delete_cmd_postfix":") ","delete_cmd_prefix":"rm(","library":"var_list.r","varRefreshCmd":"cat(var_dic_list()) "}},"types_to_exclude":["module","function","builtin_function_or_method","instance","_Feature"],"window_display":false}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1661536714219,"exec_count":1,"id":"183149","input":"# EXECUTE FIRST\n\n# computational imports\nfrom pyomo.environ import *\nimport numpy as np\nimport pandas as pd\n\n# display imports\nfrom IPython.display import display, IFrame\nfrom IPython.core.display import HTML\n\n# plotting imports\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style(\"darkgrid\")\n\n# for playing videos, customize height and width if desired\ndef play_video(vid_name, w = 640, h = 360):\n    vid_path = \"https://media.uwex.edu/content/ds/ds775_r19/\"\n    return IFrame( vid_path + vid_name + \"/index.html\", width = w, height = h )","kernel":"python3","metadata":{"code_folding":[0]},"no_halt":true,"pos":0,"start":1661536711531,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536714251,"exec_count":2,"id":"4a9fa5","input":"# execute this cell for video\nplay_video(\"ds775_lesson2-wyndor-abstract\")","kernel":"python3","metadata":{"code_folding":[0],"hidden":true},"no_halt":true,"output":{"0":{"data":{"iframe":"6de09dc79367ccd6b9f2d9af8a69dd453e69c785","text/plain":"<IPython.lib.display.IFrame at 0x7f1694b7d3a0>"},"exec_count":2}},"pos":12,"start":1661536714228,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536714411,"exec_count":3,"id":"c8452f","input":"# abstract Wyndor\n\n### PROBLEM DATA ###\nproducts = ['Doors', 'Windows']\nplants = ['Plant1', 'Plant2', 'Plant3']\nprofit_rate = {'Doors': 3, 'Windows': 5}\nhours_available = {'Plant1': 4, 'Plant2': 12, 'Plant3': 18}\nhours_per_batch = {\n    'Plant1': {\n        'Doors': 1,\n        'Windows': 0\n    },\n    'Plant2': {\n        'Doors': 0,\n        'Windows': 2\n    },\n    'Plant3': {\n        'Doors': 3,\n        'Windows': 2\n    }\n}\n\n### MODEL CONSTRUCTION ###\n#Declaration\nmodel = ConcreteModel()\n\n#Decision Variables\nmodel.weekly_prod = Var(products, domain=NonNegativeReals)\n\n#Objective\nmodel.profit = Objective(expr=sum(profit_rate[pr] * model.weekly_prod[pr]\n                               for pr in products),\n                      sense=maximize)\n\n#Constraints\nmodel.capacity = ConstraintList()\nfor pl in plants:\n    model.capacity.add(\n        sum(hours_per_batch[pl][pr] * model.weekly_prod[pr]\n            for pr in products) <= hours_available[pl])\n\n### SOLUTION ###\nsolver = SolverFactory('glpk')\nsolver.solve(model)\n\n### OUTPUT ###\n\n# note that we're using f-strings for output here which is a little different and cleaner than in the video\nprint(f\"Maximum Profit = ${1000*model.profit():,.2f}\")\nfor j in products:\n    print(f\"Batches of {j} = {model.weekly_prod[j]():.1f}\")","kernel":"python3","metadata":{"code_folding":[]},"no_halt":true,"output":{"0":{"name":"stdout","text":"Maximum Profit = $36,000.00\nBatches of Doors = 2.0\nBatches of Windows = 6.0\n"}},"pos":14,"start":1661536714260,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536714425,"exec_count":4,"id":"0b92da","input":"# the objective function:\nmodel.profit.pprint()\n\n# the constraints:\nmodel.capacity.pprint()","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"profit : Size=1, Index=None, Active=True\n    Key  : Active : Sense    : Expression\n    None :   True : maximize : 3*weekly_prod[Doors] + 5*weekly_prod[Windows]\ncapacity : Size=3, Index=capacity_index, Active=True\n    Key : Lower : Body                                          : Upper : Active\n      1 :  -Inf :                            weekly_prod[Doors] :   4.0 :   True\n      2 :  -Inf :                        2*weekly_prod[Windows] :  12.0 :   True\n      3 :  -Inf : 3*weekly_prod[Doors] + 2*weekly_prod[Windows] :  18.0 :   True\n"}},"pos":16,"start":1661536714419,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536714466,"exec_count":5,"id":"3920aa","input":"### PROBLEM DATA ###\n\n# load data\nproducts = ['Doors', 'Windows']\nplants = ['Plant1', 'Plant2', 'Plant3']\nprofit_rate_list = [3,5]\nhours_avail_list = [4,12,18]\nhours_per_batch_list = [ [1,0], [0,2], [3,2] ]\n\n# parse lists into dictionaries\nprofit_rate = dict( zip( products, profit_rate_list) )\nhours_available = dict( zip( plants, hours_avail_list) )\nhours_per_batch = { pl: { pr: hours_per_batch_list[i][j] for j,pr in enumerate(products)} for i,pl in enumerate(plants)}\n\n### MODEL CONSTRUCTION ###\n#Declaration\nmodel = ConcreteModel()\n\n#Decision Variables\nmodel.weekly_prod = Var(products, domain=NonNegativeReals)\n\n#Objective\nmodel.profit = Objective(expr=sum(profit_rate[pr] * model.weekly_prod[pr]\n                               for pr in products),\n                      sense=maximize)\n\n#Constraints\nmodel.capacity = ConstraintList()\nfor pl in plants:\n    model.capacity.add(\n        sum(hours_per_batch[pl][pr] * model.weekly_prod[pr]\n            for pr in products) <= hours_available[pl])\n\n### SOLUTION ###\nsolver = SolverFactory('glpk')\nsolver.solve(model)\n\n### OUTPUT ###\n\n# note that we're using f-strings for output here which is a little different and cleaner than in the video\nprint(f\"Maximum Profit = ${1000*model.profit():,.2f}\")\nfor j in products:\n    print(f\"Batches of {j} = {model.weekly_prod[j]():.1f}\")","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"Maximum Profit = $36,000.00\nBatches of Doors = 2.0\nBatches of Windows = 6.0\n"}},"pos":18,"start":1661536714436,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536714503,"exec_count":6,"id":"6bf8ce","input":"### PROBLEM DATA ###\n\n# load data\nproducts = ['Doors', 'Windows']\nplants = ['Plant1', 'Plant2', 'Plant3']\nprofit_rate_list = [3,5]\nhours_avail_list = [4,12,18]\nhours_per_batch_list = [ [1,0], [0,2], [3,2] ]\n\n# parse lists into Pandas\nprofit_rate = pd.Series( profit_rate_list, index = products)\nhours_available = pd.Series( hours_avail_list, index = plants)\nhours_per_batch = pd.DataFrame( hours_per_batch_list, index = plants, columns = products)\n\n### MODEL CONSTRUCTION ###\n#Declaration\nmodel = ConcreteModel()\n\n#Decision Variables\nmodel.weekly_prod = Var(products, domain=NonNegativeReals)\n\n#Objective\nmodel.profit = Objective(expr=sum(profit_rate[pr] * model.weekly_prod[pr]\n                               for pr in products),\n                      sense=maximize)\n\n#Constraints\nmodel.capacity = ConstraintList()\nfor pl in plants:\n    model.capacity.add(\n        sum(hours_per_batch.loc[pl,pr] * model.weekly_prod[pr]\n            for pr in products) <= hours_available[pl])\n\n### SOLUTION ###\nsolver = SolverFactory('glpk')\nsolver.solve(model)\n\n### OUTPUT ###\n\n# note that we're using f-strings for output here which is a little different and cleaner than in the video\nprint(f\"Maximum Profit = ${1000*model.profit():,.2f}\")\nfor j in products:\n    print(f\"Batches of {j} = {model.weekly_prod[j]():.1f}\")","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"Maximum Profit = $36,000.00\nBatches of Doors = 2.0\nBatches of Windows = 6.0\n"}},"pos":20,"start":1661536714471,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536714967,"exec_count":7,"id":"7a1969","input":"### PROBLEM DATA ###\n\n# load data\nnum_products = 2\nnum_plants = 3\nprofit_rate = [3,5]\nhours_available = [4,12,18]\nhours_per_batch = [[1,0],[0,2],[3,2]]\n\n### MODEL CONSTRUCTION ###\n#Declaration\nmodel = ConcreteModel()\n\n#Decision Variables\nmodel.weekly_prod = Var(range(num_products), domain=NonNegativeReals)\n\n#Objective\nmodel.profit = Objective(expr=sum(profit_rate[pr] * model.weekly_prod[pr]\n                               for pr in range(num_products)),\n                      sense=maximize)\n\n# Constraints\nmodel.capacity = ConstraintList()\nfor pl in range(num_plants):\n    model.capacity.add(\n        sum(hours_per_batch[pl][pr] * model.weekly_prod[pr]\n            for pr in range(num_products)) <= hours_available[pl])\n\n### SOLUTION ###\nsolver = SolverFactory('glpk')\nsolver.solve(model)\n\n### OUTPUT ###\nprint(f\"Maximum Profit = ${1000*model.profit():,.2f}\")\nfor pr in range(num_products):\n    print(f\"Batches of {pr} = {model.weekly_prod[pr]():.0f}\")","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"Maximum Profit = $36,000.00\nBatches of 0 = 2\nBatches of 1 = 6\n"}},"pos":22,"start":1661536714552,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536714983,"exec_count":8,"id":"29b589","input":"# the objective function:\nmodel.profit.pprint()\n\n# the constraints:\nmodel.capacity.pprint()","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"profit : Size=1, Index=None, Active=True\n    Key  : Active : Sense    : Expression\n    None :   True : maximize : 3*weekly_prod[0] + 5*weekly_prod[1]\ncapacity : Size=3, Index=capacity_index, Active=True\n    Key : Lower : Body                                : Upper : Active\n      1 :  -Inf :                      weekly_prod[0] :   4.0 :   True\n      2 :  -Inf :                    2*weekly_prod[1] :  12.0 :   True\n      3 :  -Inf : 3*weekly_prod[0] + 2*weekly_prod[1] :  18.0 :   True\n"}},"pos":24,"start":1661536714977,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536715070,"exec_count":9,"id":"ba295b","input":"# details not important, dataframe for example\ndf = pd.DataFrame([[10, 11, 12, 13, 14],[15,16,17,18,0],[19,20,21,0,0],[22,23,0,0,0],[24,0,0,0,0]], \n                  index = [1,2,3,4,5], columns = [1,2,3,4,5] )\ndf","kernel":"python3","metadata":{"code_folding":[]},"no_halt":true,"output":{"0":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>1</th>\n      <td>10</td>\n      <td>11</td>\n      <td>12</td>\n      <td>13</td>\n      <td>14</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>15</td>\n      <td>16</td>\n      <td>17</td>\n      <td>18</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>19</td>\n      <td>20</td>\n      <td>21</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>22</td>\n      <td>23</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>24</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"    1   2   3   4   5\n1  10  11  12  13  14\n2  15  16  17  18   0\n3  19  20  21   0   0\n4  22  23   0   0   0\n5  24   0   0   0   0"},"exec_count":9}},"pos":35,"start":1661536714988,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536715101,"exec_count":10,"id":"8185ad","input":"# execute this cell for video\nplay_video(\"ds775_lesson2-webmercantile-abstract\")","kernel":"python3","metadata":{"code_folding":[0],"hidden":true},"no_halt":true,"output":{"0":{"data":{"iframe":"628f2d7240f1cb408e05d6380a769114b6a71b59","text/plain":"<IPython.lib.display.IFrame at 0x7f1680d24f70>"},"exec_count":10}},"pos":39,"start":1661536715075,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536715169,"exec_count":11,"id":"51c263","input":"# abstract Web Mercantile\n\n### Problem Data ###\nnum_months = 5\nmax_duration = 5\n\nmonths = range(1, num_months + 1) # generates 1, 2, ..., num_months\ndurations = range(1, max_duration + 1) # generates 1, 2, ..., max_duration\n\nrent = dict(zip(durations, [65, 100, 135, 160, 190]))\nspace = dict(zip(months, [30000, 20000, 40000, 10000, 50000]))\n\n### Pyomo Model ###\n\n# Concrete Model\nmodel = ConcreteModel(name=\"WebMerc2\")\n\n# Decision Variables\nmodel.x_sqft = Var(months, durations, domain=NonNegativeReals)\n\n# Objective (minimize is the default so it's not stated explicitly here)\nmodel.obj = Objective(expr=sum(rent[d] * model.x_sqft[m, d] for m in months\n                               for d in durations))\n\n# Constraints\nmodel.space_ct = ConstraintList()\nfor month in months:\n    model.space_ct.add(\n        sum(model.x_sqft[m, d] for m in months for d in durations\n            if m <= month and m + d > month) >= space[month])\n\nmodel.time_rule_ct = ConstraintList()\nfor m in months:\n    for d in durations:\n        if m + d > num_months + 1:\n            model.time_rule_ct.add(model.x_sqft[m, d] == 0)\n\n### Solution ###\n\nsolver = SolverFactory('glpk')\nsolver.solve(model)\n\n### Display ###\n# note that output is formatted with f-strings unlike the video\n\nprint(f\"Total Cost = ${model.obj():,.2f}\")\n\nprint(\"\\nHere are the amounts to lease by month and duration:\")\nfor m in months:\n    for d in durations:\n        if model.x_sqft[m, d]() > 0:\n            print(f\"Lease {model.x_sqft[m, d]():.0f} sq ft in month {m:d} for {d:d} months\")\n\nprint(\"\\nHere are the amounts needed and the total amount needed in each month:\")\nfor m in months:\n    amount_leased = sum(model.x_sqft[i, d]() for d in durations for i in months if i <= m and i + d > m)\n    print(f\"In month {m:d}, {space[m]:.0f} square feet are needed and {amount_leased:.0f} square feet are leased\")","kernel":"python3","metadata":{"code_folding":[0]},"no_halt":true,"output":{"0":{"name":"stdout","text":"Total Cost = $7,650,000.00\n\nHere are the amounts to lease by month and duration:\nLease 30000 sq ft in month 1 for 5 months\nLease 10000 sq ft in month 3 for 1 months\nLease 20000 sq ft in month 5 for 1 months\n\nHere are the amounts needed and the total amount needed in each month:\nIn month 1, 30000 square feet are needed and 30000 square feet are leased\nIn month 2, 20000 square feet are needed and 30000 square feet are leased\nIn month 3, 40000 square feet are needed and 40000 square feet are leased\nIn month 4, 10000 square feet are needed and 30000 square feet are leased\nIn month 5, 50000 square feet are needed and 50000 square feet are leased\n"}},"pos":41,"start":1661536715118,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536715194,"exec_count":12,"id":"e2ee29","input":"# execute this cell for video\nplay_video(\"ds775_lesson2-blending-abstract\")","kernel":"python3","metadata":{"code_folding":[0]},"no_halt":true,"output":{"0":{"data":{"iframe":"2ea998d1040bbbe01d6cfcc9157853dcbddc1037","text/plain":"<IPython.lib.display.IFrame at 0x7f1680d248e0>"},"exec_count":12}},"pos":52,"start":1661536715173,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536715298,"exec_count":13,"id":"12c47f","input":"# abstract Sausage Factory\n\n### Problem Data ###\n\ntypes = ['economy','premium']\ningredients = ['pork', 'wheat', 'starch']\n\ncost = dict( zip( ingredients, [4.32, 2.46, 1.86] ) )\n\nkg_per_sausage = 0.05\nnumber_each_type = dict( zip( types, [350, 500] ) )\n\nmnpi = [[.4,.6],[0,0],[0,0]] # min proportions\nmin_prop_ing = { ingredients[i]:{ types[j]:mnpi[i][j] for j in range(len(types)) } for i in range(len(ingredients)) }\nmxpi = [[1,1],[1,1],[.25,.25]] # max proportions\nmax_prop_ing = { ingredients[i]:{ types[j]:mxpi[i][j] for j in range(len(types)) } for i in range(len(ingredients)) }\n\nmax_ingredient = dict( zip( ingredients, [30, 20, 17] ) )\nmin_ingredient = dict( zip( ingredients, [23,  0,  0] ) )\n\n### Pyomo Model ###\n\n# Concrete Model\nM = ConcreteModel(name = \"Sausages\")\n\n# Decision Variables\nM.amount = Var(ingredients, types, domain = NonNegativeReals)\n\n# Objective\nM.cost = Objective( expr = sum( cost[i] * sum(M.amount[i,t] for t in types) \n                               for i in ingredients), sense = minimize )\n\nM.tot_sausages_ct = ConstraintList()\nfor t in types:\n    M.tot_sausages_ct.add( sum( M.amount[i,t] for i in ingredients ) \n                         == kg_per_sausage * number_each_type[t] )\n\nM.min_prop_ct = ConstraintList()\nfor i in ingredients:\n    for t in types:\n        M.min_prop_ct.add( M.amount[i,t] >= min_prop_ing[i][t] *\n                         sum( M.amount[k,t] for k in ingredients ) )\n\nM.max_prop_ct = ConstraintList()\nfor i in ingredients:\n    for t in types:\n        M.max_prop_ct.add( M.amount[i,t] <= max_prop_ing[i][t] * \n                         sum( M.amount[k, t] for k in ingredients ) )\n        \nM.max_ingredient_ct = ConstraintList()\nfor i in ingredients:\n    M.max_ingredient_ct.add( sum( M.amount[ i, t] for t in types ) <= \n                           max_ingredient[i] )\n    \nM.min_ingredient_ct = ConstraintList()\nfor i in ingredients:\n    M.min_ingredient_ct.add( sum( M.amount[ i, t] for t in types ) >=\n                           min_ingredient[i] )\n\n### Solution ###\nsolver = SolverFactory('glpk')\nsolver.solve(M)\n\n### Output ###\nprint(f\"Total Cost = ${M.cost():,.2f}\")\n\n# put amounts in dataframe for nicer display\nimport pandas as pd\ndvars = pd.DataFrame( [ [M.amount[i,t]() for t in types] for i in ingredients ],\n                    index = ['Pork','Wheat','Starch'],\n                    columns = ['Economy','Premium'])\nprint(\"Kilograms of each ingredient in each type of sausage:\")\ndvars","kernel":"python3","metadata":{"code_folding":[]},"no_halt":true,"output":{"0":{"name":"stdout","text":"Total Cost = $140.96\nKilograms of each ingredient in each type of sausage:\n"},"1":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Economy</th>\n      <th>Premium</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Pork</th>\n      <td>8.000</td>\n      <td>15.00</td>\n    </tr>\n    <tr>\n      <th>Wheat</th>\n      <td>5.125</td>\n      <td>3.75</td>\n    </tr>\n    <tr>\n      <th>Starch</th>\n      <td>4.375</td>\n      <td>6.25</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"        Economy  Premium\nPork      8.000    15.00\nWheat     5.125     3.75\nStarch    4.375     6.25"},"exec_count":13}},"pos":54,"start":1661536715205,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536715318,"exec_count":14,"id":"8b7805","input":"# execute cell for video\nplay_video(\"ds775_lesson2_what-is-sensitivity-analysis\")","kernel":"python3","no_halt":true,"output":{"0":{"data":{"iframe":"c829f1e3a50e3dedc3f813a768af5fe8cd03af3b","text/plain":"<IPython.lib.display.IFrame at 0x7f16705c4850>"},"exec_count":14}},"pos":58,"start":1661536715304,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536715368,"exec_count":15,"id":"5448e5","input":"# execute cell for video\nplay_video(\"ds775_lesson2_active-vs-inactive-constraints\")","kernel":"python3","no_halt":true,"output":{"0":{"data":{"iframe":"bbc4a367f8acffaead0da4993f4a5d51144106f8","text/plain":"<IPython.lib.display.IFrame at 0x7f1694b7dd00>"},"exec_count":15}},"pos":60,"start":1661536715324,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536715392,"exec_count":16,"id":"a40a6c","input":"# execute cell for video\nplay_video(\"ds775_lesson2_shadow-prices\")","kernel":"python3","no_halt":true,"output":{"0":{"data":{"iframe":"88f380c0bee7444bea28a26561823540060ab8f0","text/plain":"<IPython.lib.display.IFrame at 0x7f1694b7de20>"},"exec_count":16}},"pos":62,"start":1661536715372,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536715413,"exec_count":17,"id":"dea478","input":"# new video for allowable range of constraint right side\nplay_video(\"ds775_lesson2_allowable-range-constraint-bounds\")","kernel":"python3","no_halt":true,"output":{"0":{"data":{"iframe":"1cb8fcba7a34247b3f446a26cdeed30e0496a7f3","text/plain":"<IPython.lib.display.IFrame at 0x7f1694b7d190>"},"exec_count":17}},"pos":64,"start":1661536715399,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536715435,"exec_count":18,"id":"33414c","input":"# new video for obj function coef allowable range\nplay_video(\"ds775_lesson2_allowable-range-obj-function-coefficients\")","kernel":"python3","metadata":{"code_folding":[0]},"no_halt":true,"output":{"0":{"data":{"iframe":"c4efb19c4f92ce0da54f91aa1de9782c1effdeba","text/plain":"<IPython.lib.display.IFrame at 0x7f1694b7dcd0>"},"exec_count":18}},"pos":66,"start":1661536715419,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536715557,"exec_count":19,"id":"fd7fe4","input":"### PROBLEM DATA ###\n\n# load data\nproducts = ['Doors', 'Windows']\nplants = ['Plant1', 'Plant2', 'Plant3']\nprofit_rate_list = [3,5]\nhours_avail_list = [4,12,18]\nhours_per_batch_list = [ [1,0], [0,2], [3,2] ]\n\n# parse lists into dictionaries\nprofit_rate = dict( zip( products, profit_rate_list) )\nhours_available = dict( zip( plants, hours_avail_list) )\nhours_per_batch = { pl: { pr: hours_per_batch_list[i][j] for j,pr in enumerate(products)} for i,pl in enumerate(plants)}\n\n### MODEL CONSTRUCTION ###\n#Declaration\nmodel = ConcreteModel()\n\n#Decision Variables\nmodel.weekly_prod = Var(products, domain=NonNegativeReals)\n\n#Objective\nmodel.profit = Objective(expr=sum(profit_rate[pr] * model.weekly_prod[pr]\n                               for pr in products),\n                      sense=maximize)\n\n#Constraints\nmodel.capacity = ConstraintList()\nfor pl in plants:\n    model.capacity.add(\n        sum(hours_per_batch[pl][pr] * model.weekly_prod[pr]\n            for pr in products) <= hours_available[pl])\n\n### SOLUTION ###\nsolver = SolverFactory('glpk')\nsolver.solve(model)\n\n### OUTPUT ###\n\n# note that we're using f-strings for output here which is a little different and cleaner than in the video\nprint(f\"Maximum Profit = ${1000*model.profit():,.2f}\")\nfor j in products:\n    print(f\"Batches of {j} = {model.weekly_prod[j]():.1f}\")","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"Maximum Profit = $36,000.00\nBatches of Doors = 2.0\nBatches of Windows = 6.0\n"}},"pos":77,"start":1661536715457,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536715880,"exec_count":20,"id":"cf7d08","input":"model.write('model.lp', io_options={'symbolic_solver_labels': True})","kernel":"python3","no_halt":true,"output":{"0":{"data":{"text/plain":"('model.lp', 139734351105520)"},"exec_count":20}},"pos":79,"start":1661536715876,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716080,"exec_count":21,"id":"be79bf","input":"!glpsol -m model.lp --lp --ranges sensit.sen","kernel":"python3","metadata":{"hidden":true},"no_halt":true,"output":{"0":{"name":"stdout","text":"GLPSOL: GLPK LP/MIP Solver, v4.65\r\nParameter(s) specified in the command line:\r\n -m model.lp --lp --ranges sensit.sen\r\nReading problem data from 'model.lp'...\r\n4 rows, 3 columns, 5 non-zeros\r\n29 lines were read\r\nGLPK Simplex Optimizer, v4.65\r\n4 rows, 3 columns, 5 non-zeros\r\nPreprocessing...\r\n1 row, 2 columns, 2 non-zeros\r\nScaling...\r\n A: min|aij| =  2.000e+00  max|aij| =  3.000e+00  ratio =  1.500e+00\r\nProblem data seem to be well scaled\r\nConstructing initial basis...\r\nSize of triangular part is 1\r\n*     0: obj =  -0.000000000e+00 inf =   0.000e+00 (2)\r\n*     2: obj =   3.600000000e+01 inf =   0.000e+00 (0)\r\nOPTIMAL LP SOLUTION FOUND\r\nTime used:   0.0 secs\r\nMemory used: 0.0 Mb (40400 bytes)\r\nWrite sensitivity analysis report to 'sensit.sen'...\r\n"}},"pos":80,"scrolled":true,"start":1661536715893,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716100,"exec_count":22,"id":"915ec9","input":"# print sensitivity report\nnp.set_printoptions(linewidth=110)\nf = open('sensit.sen', 'r')\nfile_contents = f.read()\nprint(file_contents)\nf.close()","kernel":"python3","metadata":{"code_folding":[],"hidden":true},"no_halt":true,"output":{"0":{"name":"stdout","text":"GLPK 4.65 - SENSITIVITY ANALYSIS REPORT                                                                         Page   1\n\nProblem:    \nObjective:  profit = 36 (MAXimum)\n\n   No. Row name     St      Activity         Slack   Lower bound       Activity      Obj coef  Obj value at Limiting\n                                          Marginal   Upper bound          range         range   break point variable\n------ ------------ -- ------------- ------------- -------------  ------------- ------------- ------------- ------------\n     1 c_u_capacity(1)_\n                    BS       2.00000       2.00000          -Inf         .           -3.00000      30.00000 c_u_capacity(3)_\n                                            .            4.00000        6.00000       4.50000      45.00000 c_u_capacity(2)_\n\n     2 c_u_capacity(2)_\n                    NU      12.00000        .               -Inf        6.00000      -1.50000      27.00000 c_u_capacity(1)_\n                                           1.50000      12.00000       18.00000          +Inf      45.00000 weekly_prod(Doors)\n\n     3 c_u_capacity(3)_\n                    NU      18.00000        .               -Inf       12.00000      -1.00000      30.00000 weekly_prod(Doors)\n                                           1.00000      18.00000       24.00000          +Inf      42.00000 c_u_capacity(1)_\n\n     4 c_e_ONE_VAR_CONSTANT\n                    NS       1.00000        .            1.00000         .               -Inf      36.00000 ONE_VAR_CONSTANT\n                                            .            1.00000           +Inf          +Inf      36.00000\n\nGLPK 4.65 - SENSITIVITY ANALYSIS REPORT                                                                         Page   2\n\nProblem:    \nObjective:  profit = 36 (MAXimum)\n\n   No. Column name  St      Activity      Obj coef   Lower bound       Activity      Obj coef  Obj value at Limiting\n                                          Marginal   Upper bound          range         range   break point variable\n------ ------------ -- ------------- ------------- -------------  ------------- ------------- ------------- ------------\n     1 weekly_prod(Doors)\n                    BS       2.00000       3.00000        .                -Inf        .           30.00000 c_u_capacity(3)_\n                                            .               +Inf        4.00000       7.50000      45.00000 c_u_capacity(2)_\n\n     2 weekly_prod(Windows)\n                    BS       6.00000       5.00000        .             3.00000       2.00000      18.00000 c_u_capacity(2)_\n                                            .               +Inf        6.00000          +Inf          +Inf\n\n     3 ONE_VAR_CONSTANT\n                    BS       1.00000        .             .             1.00000          -Inf          -Inf\n                                            .               +Inf        1.00000          +Inf          +Inf\n\nEnd of report\n\n"}},"pos":82,"start":1661536716094,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716115,"exec_count":23,"id":"7b0729","input":"x <= 4\nx is between -infinity and 4\nx is in the open interval (-infinty,10]","kernel":"python3","no_halt":true,"output":{"0":{"ename":"SyntaxError","evalue":"invalid syntax (1360551216.py, line 3)","traceback":["\u001b[0;36m  File \u001b[0;32m\"/tmp/ipykernel_627/1360551216.py\"\u001b[0;36m, line \u001b[0;32m3\u001b[0m\n\u001b[0;31m    x is in the open interval (-infinty,10]\u001b[0m\n\u001b[0m         ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid syntax\n"]}},"pos":83,"start":1661536716105,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716138,"exec_count":24,"id":"2acf0e","input":"plants = ['Plant1', 'Plant2', 'Plant3']\nhours_avail = [4, 12, 18]","kernel":"python3","no_halt":true,"pos":91,"start":1661536716123,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716159,"exec_count":25,"id":"df29aa","input":"# method 0 - type it out (This method should be avoided where possible.)\nhours_avail_dict = { 'Plant1':4, 'Plant2':12, 'Plant3':18}\nprint(hours_avail_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': 4, 'Plant2': 12, 'Plant3': 18}\n"}},"pos":92,"start":1661536716149,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716175,"exec_count":26,"id":"c3871f","input":"# method 1 - use a for loop\nhours_avail_dict = {}\nfor i in range( len(plants) ):\n    hours_avail_dict[ plants[i] ] = hours_avail[i]\n\nprint(hours_avail_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': 4, 'Plant2': 12, 'Plant3': 18}\n"}},"pos":93,"start":1661536716164,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716190,"exec_count":27,"id":"735fad","input":"# method 2 - use a for loop, v2 with zip\nhours_avail_dict = {}\nfor p,h in zip(plants,hours_avail):\n    hours_avail_dict[ p ] = h\n\nprint(hours_avail_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': 4, 'Plant2': 12, 'Plant3': 18}\n"}},"pos":94,"start":1661536716179,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716219,"exec_count":28,"id":"c1c60a","input":"# method 3 - use a for loop, v3 with enumerate\nhours_avail_dict = {}\nfor i, pl in enumerate(plants):\n    hours_avail_dict[ pl ] = hours_avail[i]\n\nprint(hours_avail_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': 4, 'Plant2': 12, 'Plant3': 18}\n"}},"pos":96,"start":1661536716195,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716253,"exec_count":29,"id":"feab0a","input":"# method 4 - use a comprehension (compare to method 1)\nhours_avail_dict = { plants[i]:hours_avail[i] for i in range( len(plants) )}\nprint(hours_avail_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': 4, 'Plant2': 12, 'Plant3': 18}\n"}},"pos":97,"start":1661536716224,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716265,"exec_count":30,"id":"78b811","input":"# method 5 - use a comprehension with zip (compare to method 2)\nhours_avail_dict = { p:h for p,h in zip(plants,hours_avail)}\nprint(hours_avail_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': 4, 'Plant2': 12, 'Plant3': 18}\n"}},"pos":98,"start":1661536716258,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716290,"exec_count":31,"id":"6f6c1f","input":"# method 6 - use a comprehension with enumerate (compare to method 3)\nhours_avail_dict = { pl:hours_avail[i] for i,pl in enumerate(plants)}\nprint(hours_avail_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': 4, 'Plant2': 12, 'Plant3': 18}\n"}},"pos":99,"start":1661536716272,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716308,"exec_count":32,"id":"9da672","input":"# method 7 - use the dictionary constructor along with zip (most 'Pythonic' approach)\nhours_avail_dict = dict( zip( plants, hours_avail) )\nprint(hours_avail_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': 4, 'Plant2': 12, 'Plant3': 18}\n"}},"pos":100,"start":1661536716295,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716482,"exec_count":33,"id":"2ca7b3","input":"# method 10 - nested dictionary from nested for loop\nproducts = ['Doors', 'Windows']\nplants = ['Plant1', 'Plant2', 'Plant3']\nhours_per_batch = [ [1, 0], [0, 2], [3, 2] ]\n\nhours_per_batch_dict = {}\nfor i in range( len(plants) ):\n    hours_per_batch_dict[plants[i]] = {}\n    for j in range( len(products) ):\n        hours_per_batch_dict[plants[i]][products[j]] = hours_per_batch[i][j]\n        \nprint(hours_per_batch_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': {'Doors': 1, 'Windows': 0}, 'Plant2': {'Doors': 0, 'Windows': 2}, 'Plant3': {'Doors': 3, 'Windows': 2}}\n"}},"pos":102,"start":1661536716377,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716806,"exec_count":34,"id":"12733c","input":"# method 11 - nested dictionary from nested for loop with enumerate\nproducts = ['Doors', 'Windows']\nplants = ['Plant1', 'Plant2', 'Plant3']\nhours_per_batch = [ [1, 0], [0, 2], [3, 2] ]\n\nhours_per_batch_dict = {}\nfor i,pl in enumerate(plants):\n    hours_per_batch_dict[ pl ]= {}\n    for j,pr in enumerate(products):\n        hours_per_batch_dict[ pl ][ pr ] = hours_per_batch[ i ][ j ]\n        \nprint(hours_per_batch_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': {'Doors': 1, 'Windows': 0}, 'Plant2': {'Doors': 0, 'Windows': 2}, 'Plant3': {'Doors': 3, 'Windows': 2}}\n"}},"pos":103,"start":1661536716490,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716854,"exec_count":35,"id":"9abba4","input":"# method 12 - comprehension without enumerate\nproducts = ['Doors', 'Windows']\nplants = ['Plant1', 'Plant2', 'Plant3']\nhours_per_batch = [ [1, 0], [0, 2], [3, 2] ]\n\nhours_per_batch_dict = { plants[i]: { products[j]: hours_per_batch[i][j] for j in range( len(products) )} for i in range( len(plants) )}\n        \nprint(hours_per_batch_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': {'Doors': 1, 'Windows': 0}, 'Plant2': {'Doors': 0, 'Windows': 2}, 'Plant3': {'Doors': 3, 'Windows': 2}}\n"}},"pos":104,"start":1661536716813,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716872,"exec_count":36,"id":"a83e39","input":"# method 13 - comprehension with enumerate\nproducts = ['Doors', 'Windows']\nplants = ['Plant1', 'Plant2', 'Plant3']\nhours_per_batch = [ [1, 0], [0, 2], [3, 2] ]\n\nhours_per_batch_dict = { pl: { pr: hours_per_batch[i][j] for j,pr in enumerate(products)} for i,pl in enumerate(plants)}\n        \nprint(hours_per_batch_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': {'Doors': 1, 'Windows': 0}, 'Plant2': {'Doors': 0, 'Windows': 2}, 'Plant3': {'Doors': 3, 'Windows': 2}}\n"}},"pos":105,"start":1661536716860,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716901,"exec_count":37,"id":"4126d2","input":"# method 14 - comprehension with enumerate, replace inner with dict+zip construction\nproducts = ['Doors', 'Windows']\nplants = ['Plant1', 'Plant2', 'Plant3']\nhours_per_batch = [ [1, 0], [0, 2], [3, 2] ]\n\nhours_per_batch_dict = { pl: dict( zip( products, hours_per_batch[i]) ) for i,pl in enumerate(plants)}\n        \nprint(hours_per_batch_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': {'Doors': 1, 'Windows': 0}, 'Plant2': {'Doors': 0, 'Windows': 2}, 'Plant3': {'Doors': 3, 'Windows': 2}}\n"}},"pos":106,"start":1661536716876,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536716951,"exec_count":38,"id":"4263ea","input":"# method 15 - using dict+zip without enumerate\nproducts = ['Doors', 'Windows']\nplants = ['Plant1', 'Plant2', 'Plant3']\nhours_per_batch = [ [1, 0], [0, 2], [3, 2] ]\n\nhours_per_batch_dict = dict( zip( plants, [dict( zip( products, row)) for row in hours_per_batch] ))\n        \nprint(hours_per_batch_dict)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"{'Plant1': {'Doors': 1, 'Windows': 0}, 'Plant2': {'Doors': 0, 'Windows': 2}, 'Plant3': {'Doors': 3, 'Windows': 2}}\n"}},"pos":107,"start":1661536716908,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536717004,"exec_count":39,"id":"6c8d27","input":"### PROBLEM DATA ###\n\n# load data\nproducts = ['Doors', 'Windows']\nplants = ['Plant1', 'Plant2', 'Plant3']\nprofit_rate_list = [3,5]\nhours_avail_list = [4,12,18]\nhours_per_batch_list = [ [1,0], [0,2], [3,2] ]\n\n# parse lists into Pandas\nprofit_rate = pd.Series( profit_rate_list, index = products)\nhours_available = pd.Series( hours_avail_list, index = plants)\nhours_per_batch = pd.DataFrame( hours_per_batch_list, index = plants, columns = products)\n\n### MODEL CONSTRUCTION ###\n#Declaration\nmodel = ConcreteModel()\n\n#Decision Variables\nmodel.weekly_prod = Var(products, domain=NonNegativeReals)\n\n#Objective\nmodel.profit = Objective(expr=sum(profit_rate[pr] * model.weekly_prod[pr]\n                               for pr in products),\n                      sense=maximize)\n\n#Constraints\nmodel.capacity = ConstraintList()\nfor pl in plants:\n    model.capacity.add(\n        sum(hours_per_batch.loc[pl,pr] * model.weekly_prod[pr]\n            for pr in products) <= hours_available[pl])\n\n### SOLUTION ###\nsolver = SolverFactory('glpk')\nsolver.solve(model)\n\n### OUTPUT ###\n\n# note that we're using f-strings for output here which is a little different and cleaner than in the video\nprint(f\"Maximum Profit = ${1000*model.profit():,.2f}\")\nfor j in products:\n    print(f\"Batches of {j} = {model.weekly_prod[j]():.1f}\")","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"Maximum Profit = $36,000.00\nBatches of Doors = 2.0\nBatches of Windows = 6.0\n"}},"pos":110,"start":1661536716960,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536717165,"exec_count":40,"id":"b8fb71","input":"# write the model to a sensitivity report\nmodel.write('model.lp', io_options={'symbolic_solver_labels': True})\n!glpsol -m model.lp --lp --ranges sensit.sen","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"GLPSOL: GLPK LP/MIP Solver, v4.65\r\nParameter(s) specified in the command line:\r\n -m model.lp --lp --ranges sensit.sen\r\nReading problem data from 'model.lp'...\r\n4 rows, 3 columns, 5 non-zeros\r\n29 lines were read\r\nGLPK Simplex Optimizer, v4.65\r\n4 rows, 3 columns, 5 non-zeros\r\nPreprocessing...\r\n1 row, 2 columns, 2 non-zeros\r\nScaling...\r\n A: min|aij| =  2.000e+00  max|aij| =  3.000e+00  ratio =  1.500e+00\r\nProblem data seem to be well scaled\r\nConstructing initial basis...\r\nSize of triangular part is 1\r\n*     0: obj =  -0.000000000e+00 inf =   0.000e+00 (2)\r\n*     2: obj =   3.600000000e+01 inf =   0.000e+00 (0)\r\nOPTIMAL LP SOLUTION FOUND\r\nTime used:   0.0 secs\r\nMemory used: 0.0 Mb (40400 bytes)\r\nWrite sensitivity analysis report to 'sensit.sen'...\r\n"}},"pos":111,"start":1661536717011,"state":"done","type":"cell"}
{"cell_type":"code","end":1661536717191,"exec_count":41,"id":"32ceb2","input":"# widen browser and/or close TOC to see sensitivity report\nimport numpy as np\nnp.set_printoptions(linewidth=110)\nf = open('sensit.sen', 'r')\nfile_contents = f.read()\nprint(file_contents)\nf.close()","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"GLPK 4.65 - SENSITIVITY ANALYSIS REPORT                                                                         Page   1\n\nProblem:    \nObjective:  profit = 36 (MAXimum)\n\n   No. Row name     St      Activity         Slack   Lower bound       Activity      Obj coef  Obj value at Limiting\n                                          Marginal   Upper bound          range         range   break point variable\n------ ------------ -- ------------- ------------- -------------  ------------- ------------- ------------- ------------\n     1 c_u_capacity(1)_\n                    BS       2.00000       2.00000          -Inf         .           -3.00000      30.00000 c_u_capacity(3)_\n                                            .            4.00000        6.00000       4.50000      45.00000 c_u_capacity(2)_\n\n     2 c_u_capacity(2)_\n                    NU      12.00000        .               -Inf        6.00000      -1.50000      27.00000 c_u_capacity(1)_\n                                           1.50000      12.00000       18.00000          +Inf      45.00000 weekly_prod(Doors)\n\n     3 c_u_capacity(3)_\n                    NU      18.00000        .               -Inf       12.00000      -1.00000      30.00000 weekly_prod(Doors)\n                                           1.00000      18.00000       24.00000          +Inf      42.00000 c_u_capacity(1)_\n\n     4 c_e_ONE_VAR_CONSTANT\n                    NS       1.00000        .            1.00000         .               -Inf      36.00000 ONE_VAR_CONSTANT\n                                            .            1.00000           +Inf          +Inf      36.00000\n\nGLPK 4.65 - SENSITIVITY ANALYSIS REPORT                                                                         Page   2\n\nProblem:    \nObjective:  profit = 36 (MAXimum)\n\n   No. Column name  St      Activity      Obj coef   Lower bound       Activity      Obj coef  Obj value at Limiting\n                                          Marginal   Upper bound          range         range   break point variable\n------ ------------ -- ------------- ------------- -------------  ------------- ------------- ------------- ------------\n     1 weekly_prod(Doors)\n                    BS       2.00000       3.00000        .                -Inf        .           30.00000 c_u_capacity(3)_\n                                            .               +Inf        4.00000       7.50000      45.00000 c_u_capacity(2)_\n\n     2 weekly_prod(Windows)\n                    BS       6.00000       5.00000        .             3.00000       2.00000      18.00000 c_u_capacity(2)_\n                                            .               +Inf        6.00000          +Inf          +Inf\n\n     3 ONE_VAR_CONSTANT\n                    BS       1.00000        .             .             1.00000          -Inf          -Inf\n                                            .               +Inf        1.00000          +Inf          +Inf\n\nEnd of report\n\n"}},"pos":112,"scrolled":true,"start":1661536717184,"state":"done","type":"cell"}
{"cell_type":"code","id":"3dc022","input":"","pos":109,"type":"cell"}
{"cell_type":"code","id":"862d44","input":"","pos":28,"type":"cell"}
{"cell_type":"code","id":"a6423f","input":"","pos":108,"type":"cell"}
{"cell_type":"markdown","id":"03287f","input":"### Explanation of Pyomo Solution 1 (video)","metadata":{"heading_collapsed":true},"pos":10,"type":"cell"}
{"cell_type":"markdown","id":"068c5b","input":"## *Self Assessment: Changing Parameters*","pos":71,"type":"cell"}
{"cell_type":"markdown","id":"081970","input":"## Common Types of Sensitivity Analysis for Linear Programs\n\nBelow are four videos.  Each video will motivate one common sensitivity analysis question, using Desmos, and will also show you where to find that information in a sensitivity report.  We'll show you how to produce a sensitivity report using Pyomo and the GLPK solver further below.  Here is <a href=\"https://www.desmos.com/calculator/x3gob1ihnz\">the Desmos we used in the videos.</a>\n\n### Video 1 - Active Constraints\n\n* An **active** or **binding** constraint is one for which equality holds at the optimal values of the decision variables.  Changes to the coefficients in an active constraint can change the optimal solution.","pos":59,"type":"cell"}
{"cell_type":"markdown","id":"0bd523","input":"## *Self-Assessment: Formulate, Solve, and Perform Sensitivity #1*","metadata":{"heading_collapsed":true},"pos":86,"type":"cell"}
{"cell_type":"markdown","id":"178c12","input":"# Lesson 02: Sensitivity Analysis and Abstract Modeling","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"1f5a1f","input":"### Video 4 - Allowable Range of Objective Function Coefficients\n\n* Over what range of values can we change a single objective coefficient without changing the location of the optimal corner point feasible solution?  Note that the optimal objective function value will change but not the optimal decision variable values.","pos":65,"type":"cell"}
{"cell_type":"markdown","id":"2167ac","input":"Use DESMOS to answer the following questions about this model formulation:\n\nMaximize $Z = c_1 x + c_2 y = 2 x + 5 y$ \n\nsubject to \n\n$x + 2y \\leq 10$ (resource 1, $b_1$) \n\n$x + 3y \\leq 12$ (resource 2, $b_2$)\n\n$ x_1, x_2 \\geq 0$ \n\n(a) Set up this model in DESMOS and show the optimal value of $Z$ and the coordinates of $x$ and $y$ where the optimal solution occurs.  Provide a screenshot of the graph you used to find this answer with the optimal $Z$ and coordinates of $x$ and $y$ displayed.\n\n(b) With a slider for $Z$ (and $b_2$ if you like), find the shadow price for resource 2 ($b_2$).   Provide a screenshot of the graph with the new optimal $Z$ and coordinates of $x$ and $y$ at this point displayed.\n\n(c) With a slider for $b_2$, find the allowable range for resource 2 ($b_2$). Provide screenshots of the graphs you used to find this answer, one for the lower bound and one for the upper bound of $b_2$.\n\n(d) With sliders for $Z$ and $c_2$, find the allowable range for the unit profit of activity 2 ($c_2$). Provide screenshots of the graphs you used to find this answer, one for the lower bound and one for the upper bound of $c_2$.","pos":74,"type":"cell"}
{"cell_type":"markdown","id":"24a798","input":"The video below explains some parts of the solution code.  If you're content to study the code on your own, then you don't need to watch it.  There is a bit in the middle that shows you how to view the abstractly constructed constraints that is generally useful.","metadata":{"hidden":true},"pos":11,"type":"cell"}
{"cell_type":"markdown","id":"25721d","input":"## Nested Lists to Nested Dictionaries\n\nFor converting nested lists to nested dictionaries we generally prefer Methods 13 and 14 below.  We use Method 13 in most of our solutions. Method 15 is the most 'Pythonic' but is not as easy to follow as some other methods.","pos":101,"type":"cell"}
{"cell_type":"markdown","id":"270121","input":"Let $x_{m,d}$ represent the number of square feet to lease for $d$ months at the beginning of month $m$.\n\nLet $r_d$ be the cost per square foot of leasing for a duration of $d$ months.\n\nLet $s_m$ be the number of square feet required in month $m$.\n\nLet $M$ be the set of months, e.g. $M = \\{1,2,3,4,5\\}.$\n\nLet $D$ be the set of possible durations, e.g. $\\{1,2,3,4,5\\}.$\n\nThe total cost of leasing, to be minimized is:\n\n$$ Z = \\sum_{m \\in M} \\sum_{d \\in D} r_d x_{m,d}.$$\n\nNote, that $x_{m,d}$ will be 0 for some combinations of $m$ and $d$.  For instance, we'll have a constraint that $x_{5,2} = 0$ since in month 5 we cannot lease office space for 2 months.  In fact, if $m+d > 6$ we must have $x_{m,d} = 0$.  If we let $n_{mon}$ be the total number of months (e.g. $n_{mon} = 5$), then the constraint is \n$$ x_{m,d} = 0 \\mbox{ if } m + d > n_{mon} $$\n\nFor the final constraint we need to make sure we have adequate space leased in each month.  We'll have to take into consideration that, for example, a lease made for 2 months at the beginning of month 1 will be available in the second month, but not in the third month. For each month we'll have add up all of the square feet that are leased in both the current month and previous months that are still available.  Mathematically, we can add conditions to our sum like this:\n\nfor month $m$\n\n$$ \\sum_{i \\in M \\mbox{ if } i \\leq m} \\sum_{\\mbox{  }d \\in D \\mbox{ if } i + d > m} x_{i,d} \\geq s_m. $$\n\nThat sum looks pretty complicated, but the first sum says to add up the leased square feet for all months up to and including the current month.  The second sum says to add only the leased square feet for unexpired leases.  If we treat the indices as integers we could also write it this way, for each month $m$:\n\n$$ \\sum_{i = 1}^m \\sum_{d = m - i + 1}^{m} x_{m,d} \\geq s_m.$$\n\nStill confused? Look at the data frame below where we have months as rows and durations as columns:","pos":34,"type":"cell"}
{"cell_type":"markdown","id":"298159","input":"True or False: Any change in any parameter will necessarily change the optimal solution.","pos":72,"type":"cell"}
{"cell_type":"markdown","id":"2eca6d","input":"### Mathematical Formulation ###","pos":33,"type":"cell"}
{"cell_type":"markdown","id":"30175c","input":"We're going to make sausages by blending pork, wheat, and starch.  Our objective is to minimize the cost of making the sausages.  The table below shows the ingredients available, the cost, and the amount of each ingredient available from our supplier:\n\nIngredient | Cost ($/kg) | Amount (kg)\n-----------|------|--------------\nPork       | 4.32 | 7\nWheat      | 2.46 | 20.0\nStarch     | 1.86 | 17\n\nAdditionally, we have 23 kg of pork on hand that we must use in the sausages.\n\nWe want to make 2 types of sausage:\n* Economy ( > 40\\% pork)\n* Premium ( > 60\\% pork)\n\nEach sausage is 50 grams (0.05 kg).\n\nAccording to government regulations, the most starch we can use in our sausages is 25\\% by weight.\n\nWe have a demand for 350 economy sausages and 500 premium sausages.","pos":47,"type":"cell"}
{"cell_type":"markdown","id":"323a39","input":"To tackle larger linear programs it isn't practical to type out all of the variables, the terms in the objective function, or the individual constraints.  We need to move from a concrete model like this:\n\n<img src=\"images/concrete_model.png\" width=\"220\">\n\nto something more abstract like this:\n\n<img src=\"images/abstract_model.png\" width=\"320\">\n\nWe'll still use the ```ConcreteModel``` object in Pyomo, but we'll start each problem by first laying out the data and then adding indexed variables to the model object.  The big idea in writing models that are generalizable or \"abstract\" is to **separate the data from the model** so that swapping in different or larger data is simple.\n\nBelow we present several examples of generalizing models so that the model can be easily adapted to different problems.  Study these examples and use them to guide you in the homework.  Rather than give detailed videos for these examples we've tried to carefully write the necessary information.  Brief videos are provided to highlight a point or two.\n\nTo make the code easier to read and debug we use lists of meaningful variable names instead of simply using integers to index our variables.  We use those variable names as keys in dictionaries to look up values of model coefficients.  At the very bottom of this notebook you'll find a bit of material about Python dictionaries.  However, if you want additional help you should seek out a tutorial.   <a href=\"https://realpython.com/python-dicts/\">Here is an example tutorial</a>, but there are many others.  Feel free to share any resources you find on Piazza.","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"369cfc","input":"**Textbook Problem 7.3-5 (a, b, f)**\n\nReconsider Problem 7.3-4. After further negotiations with\n  each vendor, management of the G.A. Tanner Co. has learned that\n  either of them would be willing to consider increasing their supply\n  of their respective subassemblies over the previously stated maxima\n  (3,000 subassemblies of type A per day and 1,000 of type B per day)\n  if the company would pay a small premium over the regular price for\n  the extra subassemblies. The size of the premium for each type of\n  subassembly remains to be negotiated. The demand for the toy being\n  produced is sufficiently high so that 2,500 per day could be sold if\n  the supply of subassemblies could be increased enough to support\n  this production rate. Assume that the original estimates of unit\n  profits given in 7.3-4 are accurate.\n  \n(a) Formulate the mathematical model for this problem and with\n  the original maximum supply levels and the additional constraint\n  that no more than 2,500 toys should be produced per day.  Solve it using Pyomo in Python.\n  \n(b) Without considering the premium, use Pyomo\n  to determine the shadow price for the subassembly A constraint by\n  solving the model again after increasing the maximum supply by 1. Use this \n  shadow price to determine the maximum premium that the\n  company should be willing to pay for each subassembly of this type.\n\n(f) Use the sensitivity report to determine the shadow price\n  for each of the subassembly constraints and the allowable range for\n  the right-hand side of each of these constraints.","metadata":{"hidden":true},"pos":89,"type":"cell"}
{"cell_type":"markdown","id":"3fd0fc","input":"**Run the following cell to print the report.  Alternately, you can open the report separately using anything that will display plain text.  We've found that using \"Print\" in CoCalc to print to a pdf file in landscape produces a readable document.**","metadata":{"hidden":true},"pos":81,"type":"cell"}
{"cell_type":"markdown","id":"40f3b7","input":"### Video 2 - Shadow Prices\n\n* A **shadow price** is the rate at which $Z$ changes for each unit increase in the amount of resource $b_i$ (when $b_i$ remains in its allowable range and none of the other parameters are allowed to change).","pos":61,"type":"cell"}
{"cell_type":"markdown","id":"411526","input":"### Problem Description","metadata":{"heading_collapsed":true},"pos":5,"type":"cell"}
{"cell_type":"markdown","id":"435854","input":"### Explanation of Pyomo Solution (video)","metadata":{"heading_collapsed":true},"pos":37,"type":"cell"}
{"cell_type":"markdown","id":"4423b3","input":"We want to move from the above, very concrete, implementation to a more abstract representation which can be generalized to larger problems.\n\n**The index sets:**\n\nLet $Pr$ represent the set of products.  Symbolically we write $Pr = \\{ \\mbox{doors}, \\mbox{windows} \\}$.  \n\nLet $Pl$ be set of plants so $Pl = \\{ \\mbox{Plant1}, \\mbox{Plant2}, \\mbox{Plant3} \\}.$\n\nIn Python we can represent these index sets as any iterable object.  While it is possible to use Python sets here, we usually use Python lists because those are both iterable and subscriptable.  In Python the index sets look like this:\n\n```python\nproducts = ['Doors', 'Windows']\nplants = ['Plant1', 'Plant2', 'Plant3']\n```\n\n**The objective function:**\n\nFor each product $pr$ let $x_{pr}$ be the number of batches of that product to produce and let $c_{pr}$ be the profit rate per batch of $pr$ that is produced.  The objective function could be written as \n$$ Z = c_{\\mbox{doors}} x_{\\mbox{doors}} + c_{\\mbox{windows}} x_{\\mbox{windows}}.$$\n\nMore generally we can write: \n$$ Z = \\sum_{pr \\in Pr} c_{pr} x_{pr}.$$\n\nIn Python this will look like:\n```python \nsum(profit_rate[pr] * model.weekly_prod[pr] for pr in products)\n```\n\n**The constraints:**\n\nTo start, we can make all the constraints look the same:\n$$\n\\begin{array}{ccccc}\n1 x_{\\mbox{doors}} & + & 0 x_{\\mbox{windows}} & \\leq & 4 \\\\\n0 x_{\\mbox{doors}} & + & 2 x_{\\mbox{windows}} & \\leq & 12 \\\\\n3 x_{\\mbox{doors}} & + & 2 x_{\\mbox{windows}} & \\leq & 18\n\\end{array}\n$$\n\nNow we have three constraints, one for each plant, that has the form:\n$$ (\\mbox{hours per batch of doors}) * x_{\\mbox{doors}} +\n(\\mbox{hours per batch of windows}) * x_{\\mbox{windows}} \\leq \\mbox{hourly capacity}.$$\n\nIf we let $h_{pl,pr}$ represent the hours needed for a batch of product $pr$ at plant $pl$ and let $a_{pl}$ be the number of hours available at plant $pl$, then we can express the constraints as:\n\nfor each plant $pl \\in Pl$ \n$$ \\sum_{pr \\in Pr} h_{pl,pr} x_{pr} \\leq a_{pl}.$$\n\nIn Python this will look like:\n\n```python \nsum(hours_per_batch[pl][pr] * model.weekly_prod[pr] for pr in products) <= hours_available[pl]\n```\n    \nFor comparison, the concrete and abstract models are shown side-by-side:\n\n<table class=\"tleft\">\n    <tr>\n        <td><p style=\"padding-right: 120px;\"> <b>Concrete Model</b></p></td>\n        <td><p style=\"padding-right: 150px;\"> <b>Abstract Model</b></p></td>\n    </tr>\n<tr>\n<td>\nMaximize $Z = 3 d + 5 w$\n</td>\n<td>\nMaximize $ Z = \\displaystyle \\sum_{pr \\in Pr} c_{pr} x_{pr}$\n<td>\n</tr>\n<tr>\n<td>\nSubject to:\n\n$\n\\begin{array}{ccccc}\n d &   &    & \\leq & 4 \\\\\n   &   & 2w & \\leq & 12 \\\\\n3d & + & 2w & \\leq & 18\n\\end{array}\n$\n</td>\n<td>\nSubject to:\n\n$ \\displaystyle \\sum_{pr \\in Pr} h_{pl,pr} x_{pr} \\leq a_{pl}, \\mbox{ for each } pl \\in Pl$\n<td>\n</tr>\n<tr>\n<td>\n$d \\geq 0$, $w \\geq 0$\n</td>\n<td>\n$ x_{pr} \\geq 0, \\mbox{ for each } pr \\in Pr$ \n<td>\n</tr>   \n</table>","metadata":{"hidden":true},"pos":8,"type":"cell"}
{"cell_type":"markdown","id":"46af36","input":"### Problem Description","pos":46,"type":"cell"}
{"cell_type":"markdown","id":"4aa41b","input":"For a small model such as this one it's still pretty easy to read the output and sort out the decision variables, but using meaningful labels can be really helpful for larger problems so we ask you not to use this approach in your homework.\n\n#### Advantages and Disadvantages for the Four Approaches\n\nThe models are essentially the same in all four approaches, but the data preparation and labeling is different.  \n\n* Solution 1 - Typing the dictionaries directly\n    * Advantage:  it's easy to type out the dictionaries for small problems\n    * Disadvantage: typing out the dictionaries for large problems isn't feasible\n* Solution 2 - Building dictionaries from lists (Preferred)\n    * Advantage:  if the data is loaded in to lists (arrays or numpy arrays would also work well) then dictionaries of any size can be built;  more levels of nesting can be used to accommodate variables with more than two indices (we'll meet an example in Lesson 3)\n    * Disadvantage:  The code is harder to write and requires some mastery of dictionaries.\n*  Solution 3 - Building Pandas data frames and series from lists or other array types (Preferred)\n    * Advantage - accommodates large problems easily; data frames and series are easier to construct than dictionaries\n    * Disadvantage - limited to problems in which the variables have one or two indices.\n*  Solution 4 - Using integers to loop directly over lists or arrays\n    * Advantage - requires very little effort to prepare the data other than loading into lists or arrays\n    * Disadvantages - code may be less readable and model output is more difficult to interpret\n\n#### Goals and Guidelines for Abstract Modeling\n\n* Separate the data from the model.  You can type out lists or arrays with the raw data, but you should parse the coefficients into dictionaries or Pandas objects to be used in the model.  In general you should pretend that the data is being loaded into lists, dataframes, or arrays and then processed before model construction.\n* Suppose you want to write all of your constraints as \"$\\leq$\" but you have some that go the wrong direction.  For example\n$$ 3x - 2y \\geq 5.$$  If you multiply both sides by $(-1)$ it reverses the inequality to yield $$ -3x + 2y \\leq -5.$$\n* Getting all the inequality constraints in the same direction helps because the coefficients can be stored and used to construct the inequalities via a loop as we did with the Wyndor model above.\n* Going forward, you'll lose points on your homework if you type out coefficients instead of using the abstract approach introduced here.  It's more difficult, but it's essential for working with large problems.  It's also great practice toward writing reusable code.\n* If you want additional practice, many of the self-assessment problems below include abstract formulations.\n","pos":25,"type":"cell"}
{"cell_type":"markdown","id":"53ec6d","input":"### Mathematical formulation","metadata":{"heading_collapsed":true},"pos":48,"type":"cell"}
{"cell_type":"markdown","id":"6acede","input":"# Constructing Dictionaries from Lists\n\nHere are some examples to help with learning how to construct dictionaries from lists.  We don't provide explanations for the code, but study and use any of the constructions as needed.\n\n## A single dictionary\n\nFirst, let's look at creating a dictionary from two separate lists of keys and values.  We generally prefer \"method 7\" for its compactness and simplicity.  Study only \"method 7\" if there are too many options to absorb.","pos":90,"type":"cell"}
{"cell_type":"markdown","id":"6f6afa","input":"# Sensitivity Analysis\n\n## What is Sensitivity Analysis?\n\nWe want to know what happens when the model coefficients change.  What effect do changes have on the optimal solution?\nWe say a bit more about the need for Sensitivity Analysis in the next video:","pos":57,"type":"cell"}
{"cell_type":"markdown","id":"701f95","input":"## Generating a Sensitivity Report in Python","metadata":{"heading_collapsed":true},"pos":75,"type":"cell"}
{"cell_type":"markdown","id":"73e00b","input":"Pyomo doesn't automatically generate a sensitivity analysis, but it's possible to write the model to a standardized file (called an LP file) and then run a solver to produce a sensitivity report.  For directions about interpreting the sensitivity report refer to the last few videos or look at the annotated image provided further below.\n\n**First, run the following cell to load up the abstract Wyndor model from above.**","metadata":{"hidden":true},"pos":76,"type":"cell"}
{"cell_type":"markdown","id":"76435c","input":"## *Self Assessment: Allowable Range (Objective Coef)*","metadata":{"heading_collapsed":true},"pos":69,"type":"cell"}
{"cell_type":"markdown","id":"77a86a","input":"Use what you've learned in the examples above to formulate and solve a linear programming model for textbook problem 3.4-11.\n\nThe Medequip Company produces precision medical diagnostic equipment at two factories. Three medical centers have placed orders for this months production output. The table below shows what the cost would be for shipping each unit from each factory to each of these customers. Also shown are the number of units that will be produced at each factory and the number of units ordered by each customer.\n\n<table>\n    <tr>\n        <th style=\"border-right:thin solid;border-bottom:thin solid;\"> &nbsp; </th>\n        <th style=\"border-bottom:thin solid;\"> Customer 1</th>\n        <th style=\"border-bottom:thin solid;\"> Customer 2</th>\n        <th style=\"border-bottom:thin solid;\"> Customer 3</th>\n        <th style=\"border-left: thin solid;border-bottom:thin solid;\"> Output</th>\n    </tr>\n    <tr>\n        <td style=\"border-right:thin solid;\"> <b>Factory 1</b> </td>\n        <td> \\$600 </td>\n        <td> \\$800 </td>\n        <td> \\$700 </td>\n        <td style=\"border-left:thin solid;\"> 400 units </td>\n    </tr>\n    <tr>\n        <td style=\"border-right:thin solid;\"> <b>Factory 2</b> </td>\n        <td> \\$400 </td>\n        <td> \\$900 </td>\n        <td> \\$600 </td>\n        <td style=\"border-left:thin solid;\"> 500 units </td>\n    </tr>       \n    <tr>\n        <td style=\"border-top:thin solid;border-right:thin solid\"> <b>Order size</b> </td>\n        <td style=\"border-top:thin solid;\"> 300 units </td>\n        <td style=\"border-top:thin solid;\"> 200 units </td>\n        <td style=\"border-top:thin solid;\"> 400 units </td>\n        <td style=\"border-left:thin solid; border-top:thin solid;\"> &nbsp; </td>\n    </tr>\n</table>\n\nA decision now needs to be made about the shipping plan for how many units to ship from each factory to each customer.\n\n(a) Formulate a linear programming model for this problem.\n\n(b) Solve this model using Pyomo.","pos":56,"type":"cell"}
{"cell_type":"markdown","id":"77e1b6","input":"This is problem 3.4-9, page 85, from the textbook.\n\nWeb Mercantile sells many household products through an online catalog. The company needs substantial warehouse space for storing its goods. Plans now are being made for leasing warehouse storage space over the next 5 months. Just how much space will be required in each of these months is known. However, since these space requirements are quite different, it may be most economical to lease only the amount needed each month on a month-by-month basis. On the other hand, the additional cost for leasing space for additional months is much less than for the first month, so it may be less expensive to lease the maximum amount required for the entire 5 months. Another option is the intermediate approach of changing the total amount of space leased (by adding a new lease and/or having an old lease expire) at least once but not every month.\n\nThe space requirement and the leasing costs for the various leasing periods are as follows:\n\n<img src=\"images/problem3p4-9.png\" width=\"440\">  ","pos":32,"type":"cell"}
{"cell_type":"markdown","id":"7bc2be","input":"## Abstract Modeling for LP","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"7bf8a0","input":"In month 1 the number of square feet leased is $10 + 11 + 12 + 13 + 14 = 60$.\n\nIn month 2 the number of square feet leased is $11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 = 116.$  Notice that the sum includes all the rentals from months 1 and 2 except for the 10 square feet rented at the beginning of month 1 for a duration of 1 month.  That term is not included in the sum because $i + d = 1 + 1 = 2$ is not greater than 2 indicating that the 10 square feet is not available in month 2.\n\nHow many square feet are available in month 3?  In month 4?  In month 5?  (answers are 150, 148, and 100 respectively)","pos":36,"type":"cell"}
{"cell_type":"markdown","id":"7d697b","input":"## *Self-Assessment: Formulate, Solve, and Perform Sensitivity #2*","metadata":{"heading_collapsed":true},"pos":88,"type":"cell"}
{"cell_type":"markdown","id":"7e61d6","input":"**Textbook Problem 4.7-6 (c, b)**\n\nConsider the following problem: \n\nMaximize $Z = 5 x_1 + 4x_2 - x_3 + 3 x_4$ \n\nsubject to \n\n$ 3x_1 + 2x_2 - 3x_3 + x_4 \\leq 24 \\mbox{ (resource 1) } $\n\n$ 3x_1 + 3x_2 + x_3 + 3x_4 \\leq 36 \\mbox{ (resource 2) }$\n\nand $x_1 \\geq 0, x_2 \\geq 0, x_3 \\geq 0, x_4 \\geq 0.$ \n\nUse Pyomo to solve the problem and then generate sensitivity information. Use this information to identify the shadow price for each resource, the allowable range for each objective function coefficient, and the allowable range for each right-hand side.  You should practice writing abstract code with the model and data separated.","metadata":{"hidden":true},"pos":85,"type":"cell"}
{"cell_type":"markdown","id":"8415d4","input":"We first saw this problem in Lesson 1 where it was solved by introducing individual variables for each possible month and lease duration combination.  Such an approach was possible over a five month span, but imagine typing all of the variables and constraints for a 24 month, or longer, time period.  In the solution below, using indexed variables, the code can be easily adapted to any time period.  \n\nThe primary difference between this and the Wyndor example above is that the decision variables depend on both the month and the duration so they form an array.  Study this example to see ","pos":30,"type":"cell"}
{"cell_type":"markdown","id":"850164","input":"## *Self-Assessment: Solve and Perform Sensitivity*\n","metadata":{"heading_collapsed":true},"pos":84,"type":"cell"}
{"cell_type":"markdown","id":"8711fa","input":"### Explanation of Pyomo Solution (video)","pos":50,"type":"cell"}
{"cell_type":"markdown","id":"936016","input":"### Pyomo Solution 3\n\n**Solution approaches 2 and 3 are what you should use in the homework.  We almost always use approach 2 in the lessons and solutions.**\n\nThis is similar to Solution 2 except the data is parsed from the lists into Pandas dataframes and series to facilitate the model construction.  The advantage to Pandas objects is that we can use our lists of labels as indices.  In the model construction we only had to change how the values in `hours_per_batch` are referenced.  This approach will work on most problems, but we'll encounter a problem in the next lesson with three index variables for which you'll need to use dictionaries.","pos":19,"type":"cell"}
{"cell_type":"markdown","id":"9c8a22","input":"Again, here is the Wyndor model from the textbook.  $Z$ is the profit in thousands of dollars.  $d$ and $w$ are the batches of doors and windows, respectively.  The constraints, in order, represent the production capacities of Plants 1, 2, and 3.\n\nMaximize $Z = 3 d + 5 w$\n\nSubject to:\n\n$\n\\begin{array}{ccccc}\n d &   &    & \\leq & 4 \\\\\n   &   & 2w & \\leq & 12 \\\\\n3d & + & 2w & \\leq & 18\n\\end{array}\n$\n\n$d \\geq 0$, $w \\geq 0$","metadata":{"hidden":true},"pos":6,"type":"cell"}
{"cell_type":"markdown","id":"9e870c","input":"## Wyndor - Abstract Formulation","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"a0b124","input":"### Pyomo Solution","pos":53,"type":"cell"}
{"cell_type":"markdown","id":"a32b60","input":"The model code really hasn't changed much other than our loops are indexed by integers instead of lists of labels.  This makes the model output a little harder to read and debug because we don't know which index values correspond to Windows or Doors:","pos":23,"type":"cell"}
{"cell_type":"markdown","id":"a418a8","input":"**Textbook Problem 3.2-3.** This is your lucky day. You have just won a \\$20,000\n  prize. You are setting aside \\$8,000 for taxes and partying\n  expenses, but you have decided to invest the other \\$12,000. Upon\n  hearing this news, two different friends have offered you an\n  opportunity to become a partner in two different entrepreneurial\n  ventures, one planned by each friend. In both cases, this investment\n  would involve expending some of your time next summer as well as\n  putting up cash. Becoming a full partner in the first friends\n  venture would require an investment of \\$10,000 and 400 hours, and\n  your estimated profit (ignoring the value of your time) would be\n  \\$9,000. The corresponding figures for the second friends venture\n  are \\$8,000 and 500 hours, with an estimated profit to you of\n  \\$9,000. However, both friends are flexible and would allow you to\n  come in at any fraction of a full partnership you would like. If you\n  choose a fraction of a full partnership, all the above figures given\n  for a full partnership (money investment, time investment, and your\n  profit) would be multiplied by this same fraction.  Because you were\n  looking for an interesting summer job anyway (maximum of 600 hours),\n  you have decided to participate in one or both friends ventures in\n  whichever combination would maximize your total estimated\n  profit. You now need to solve the problem of finding the best\n  combination.\n\nThis self-assessment problem was also in Lesson 1 where you formulated and solved a linear model using the graphical method. Now copy and paste the code from the Wyndor problem above into a new cell and adapt it to solve this problem.","pos":27,"type":"cell"}
{"cell_type":"markdown","id":"a61004","input":"## Web Mercantile - Abstract Formulation","pos":29,"type":"cell"}
{"cell_type":"markdown","id":"b2560f","input":"Notice that using meaningful labels for the variables and the indices make it easier to read and debug the model which is a big plus.  The downside to the data approach above is that we had to type out the dictionaries that store all the model parameters.  That wouldn't be feasible to larger models.  We explore a better approach in the next solution.\n\n### Pyomo Solution 2 (Solutions 2 and 3 are the preferred approaches for homework)\n\nThe only difference here is that we have the data loaded into lists that might be similar to how the data would appear after it is loaded from an external source. The data is parsed from the lists into dictionaries to facilitate the model construction. The model construction and solution are identical to those in Solution 1.  At the end of this notebook you'll find several examples of constructing dictionaries from lists.  We also use this approach throughout our examples and homework solutions.  You could use a similar approach for constructing dictionaries from any array-like data type.","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"b61cac","input":"### Pyomo Solution 1\n\nThis solution is the one referenced in the video.  Here the data and the model are separated quite well, but the dictionaries for the model data are fully typed out which isn't practical except for tiny models.   For larger models the data would be loaded into lists or arrays from a file or database then the data would be parsed into dictionaries or Pandas series and dataframes.  The advantage to those data structures is that they allow us to reference the data using strings that label the variables and constraints which makes the models easier to read and debug.\n\nFurther below we present 3 other solution approaches that illustrate different approaches to storing the problem data and using it in the model construction.  After each solution we'll both print out the model and also note some pluses and minuses for that approach.","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"c12cc5","input":"We like to use `enumerate` because it makes it easy to index both by position in the list and by the list elements.  If you'd like to review the enumerate command <a href=\"https://realpython.com/python-enumerate/\">this is a pretty good tutorial.</a>","pos":95,"type":"cell"}
{"cell_type":"markdown","id":"c6e4aa","input":"The video below explains some parts of the solution code.  If you're content to study the code on you own, then you don't need to watch it.","pos":51,"type":"cell"}
{"cell_type":"markdown","id":"c7220a","input":"Here is what the constraints and objective function look like with the labeled variables:","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"c82c13","input":"### *Self Assessment: Supply and Demand Problem*","pos":55,"type":"cell"}
{"cell_type":"markdown","id":"d08106","input":"This example, first presented in Lesson 1, is adapted from here: http://benalexkeen.com/linear-programming-with-python-and-pulp-part-4/.  \n        \nIn Lesson 1 this problem was formulated and solved by introducing individual variables for each ingredient and sausage type.  Here, we'll use an array of variables and configure the objective function and constraints in a way that can be more easily generalized.\nThe second will be to write the model in a way that can be easily extended.","pos":45,"type":"cell"}
{"cell_type":"markdown","id":"d0d67e","input":"### Pyomo Solution","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"d232f2","input":"**Now run the cell below to write the model to an LP file to create a sensitivity report.**  Note:  the solver produces some output that we do not need.  You can just ignore the output here.","metadata":{"hidden":true},"pos":78,"type":"cell"}
{"cell_type":"markdown","id":"d5ff43","input":"True or False:  For the objective coefficients, the allowable range is the range of values over which the current optimal solution remains optimal, assuming no change in the other coefficients. ","metadata":{"hidden":true},"pos":70,"type":"cell"}
{"cell_type":"markdown","id":"d93242","input":"## Sausages Blending - Abstract Formulation","pos":44,"type":"cell"}
{"cell_type":"markdown","id":"dcf61d","input":"In the Pyomo solutions below we'll share a few different approaches for the data structures used to both store the problem data and to construct the model.  In each case we share some pluses and minuses to each approach.  We offer a video for the first solution and code for all the approaches.  After the four solution approaches we discuss some advantages and disadvantages to each approach. *If four approaches is too many, then just focus on the second as it will work for all the problems we encounter.*","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"de8dff","input":"### Mathematical Formulation","metadata":{"heading_collapsed":true},"pos":7,"type":"cell"}
{"cell_type":"markdown","id":"e5ae27","input":"True or False:  A positive shadow price indicates that the right-hand side of that constraint is a sensitive parameter.","metadata":{"hidden":true},"pos":68,"type":"cell"}
{"cell_type":"markdown","id":"e95800","input":"### *Self Assessment: A Holiday Factory*","metadata":{"heading_collapsed":true},"pos":42,"type":"cell"}
{"cell_type":"markdown","id":"eb4fb2","input":"### Video 3 - Allowable Range of Constraint Right Side\n\n* The allowable range of constraint right side, $b_i$ is the range values over which the corresponding constraint remains active when no other parameters are allowed to change.  Outside this range the constraint is no longer active and is not involved in the optimal solution.  Note, as $b_i$ changes within its allowable range the optimal objective function value and decision variables values will change, but will be determined by the same set of active constraints","pos":63,"type":"cell"}
{"cell_type":"markdown","id":"ebc8b6","input":"We'll write things generically so that the model can be used for any numbers of ingredients and types.\n\nLet $I$ represent the set of ingredients and let $T$ represent the set of types of sausage.\n\nFor each $i \\in I$ and $t \\in T$ \n\n<table class=\"tleft\">\n    <tr>\n        <td><p style=\"padding-right: 20px;\"> <b>Quantity</b></p></td>\n        <td><p style=\"padding-right: 100px;\"> <b>Description</b></p></td>\n    <tr>\n    <tr><td>$x_{i,t}$</td><td>kg of ingredient $i$ to use in sausage of type $t$ (decision variable)</td></tr>\n    <tr><td>$c_i$</td><td>cost per kg of ingredient $i$ in dollars</td></tr>\n    <tr><td>$pmin_{i,t}$</td><td>minimum proportion of ingredient $i$ in sausage of type $t$, use 0 for no minimum</td></tr>\n    <tr><td>$pmax_{i,t}$</td><td>maximum proportion of ingredient $i$ in sausage of type $t$, use 1 for no maximum</td></tr>\n    <tr><td>$imax_{i}$</td><td>maximum kilograms of ingredient $i$ that are available</td></tr>\n    <tr><td>$imin_{i}$</td><td>minimum kilograms of ingredient $i$ that must be used</td></tr>\n    <tr><td>$d_{t}$</td><td>total kg of sausage of type $t$ that are demanded</td></tr>\n</table>\n\nTo write the cost function we need to add up the quantity of each ingredient used across all the sausage types, so for each ingredient $i$ this is $$\\sum_{t \\in T} x_{i,t}.$$\nNow the cost of ingredient $i$ will be\n$$ c_i \\left( \\sum_{t \\in T} x_{i,t} \\right).$$\nFinally, the objective function is the total cost for all ingredients and types:\n$$ \\mbox{Cost} = \\sum_{i \\in I}  c_i \\left( \\sum_{t \\in T} x_{i,t} \\right).$$\n\nNow let's turn to the constraints.  First we need the total kg of each type of sausage made to equal the demand for that type. \n\n$$ \\sum_{i \\in I} x_{i,t} = d_t \\mbox{ for each } t \\in T.$$\n\nThe sum on the left represents the total kg of ingredients used in sausage $j$.\n\nNow we need the minimum proportion constraints:\n$$x_{i,t} \\geq pmin_{i,t} \\sum_{k \\in I} x_{k,t}.$$\n\nThat sum on the right now uses the index $k$ which serves as a dummy variable to add up the total kg of each type of sausage.\n\nThe maximum proportion constraints are similar:\n$$x_{i,t} \\leq pmax_{i,t} \\sum_{k \\in I} x_{k,t}.$$\n\nThe availability constraints enforce the maximum amount of ingredient $i$ that is available:\n$$\\sum_{t \\in T} x_{i,t} \\leq imax_i.$$\nThe sum on the left here is the total kg of ingredient $i$ used over all types of sausages.\n\nThe \"must use\" constraints are similar:\n$$\\sum_{t \\in T} x_{i,t} \\geq imin_i.$$\n\n\nHere are the concrete and abstract model comparisons side-by-side for comparison:\n<table class=\"tleft\">\n    <tr>\n        <td><p style=\"padding-right: 40px;\"> <b>Description</b></p></td>\n        <td><p style=\"padding-right: 120px;\"> <b>Concrete Model</b></p></td>\n        <td><p style=\"padding-right: 120px;\"> <b>Abstract Model</b></p></td>\n    </tr>\n<tr>\n    <td> Minimize Cost = </td>\n    <td>\n        $4.32 ( p_e + p_p) + 2.46( w_e + w_p) + 1.86 (s_e + s_p) $\n    </td>\n    <td>\n        $\\displaystyle \\sum_{i \\in I}  c_i \\left(\\sum_{t \\in T} x_{i,t} \\right)$\n    <td>\n</tr>\n<tr>\n    <td> Demand Constraints </td>\n    <td> $p_e + w_e + s_e = 350 \\times 0.05$<br>$p_p + w_p + s_p = 500 \\times 0.05$ </td>\n    <td> $\\displaystyle \\sum_{i \\in I} x_{i,t} = d_t \\mbox{ for each } t \\in T$ </td>\n</tr>\n<tr>\n    <td> Minimimum Proportion<br>Constraints </td>\n    <td> $p_e \\geq 0.4 (p_e + w_e + s_e)$<br>$p_p \\geq 0.6 (p_p + w_p + s_p)$</td>\n    <td> $\\displaystyle x_{i,t} \\geq pmin_{i,t} \\sum_{k \\in I} x_{k,t}$</td>\n</tr>\n<tr>\n    <td> Maximum Proportion<br>Constraints </td>\n    <td> $s_e \\leq 0.25 (p_e + w_e + s_e)$<br>$s_p \\leq 0.25 (p_p + w_p + s_p)$ </td>\n    <td> $\\displaystyle x_{i,t} \\leq pmax_{i,t} \\sum_{k \\in I} x_{k,t}$ </td>\n<tr>\n    <td> Maximum Ingredient<br>Constraints </td>\n    <td> $p_e + p_p \\leq 30$<br>$w_e + w_p \\leq 20$<br>$s_e + s_p \\leq 17$ </td>\n    <td> $\\displaystyle \\sum_{t \\in T} x_{i,t} \\leq imax_i$</td>\n</tr>\n<tr>\n    <td> Minimum Ingredient<br>Constraints </td>\n    <td> $p_e + p_p \\geq 23$</td>\n    <td> $\\displaystyle \\sum_{t \\in T} x_{i,t} \\geq imin_i$</td>\n</tr>\n</table>","metadata":{"hidden":true},"pos":49,"type":"cell"}
{"cell_type":"markdown","id":"ece403","input":"A company is planning to design and manufacture children's toys over an 11-month span prior to a major holiday.  In the beginning, the company won't need much space to design and plan the toy, but the square footage required will grow as they stockpile parts for the toys and start manufacturing.  Toward the end of the 11-month span the square feet required will start to diminish as toys are shipped to stores and distribution centers.  The square feet needed in each month is as follows:\n\nMonth | Square Feet | Month | Square Feet\n--- | --- | --- | ---\n1 | 2000 | 7 | 10000\n2 | 2000 | 8 | 10000\n3 | 3000 | 9 | 9000\n4 | 4000 | 10 | 7000\n5 | 6000 | 11 | 5000\n6 | 10000\n\n\nThe rent per square foot starts at $20 per month, but decreases for leases of longer duration as follows. \n\nDuration (months) | Rent (\\$ per square foot)\n--- | --- \n1 | 20 \n2 | 20 + 19 = 39 \n3 | 20 + 19 + 18 = 57\n$\\vdots$ | $\\vdots$\n11 | 165\n\nLearn how easy it is to reuse models by figuring out the pattern for durations and then adapting the example code above to find the minimum cost for the leasing the required square footage.  Try to find a way to compute the rent for each duration using a sum or a formula instead of just computing each by \"hand\".","metadata":{"hidden":true},"pos":43,"type":"cell"}
{"cell_type":"markdown","id":"ef451c","input":"### Problem Description","pos":31,"type":"cell"}
{"cell_type":"markdown","id":"f06b24","input":"### Pyomo Solution 4\n\nIn this solution we loop over the lists directly in the model construction.  This approach is fine for quick and dirty solutions, but when possible the model and code should be written using meaningful index variables as in Solutions 2 and 3.","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"f0d6a5","input":"## *Self Assessment: Graphical Exploration of Sensitivity*","pos":73,"type":"cell"}
{"cell_type":"markdown","id":"f60fe4","input":"**Textbook Problem 7.3-4 (a & f with Pyomo)**\n\nOne of the products of the G.A. Tanner Company is a special\n  kind of toy that provides an estimated unit profit of \\$3. Because\n  of a large demand for this toy, management would like to increase\n  its production rate from the current level of 1,000 per\n  day. However, a limited supply of two subassemblies (A and B) from\n  vendors make this difficult. Each toy requires two subassemblies of\n  type A, but the vendor providing these subassemblies would only be\n  able to increase its supply rate from the current 2,000 per day to a\n  maximum of 3,000 per day. Each toy requires only one subassembly of\n  type B, but the vendor providing these subassemblies would be unable\n  to increase its supply rate above the current level of 1,000 per\n  day. Because no other vendors currently are available to provide\n  these subassemblies, management is considering initiating a new\n  production process internally that would simultaneously produce an\n  equal number of subassemblies of the two types to supplement the\n  supply from the two vendors. It is estimated that the companys cost\n  for producing one subassembly of each type would be \\$2.50 more than\n  the cost of purchasing these subassemblies from the two\n  vendors. Management wants to determine both the production rate of\n  the toy and the production rate of each pair of subassemblies (one A\n  and one B) that would maximize the total profit.  The following\n  table summarizes the data for the problem.\n  \n  \n<img src=\"images/problem5p3.png\" width=\"440\">  \n\n(a) Formulate the mathematical model for this problem and solve it using Pyomo in Python.\n  \n(f) Generate a sensitivity report to find the allowable range for\n  the unit profit of each activity (toys and subassemblies).","metadata":{"hidden":true},"pos":87,"type":"cell"}
{"cell_type":"markdown","id":"f66ab0","input":"## *Self Assessment: Positive Shadow Price*","metadata":{"heading_collapsed":true},"pos":67,"type":"cell"}
{"cell_type":"markdown","id":"fdd30c","input":"The video below explains some parts of the solution code.  If you're content to study the code on you own, then you don't need to watch it. ","metadata":{"hidden":true},"pos":38,"type":"cell"}
{"cell_type":"markdown","id":"ffef95","input":"### *Self Assessment: Investment Allocation*","pos":26,"type":"cell"}
{"id":0,"time":1661536311145,"type":"user"}
{"last_load":1661536310731,"type":"file"}