{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-7473631e-c0a2-4de0-a31e-b5b6e1a03f92.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"},"toc":{"base_numbering":1,"nav_menu":{},"number_sections":true,"sideBar":true,"skip_h1_title":false,"title_cell":"Table of Contents","title_sidebar":"Contents","toc_cell":false,"toc_position":{"height":"calc(100% - 180px)","left":"10px","top":"150px","width":"294.56px"},"toc_section_display":true,"toc_window_display":false},"varInspector":{"cols":{"lenName":16,"lenType":16,"lenVar":40},"kernels_config":{"python":{"delete_cmd_postfix":"","delete_cmd_prefix":"del ","library":"var_list.py","varRefreshCmd":"print(var_dic_list())"},"r":{"delete_cmd_postfix":") ","delete_cmd_prefix":"rm(","library":"var_list.r","varRefreshCmd":"cat(var_dic_list()) "}},"types_to_exclude":["module","function","builtin_function_or_method","instance","_Feature"],"window_display":false}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1673904297739,"exec_count":1,"id":"0b1cbe","input":"# imports\nimport numpy as np\nimport pandas as pd\nfrom scipy import interpolate\nfrom scipy.optimize import minimize_scalar, minimize\nimport matplotlib.pyplot as plt\nimport json\nimport time\nimport seaborn as sns\nsns.set_style(\"darkgrid\")","kernel":"python3","metadata":{"code_folding":[0]},"no_halt":true,"pos":0,"start":1673904295752,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904297770,"exec_count":2,"id":"240455","input":"from scipy.optimize import minimize\nP = lambda x: -0.008 * x**2 + 3.1 * x - 80  # lambda is for writing one line functions\nneg_P = lambda x: -P(x)\nresult = minimize(neg_P, x0=150, bounds=[(0, 250)])\nprint(f\"The maximum profit is ${-result.fun[0]:,.2f} and occurs when {result.x[0]:3.2f} apartments are rented.\")","kernel":"python3","metadata":{"code_folding":[],"hidden":true},"no_halt":true,"output":{"0":{"name":"stdout","text":"The maximum profit is $220.31 and occurs when 193.75 apartments are rented.\n"}},"pos":2,"start":1673904297759,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904297787,"exec_count":3,"id":"0eb862","input":"P(193),P(194)","kernel":"python3","metadata":{"hidden":true},"no_halt":true,"output":{"0":{"data":{"text/plain":"(220.30800000000005, 220.31199999999995)"},"exec_count":3}},"pos":4,"start":1673904297776,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904298623,"exec_count":4,"id":"934f54","input":"# first graph the function\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(-4,3.6,201)\nf = lambda x:x**5-x**4-18*x**3+16*x**2+32*x-2\nfig = plt.figure(figsize=(6,5));\nplt.plot(x,f(x));\nplt.xlabel('x');\nplt.ylabel('y');","kernel":"python3","metadata":{"code_folding":[0],"hidden":true},"no_halt":true,"output":{"0":{"data":{"image/png":"eba7545fdef5bfd65a6aa173b5dd7abd8d3ef983","text/plain":"<Figure size 432x360 with 1 Axes>"},"metadata":{"image/png":{"height":316,"width":397}}}},"pos":7,"start":1673904297795,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904298730,"exec_count":5,"id":"4ebd37","input":"from scipy.optimize import minimize\n\n# find minima first\nx0_min = [-.5,3.5]\nfor x0 in x0_min:\n    result = minimize( f, x0, bounds = [(-4,3.6)])\n    print(f\"There is a local minimum value of {result.fun[0]:.2f} at x = {result.x[0]:.2f}\")\n    \n# now maxima\nneg_f = lambda x:-f(x)\nx0_max = [-3,1]\nfor x0 in x0_max:\n    result = minimize( neg_f, x0, bounds = [(-4,3.6)])\n    print(f\"There is a local maximum value of {-result.fun[0]:3.2f} at x = {result.x[0]:1.2f}\")","kernel":"python3","metadata":{"hidden":true},"no_halt":true,"output":{"0":{"name":"stdout","text":"There is a local minimum value of -11.91 at x = -0.54\nThere is a local minimum value of -96.27 at x = 3.30\nThere is a local maximum value of 210.19 at x = -3.11\nThere is a local maximum value of 28.85 at x = 1.15\n"}},"pos":9,"start":1673904298637,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904299117,"exec_count":6,"id":"4ee14a","input":"def rastrigin(x):\n    # pass a single vector of length n (=dim) to evaluate Rastrigin\n    return sum(x**2 + 10 - 10 * np.cos(2 * np.pi * x))","kernel":"python3","no_halt":true,"pos":13,"start":1673904299114,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904307542,"exec_count":7,"id":"279209","input":"from scipy.optimize import minimize\nimport numpy as np\n\ndef multistart_rastrigin(dim,num_local_searches):\n    minima = np.zeros(num_local_searches)\n    for i in range(num_local_searches):\n        x_initial = np.random.uniform(-5.12, 5.12, dim)\n        result = minimize(rastrigin, x_initial)\n        minima[i] = result.fun\n    return minima\n\ndim = 3\nnum_local_searches = 2000\nmin_values = multistart_rastrigin(dim,num_local_searches)\nsuccesses = sum( min_values < .01)\nprint(f\"The global minimum was found {successes:d} times.\")","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"The global minimum was found 2 times.\n"}},"pos":15,"scrolled":true,"start":1673904299127,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904421885,"exec_count":8,"id":"f1f801","input":"# this could take a few minutes!\n# if you don't want to run it, I did and found the global min 6 times\ndim = 4\nnum_local_searches = 20000\nmin_values = multistart_rastrigin(dim,num_local_searches)\nsuccesses = sum( min_values < .01)\nprint(f\"The global minimum was found {successes:d} times.\")","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"The global minimum was found 5 times.\n"}},"pos":16,"start":1673904307625,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904440750,"exec_count":9,"id":"f6b33b","input":"# this may take a minute\ndim = 10\nnum_local_searches = 1000\nmin_values = multistart_rastrigin(dim,num_local_searches)\nprint(f\"The smallest minimum value found is {np.min(min_values):3.2f}\")","kernel":"python3","metadata":{"hidden":true},"no_halt":true,"output":{"0":{"name":"stdout","text":"The smallest minimum value found is 17.91\n"}},"pos":19,"start":1673904421911,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904440833,"exec_count":10,"id":"886628","input":"def repeat_until_found(dim):\n    best_value = 1.e10\n    iterations = 0\n    while best_value > 0.01:\n        iterations += 1\n        x_initial = np.random.uniform(-5.12, 5.12, dim)\n        result = minimize(rastrigin, x_initial)\n        if result.fun < best_value:\n            best_value = result.fun\n    return(iterations)\n\nrepeat_until_found(1)","kernel":"python3","metadata":{"hidden":true},"no_halt":true,"output":{"0":{"data":{"text/plain":"7"},"exec_count":10}},"pos":23,"start":1673904440820,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904876960,"exec_count":11,"id":"2b0097","input":"num_trials = 100\ndims = np.array([1,2,3])\niterations = np.zeros((num_trials,len(dims)))\nfor i in range(num_trials):\n    for j in range(len(dims)):\n        iterations[i,j] = repeat_until_found(dims[j])","kernel":"python3","metadata":{"hidden":true},"no_halt":true,"pos":25,"start":1673904440841,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904877012,"exec_count":12,"id":"a694ea","input":"average_iterations = np.mean(iterations, axis=0)\nfor j in range(len(dims)):\n    print(\n        'In dimension {:d} it takes {:3.1f} local searches, on average, to find the global min.'\n        .format(dims[j], average_iterations[j]))","kernel":"python3","metadata":{"hidden":true},"no_halt":true,"output":{"0":{"name":"stdout","text":"In dimension 1 it takes 6.3 local searches, on average, to find the global min.\nIn dimension 2 it takes 91.1 local searches, on average, to find the global min.\nIn dimension 3 it takes 989.1 local searches, on average, to find the global min.\n"}},"pos":26,"start":1673904876978,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904877023,"exec_count":13,"id":"9ac7be","input":"print(f\"{10.28**10:,.2f}\")","kernel":"python3","metadata":{"hidden":true},"no_halt":true,"output":{"0":{"name":"stdout","text":"13,180,477,576.06\n"}},"pos":31,"start":1673904877018,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904877037,"exec_count":14,"id":"032650","input":"# number of weeks to do local searches at 10,000 per second\n(10.24**10)/10000/3600/24/7","kernel":"python3","metadata":{"hidden":true},"no_halt":true,"output":{"0":{"data":{"text/plain":"2.095983135297999"},"exec_count":14}},"pos":33,"start":1673904877028,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904877056,"exec_count":15,"id":"0d8355","input":"# fitness and move functions\n\ndef group_fitness(groups,num_groups,values):\n    # groups must be a numpy array for this to work\n    sums = np.array([ sum( values[ groups == i] ) for i in range(num_groups) ])\n    return max(sums)-min(sums)\n\ndef change_group(groups, num_groups, debug=False):\n    #get the unique groups\n    choices = np.arange(0,num_groups)\n    #get a copy of the groups\n    new_groups = groups.copy()\n    #select item to change\n    switch = np.random.randint(0, groups.shape[0])\n    #select new group value\n    new_group = np.random.choice(choices)\n    while groups[switch] == new_group:\n        new_group = np.random.choice(choices)\n    new_groups[switch] = new_group\n    if debug:\n        print(f'The item at {switch} should change to {new_group}')\n        print(f'The initial groups are: {groups} and the changed groups are {new_groups}')\n    return new_groups\n","kernel":"python3","no_halt":true,"pos":36,"start":1673904877041,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904877076,"exec_count":16,"id":"5116af","input":"# Solution - call this function for local search\n\ndef group_balance_search(values, num_groups, max_no_improve, debug=False):\n  \n    #get the total number of items\n    num_items = values.shape[0]\n    \n    #assign them to the number of groups\n    current_groups = np.random.randint(low=0,\n                                          high=num_groups, size=num_items)\n    #get the current_fitness\n    current_fitness =  group_fitness(current_groups, num_groups, values)\n        \n    num_moves_no_improve = 0\n    while (num_moves_no_improve < max_no_improve):\n        num_moves_no_improve += 1\n        new_groups = change_group(current_groups, num_groups, debug)\n        new_fitness = group_fitness(new_groups, num_groups, values)\n        if debug:\n            print(f'Old fitness: {current_fitness}, New fitness {new_fitness}')\n        if new_fitness < current_fitness:\n            current_fitness = new_fitness\n            current_groups = new_groups\n            num_moves_no_improve = 0\n    return current_fitness, current_groups","kernel":"python3","no_halt":true,"pos":37,"start":1673904877062,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904877146,"exec_count":17,"id":"eedee8","input":"# set up data for 4 item/ two group problem\nvalues = np.array([5,10,23,8])\nnum_groups = 2\nmax_moves_no_improve = 10\n\n# search\nfitness, groups = group_balance_search(values, num_groups, max_moves_no_improve, debug=False)\nprint(f'The final fitness is {fitness}')\n\nvalue_sums_df = pd.DataFrame({'Sums': np.zeros(num_groups), 'Group': np.arange(0,num_groups)})\nfor j in range(num_groups):\n    value_sums_df.loc[j,'Sums'] = sum(values[groups==j])\n    \nprint('Our dataframe, after grouping and summing')\ndisplay(value_sums_df)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"The final fitness is 0\nOur dataframe, after grouping and summing\n"},"1":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Sums</th>\n      <th>Group</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>23.0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>23.0</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"   Sums  Group\n0  23.0      0\n1  23.0      1"}}},"pos":38,"start":1673904877112,"state":"done","type":"cell"}
{"cell_type":"code","end":1673904877252,"exec_count":18,"id":"77acb0","input":"# the weird construction here guarantees that 4 groups can be perfectly balanced so the global min is zero\n\nnp.random.seed(123)\n\ntot_num_items = 1000 # should be divisible by 4\nnum_items = int(tot_num_items / 4)\nnum_groups = 4\n\nvalues = np.random.randint(10,100,size=num_items)\nvalues = np.hstack([values,values,values,values])\ngroups = np.random.randint(num_groups,size=1000)\n\nnp.random.seed()\n\nnum_groups = 4\nmax_no_improve = 200\n\nfitness, groups = group_balance_search(values, num_groups, max_no_improve, debug=False)\n\nprint(f'The max difference between groups is {fitness}')\n\nvalue_sums_df = pd.DataFrame({'Sums': np.zeros(num_groups), 'Group': np.arange(0,num_groups)})\nfor j in range(num_groups):\n    value_sums_df.loc[j,'Sums'] = sum(values[groups==j])\n    \nprint('Our dataframe, after grouping and summing')\ndisplay(value_sums_df)","kernel":"python3","no_halt":true,"output":{"0":{"name":"stdout","text":"The max difference between groups is 10\nOur dataframe, after grouping and summing\n"},"1":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Sums</th>\n      <th>Group</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>14047.0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>14038.0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>14042.0</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>14037.0</td>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"      Sums  Group\n0  14047.0      0\n1  14038.0      1\n2  14042.0      2\n3  14037.0      3"}}},"pos":40,"start":1673904877155,"state":"done","type":"cell"}
{"cell_type":"code","id":"2892e4","input":"","pos":41,"type":"cell"}
{"cell_type":"markdown","id":"1c08fc","input":"Approximately now many local searches are required to find the global minimum one time when dim = 10?  Is it surprising that you (very likely) didn't find it with 1000 local searches?  Explain","metadata":{"hidden":true},"pos":29,"type":"cell"}
{"cell_type":"markdown","id":"22278e","input":"# *Self Assessment: How many searches when dim = 10?*","metadata":{"heading_collapsed":true},"pos":28,"type":"cell"}
{"cell_type":"markdown","id":"237cf9","input":"There appear to be local maxima around $x=-3$ and $x=1$ while there appear to be local minima around $x=-0.5$ and $x = 3.5$.","metadata":{"hidden":true},"pos":8,"type":"cell"}
{"cell_type":"markdown","id":"42995f","input":"That's about 13 billion local searches.  Even if we did 10,000 local searches per second, it would still take about two weeks to do enough to find the global minimum once:","metadata":{"hidden":true},"pos":32,"type":"cell"}
{"cell_type":"markdown","id":"4a93f2","input":"# *Self-Assessment: Rastrigin with dim = 3, dim = 4*","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"4d480f","input":"We'll start by writing a function that repeats the local search process until the global minimum is found and returns the total number of local searches.","metadata":{"hidden":true},"pos":22,"type":"cell"}
{"cell_type":"markdown","id":"516af3","input":"The more local searches we perform, the better the probability of locating the global minimum at the origin.  Experiment with the number of local searches to see how the reliability increases.  It turns out that with dim = 3 it takes about 2000 local searches to have a 90% chance at finding the global minimum.  For dim = 4 it takes about 20000 local searches.\n\nIt's possible to arrive at these numbers mathematically, but we just want you to get an idea that the number of local searches required increases dramatically as the dimension increases.","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"5b2ec1","input":"## *Self Assessment: Value Balancing Local Search*","pos":35,"type":"cell"}
{"cell_type":"markdown","id":"5b303f","input":"Now we do this 100 times for each of dim = 1,2,3 and gather the results.  **This code may take several minutes to run.**","metadata":{"hidden":true},"pos":24,"type":"cell"}
{"cell_type":"markdown","id":"750cfd","input":"# *Self-Assessment:  Rastrigin with dim = 10*","metadata":{"heading_collapsed":true},"pos":17,"type":"cell"}
{"cell_type":"markdown","id":"775e3d","input":"# *Self Assessment:  Finding Multiple Extrema*","metadata":{"heading_collapsed":true},"pos":6,"type":"cell"}
{"cell_type":"markdown","id":"7f0082","input":"Fortunately there are better approaches that can often deliver results in much less time!","metadata":{"hidden":true},"pos":34,"type":"cell"}
{"cell_type":"markdown","id":"7fb617","input":"With 1000 local searches the minimum value seems to be anywhere from 12 to 26.  Increasing the number of searches helps, but it's not clear how many iterations to use, but it's likely a lot!","metadata":{"hidden":true},"pos":20,"type":"cell"}
{"cell_type":"markdown","id":"807ec8","input":"193.75 is the relaxed solution, but we can't rent 193.75 apartments.  Let's check 193 and 194 to see which yields a larger profit.","metadata":{"hidden":true},"pos":3,"type":"cell"}
{"cell_type":"markdown","id":"98a00e","input":"Do 1000 local search with Rastrigin with dim = 10.  What is the smallest value you find?  How long do you think it would take to find the minimum from randomly chosen initial points like this?  ","metadata":{"hidden":true},"pos":18,"type":"cell"}
{"cell_type":"markdown","id":"aa1093","input":"How many iterations does it take to reliably find the global minimum with dim = 3?  With dim = 4?  Use the multi-start strategy.","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"b07d97","input":"The number of searches increases roughly by an order of magnitude (power of 10) for each added dimension.","metadata":{"hidden":true},"pos":27,"type":"cell"}
{"cell_type":"markdown","id":"b81943","input":"# *Self-Assessment:  How many searches?*","metadata":{"heading_collapsed":true},"pos":21,"type":"cell"}
{"cell_type":"markdown","id":"bb2205","input":"For the 1000 item problem we generally achieve a local minimum max difference of groups to be anywhere from 2 to 120.","pos":39,"type":"cell"}
{"cell_type":"markdown","id":"be023c","input":"The number of searches would be approximately $(10.28)^{10}$ or","metadata":{"hidden":true},"pos":30,"type":"cell"}
{"cell_type":"markdown","id":"ceaa8b","input":"# *Self Assessment:  Minimize to Maximize*","metadata":{"code_folding":[],"heading_collapsed":true},"pos":1,"type":"cell"}
{"cell_type":"markdown","id":"f51f50","input":"**Note - there is a strange quirk here in the scipy.optimize.minimize.**  When we optimize without bounds `result.fun` is a number, but when we optimize with bounds `result.fun` is a list with one number so we have to refer to `result.fun[0]` to get the number.","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"f9ca36","input":"Bottom line:  rent 194 apartments for profit $220,312.","metadata":{"hidden":true},"pos":5,"type":"cell"}
{"id":0,"time":1673904278501,"type":"user"}
{"last_load":1666212775619,"type":"file"}