{"backend_state":"init","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.7.4"}},"trust":false,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"9962a8","input":"# 3D graph of 2 dimemsional problem\nimport plotly.graph_objs as go\nfrom plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot\nimport numpy as np\n\nx = np.linspace(-2, 2, 401)     \ny = np.linspace(-2, 2, 401)     \nX, Y = np.meshgrid(x, y) \nZ = (np.abs(X)**(np.sin(3*X)) + np.abs(X)**(np.cos(2*X))) + (np.abs(Y)**(np.sin(3*Y)) + np.abs(Y)**(np.cos(2*Y)))\n\n\ndata = [\n    go.Surface( x = X, y = Y, z = Z, colorscale = 'Jet',\n        contours=go.surface.Contours(\n            z=go.surface.contours.Z(\n              show=True,\n              usecolormap=True,\n              highlightcolor=\"#42f462\",\n              project=dict(z=True)\n            )\n        )\n    )\n]\n\nlayout = go.Layout(title='2 Dimensional Function',width=600,height=600)\nfig = go.Figure(data=data, layout=layout)\niplot(fig)","pos":4,"type":"cell"}
{"cell_type":"code","exec_count":143,"id":"3bdecf","input":"#sticking with 2 dimensions here\ndim = 2\n#this tells us how many local searches (starts) we want to do\nnum_local_searches = 1000\n#since we're minimizing, we're starting with our best_value as a large positive number, \n#knowing that any solution we find will be smaller\nbest_value = 1.e10\n\nfor i in range(num_local_searches):\n    x_initial = np.random.uniform(-2, 2, dim) #we want to make sure we start in the right space (-2,2)\n    #get a result for a single starting point - remember to stay within our bounds\n    result = minimize(twoD, x_initial,method='TNC', bounds=bounds)\n    #if this result is less than our current value, keep it\n    if result.fun < best_value:\n        best_value = result.fun\n        best_x = result.x\n\nprint(\n    'The smallest value found is {:4.3f} at x = {:1.3f} and y = {:1.3f}'.format(\n        best_value, best_x[0], best_x[1]))","output":{"0":{"name":"stdout","output_type":"stream","text":"The smallest value found is 1.199 at x = 0.134 and y = 0.134\n"}},"pos":19,"type":"cell"}
{"cell_type":"code","exec_count":151,"id":"2c0782","input":"simpleFunction([5,10])","output":{"0":{"name":"stdout","output_type":"stream","text":"[5, 10, 5, 10, 5, 10, 5, 10, 5, 10, 5, 10, 5, 10, 5, 10, 5, 10, 5, 10]\n"}},"pos":12,"type":"cell"}
{"cell_type":"code","exec_count":152,"id":"eaf622","input":"#pass in a numpy array\nmy_np_array=np.array([5,10])\nsimpleFunction(my_np_array)","output":{"0":{"name":"stdout","output_type":"stream","text":"[ 50 100]\n"}},"pos":14,"type":"cell"}
{"cell_type":"code","exec_count":154,"id":"fd9484","input":"def simpleFunction2(xy):\n    print(sum(xy * 10))\n    \nsimpleFunction2(my_np_array)    ","output":{"0":{"name":"stdout","output_type":"stream","text":"150\n"}},"pos":16,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"296d91","input":"# execute to import notebook styling for tables and width etc.\nfrom IPython.core.display import HTML\n\n\n# imports\n%matplotlib inline\nimport numpy as np\nfrom scipy import interpolate\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Polygon\nimport seaborn as sns\nsns.set_style(\"darkgrid\")","pos":0,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"60fa84","input":"# plot p(x) on [-2,2], using 300 points - the higher the number the smoother the line\nx = np.linspace(-2,2,300)\n\n#this is the one-dimension function\np = lambda x:np.abs(x)**(np.sin(3*x)) + np.abs(x)**(np.cos(2*x))\n\n#plot the function\nfig = plt.figure(figsize=(4,3.5))\nplt.plot(x,p(x));\nplt.xlabel('x');\nplt.ylabel('y');\n","output":{"0":{"data":{"image/png":"727d96ca1ecea3f20d267a6809b3073a9a425a91","text/plain":"<Figure size 288x252 with 1 Axes>"},"exec_count":3,"metadata":{"needs_background":"light"},"output_type":"execute_result"}},"pos":2,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"7ec47a","input":"from scipy.optimize import minimize\n# We see 3 minima, so we'll need 3 starting points\nx0_min = [-1,-.1,1.2]\nmin_x = []\nmin_y = []\nfor x0 in x0_min:\n    ####################################\n    # Note setting bounds here\n    ####################################\n    result = minimize(p,x0,method='TNC', bounds=[(-2,2)])\n    min_x.append(result.x[0])\n    min_y.append(result.fun[0])\n    print('There is a local minimum value of {:3.2f} at x = {:1.2f}'.format(result.fun[0],result.x[0]))\n\n\n#replot with the points added\nx = np.linspace(-2,2,300)\nfig = plt.figure(figsize=(4,3.5))\nplt.plot(x,p(x));\nplt.xlabel('x');\nplt.ylabel('y');\n\n#add dots on the line for min\nplt.scatter(min_x, min_y, color=\"red\", label=\"Minima\")\nplt.legend(loc=\"lower left\")        ","output":{"0":{"name":"stdout","output_type":"stream","text":"There is a local minimum value of 1.95 at x = -1.16\nThere is a local minimum value of 0.60 at x = 0.13\nThere is a local minimum value of 1.21 at x = 1.73\n"},"1":{"data":{"text/plain":"<matplotlib.legend.Legend at 0x29822a2b2c8>"},"exec_count":6,"output_type":"execute_result"},"2":{"data":{"image/png":"acebc153d272d4dd4fdc240f2093c0ff76b730eb","text/plain":"<Figure size 288x252 with 1 Axes>"},"exec_count":6,"metadata":{"needs_background":"light"},"output_type":"execute_result"}},"pos":6,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"d2ff85","input":"from scipy.optimize import minimize\n# We see 3 minima, so we'll need 3 starting points\ndim = 2\n\n#this returns a numpy array, with as many values as your dimensions\nx_initial = np.random.uniform(-2, 2, dim)\nprint('x_initial = ', x_initial)\n\n\n#define a function (more on this in a minute)\ndef twoD(start):\n    return sum((np.abs(start)**(np.sin(3*start)) + np.abs(start)**(np.cos(2*start))))\n\n\n####################################\n# Note setting bounds here - 2 tuples for 2 dimensions\n####################################\n#note that you can multiply this array by the number of dimensions to get a repeating tuple\nbounds = [(-2,2)] * dim\nprint('Bounds = ', bounds)\n\n#get a result\nresult = minimize(twoD,x_initial,method='TNC', bounds=bounds)\n\nprint('There is a local minimum value of {:3.2f} at x = {:1.2f} and y = {:1.2f}'.format(result.fun,result.x[0],result.x[1]))\n","output":{"0":{"name":"stdout","output_type":"stream","text":"x_initial =  [1.5594864  1.64217952]\nBounds =  [(-2, 2), (-2, 2)]\nThere is a local minimum value of 2.42 at x = 1.73 and y = 1.73\n"}},"pos":8,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"c31dc9","input":"def simpleFunction(xy):\n    print(xy * 10)\n\n#pass in a single integer    \nsimpleFunction(5)    ","output":{"0":{"name":"stdout","output_type":"stream","text":"50\n"}},"pos":10,"type":"cell"}
{"cell_type":"markdown","id":"197ab5","input":"Voila! Our $twoD()$ function is doing the exact same thing, just with more \"math bits.\"","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"1b6966","input":"## Multi-start Problems\n\nMulti-start problems just mean that we start the problem multiple times from multiple different starting locations. We did a hard-coded multi-start problem above when finding all of the minima in our 1-dimensional problem. \n\nWhen we look at our 2 dimensional graph, it's pretty hard to figure out where to start by hand, so we can code a multi-start problem to start multiple times, from multiple random locations. In your lesson, you did this to solve the rastrigin problem. But you can do it to solve any problem. Let's try to find the minimum value that we can for our 2-dimension problem by using a multi-start process.","pos":18,"type":"cell"}
{"cell_type":"markdown","id":"38bf5b","input":"### Bounds with Multi-dimensional Problems\n\nTo use bounds with multi-dimensional problems, we need to set an array with a tuple of the min and max boundary for each dimension. \n\nLet's get one of the minima from our 2 dimensional problem. (If you can roll your mouse over that visual you can get some idea of possible starting points, but we're just going to randomly generate one.)","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"50116a","input":"Hey now - that's more like it. We multiplied each of our variables by 10. \n\nWe're still not quite where we want to be though, right? Remember our original function added our 2 results together. Easy peasy. We can just wrap the \"math bits\" with sum in our function.\n\nLet's try it out.","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"5c90dd","input":"Note that if we pass in an number, it returns a number. We're familiar with that. All good.\n\nWhat happens if we pass in a regular list?","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"9eb7d1","input":"#### What's up with that function?\n\nDid you look at that function and wonder what the heck was happening there? Let's break it down. Remember when I said that our 2 dimensional function did all the same \"math\" with both variables? Well, if we pass in a numpy array to our twoD function, it will do the math for each variable. Let's see what that looks like if we do it with a simpler function. First we'll create a super simple function. It's just going to multiply what's passed in by 10.","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"cd4e46","input":"# Lesson 5 Supplemental Materials\n\nThere are few concepts in lesson 4 that routinely raise questions for students. Let's address some of them.\n\n## Dimensions/Dimensionality\nThe dimension is the number of decision variables that a problem has. For continuous variable problems (these are the f(x) type problems where the decision variable can take on any number) we talk about the number of dimensions as the number of $x$ variables ($x1, x2, x3$), but that's just a convention. We could use any letter. \n\nLet's look at a quick example. \n\n### One Dimension\nThis is a 1 dimensional function - we only have 1 variable - $x$.\n\n$f(x) = |x|^{(sin(3x))} + |x|^{(cos(2x))}$\n\nIn case some of this notation is new to you, the || means \"the absolute value of\" whatever is inside the pipe symbols. We wouldn't need to do that, except for the fact that numpy gets confused about fractional exponents and this \"fixes\" it. Just go with it. \n\n### Two Dimensions\nThis is a 2 dimension problem, because we have 2 decision variables ($x,y$):\n\n$f(x,y) = |x|^{(sin(3x))} + |x|^{(cos(2x))} + |y|^{(sin(3y))} + |y|^{(cos(2y))}$\n\n*Note*: we're doing all the same math with both x and y and adding them together. That's going to come in handy in a little bit here.\n\nWe can easily plot our 1 dimension functions on a simple x, y graph. ","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"d9a85c","input":"Functions that contain more than 2 dimensions become more difficult to display visually. But, we can display 2 dimensional functions. Here's what our 2 dimensional function looks like.","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"dace16","input":"Well, that didn't do what we wanted, did it? That gave us a list with 10 of each of the items in our list. (Note, this is exactly how we got our bounds for 2D problem above. Cool!)\n\nNow what happens if we pass in a numpy array?","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"f9459f","input":"\n### Bounds and 1 Dimension Functions\n\nNow let's find all the minima with our 1 dimensional function within the bounds of [-2,2]. Remember that scipi optimize will find the **closest** minimum or maximum to the start point, so to find all of them, we'll have to pick start points that will let the algorithm \"fall into\" the correct trough, or \"climb\" the correct hill. How many minima do you see? How many starting points will we need? \n\n*Note*: the points at the bounds are neither minima nor maxima. We don't know where they \"go\" after the bounds, so we can't make any assumptions.\n\n#### Bounds with scipy minimize\nTo set bounds when you're calling scipy minimize, you can use the 'TNC' method and the bounds parameter. For a 1 dimensional problem, you'll need a single minimum and maximum tuple in an array. \n\n*Note:* When you set bounds, scipy passes back an array for the function instead of single value, at least some of the time. If you're ever getting errors with your string formatting, print out the result and double check what scipy has given you.\n\n","pos":5,"type":"cell"}
{"id":0,"time":1677161785318,"type":"user"}
{"last_load":1677161785385,"type":"file"}