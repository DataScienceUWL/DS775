{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-b406508c-af3f-46b3-90ea-7724b1e64eaf.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.7.3"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1645754702196,"exec_count":1,"id":"369368","input":"#imports\nimport json\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Polygon\n\n#Pulls in the json file\nwith open(\"../data/Caps48.json\", \"r\") as tsp_data:\n    tsp = json.load(tsp_data)\n\n#this is our matrix - more on this in a bit    \ndistance_matrix = tsp[\"DistanceMatrix\"]\n\n#this is where our json file gives us the optimal tour (state) - yay!\noptimal_tour = tsp[\"OptTour\"]\n#this is where our json file gives us the optimal value (objective function/energy/fitness)\nopt_dist = tsp[\"OptDistance\"]/1000 # converted to kilometers\n\n#the coordinates aren't necessary for solving the problem, because we have the distance matrix. \n#But, we use them for plotting the route.\nxy = np.array(tsp[\"Coordinates\"])\n\n#You truly don't have to grok this code. It's drawing a line on a base image to show us the route/state.\ndef plot_tour(best_tour, xy_meters, best_dist, height, width):\n    \n    meters_to_pxl = 0.0004374627441064968\n    intercept_x = 2.464\n    intercept_y = 1342.546\n    xy_pixels = np.zeros(xy_meters.shape)\n    xy_pixels[:,0] = meters_to_pxl * xy_meters[:,0] + intercept_x\n    xy_pixels[:,1] = -meters_to_pxl * xy_meters[:,1] + intercept_y\n\n    fig, ax = plt.subplots(1, 1, figsize=(height, width))\n    im = plt.imread('../images/caps48.png')\n    implot = ax.imshow(im)\n    plt.setp(ax.get_xticklabels(), visible=False)\n    plt.setp(ax.get_yticklabels(), visible=False)\n    ax.tick_params(axis='both', which='both', length=0)\n\n    loop_tour = np.append(best_tour, best_tour[0])\n    ax.plot(xy_pixels[loop_tour, 0],\n            xy_pixels[loop_tour, 1],\n            c='b',\n            linewidth=1,\n            linestyle='-')\n    plt.title('Best Distance {:d} km'.format(int(best_dist)))\n\nplot_tour(optimal_tour, xy, opt_dist, 6, 4)","kernel":"python3","output":{"0":{"data":{"image/png":"00a5ef01cb12d2d8866afa3293618361523a7b32","text/plain":"<Figure size 432x288 with 1 Axes>"},"metadata":{"image/png":{"height":244,"width":349}}}},"pos":1,"start":1645754701178,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":14,"id":"3c9d84","input":"#print straight from matrix\nfor r in range(6):\n    print(distance_matrix[r][0:5])\n\n#cast to dataframe for prettier printing    \nimport pandas as pd\ndf = pd.DataFrame(distance_matrix)\nprint(df.iloc[0:5, 0:5])","output":{"0":{"name":"stdout","output_type":"stream","text":"[0, 2399257, 618109, 3223293, 1856710]\n[2399257, 0, 1813867, 1012102, 937629]\n[618109, 1813867, 0, 2607102, 1241692]\n[3223293, 1012102, 2607102, 0, 1416575]\n[1856710, 937629, 1241692, 1416575, 0]\n[1585403, 3538445, 1869224, 4087186, 2700860]\n         0        1        2        3        4\n0        0  2399257   618109  3223293  1856710\n1  2399257        0  1813867  1012102   937629\n2   618109  1813867        0  2607102  1241692\n3  3223293  1012102  2607102        0  1416575\n4  1856710   937629  1241692  1416575        0\n"}},"pos":3,"type":"cell"}
{"cell_type":"code","exec_count":17,"id":"ba1873","input":"#fetching the distance between city 2 and city 4\ndistance_matrix[2][4]","output":{"0":{"data":{"text/plain":"1241692"},"exec_count":17,"output_type":"execute_result"}},"pos":5,"type":"cell"}
{"cell_type":"code","exec_count":18,"id":"e7a495","input":"#fetching the distance between city 4 and city 2\ndistance_matrix[4][2]","output":{"0":{"data":{"text/plain":"1241692"},"exec_count":18,"output_type":"execute_result"}},"pos":7,"type":"cell"}
{"cell_type":"code","exec_count":21,"id":"11515e","input":"#total number of cities\nnum_cities = 48\n#generate a random order of the numbers 0-47\ncurrent_tour = np.random.permutation(np.arange(num_cities))\n#look at the current tour's order\nprint(current_tour)","output":{"0":{"name":"stdout","output_type":"stream","text":"[12 28 27 45 34 13  8 32  3 21 25 30 42 23 38 19  9  4 14 39  0 44 29 18\n 36 26 24 33  6 17 47 10  2 43 46 41 37 20  1 22 11  5 31 40 15 16  7 35]\n"}},"pos":9,"type":"cell"}
{"cell_type":"code","exec_count":22,"id":"8ec77d","input":"def sub_tour_reversal(tour):\n    # This bit gets the total length of our tour\n    num_cities = len(tour)\n    #this bit picks 2 random numbers (cities) from the list of numbers 0-num_cities\n    i, j = np.sort(np.random.choice(num_cities, 2, replace=False))\n    #return the swapped tour\n    return np.concatenate((tour[0:i], tour[j:-num_cities + i - 1:-1],\n                              tour[j + 1:num_cities]))\n\nsub_tour_reversal(current_tour)","output":{"0":{"data":{"text/plain":"array([12, 28, 27, 41, 46, 43,  2, 10, 47, 17,  6, 33, 24, 26, 36, 18, 29,\n       44,  0, 39, 14,  4,  9, 19, 38, 23, 42, 30, 25, 21,  3, 32,  8, 13,\n       34, 45, 37, 20,  1, 22, 11,  5, 31, 40, 15, 16,  7, 35])"},"exec_count":22,"output_type":"execute_result"}},"pos":11,"type":"cell"}
{"cell_type":"code","exec_count":25,"id":"5c049f","input":"np.random.seed(1)\nsmall_tour =  np.random.permutation(np.arange(5))\nprint(small_tour)","output":{"0":{"name":"stdout","output_type":"stream","text":"[2 1 4 0 3]\n"}},"pos":13,"type":"cell"}
{"cell_type":"code","exec_count":72,"id":"8563e3","input":"#set i and j\ni = 1\nj = 3\n\n# see what's in the tour[0:i] bit - this is the part of the array up to i\nprint(small_tour[0:1])\n\n# see what's in the tour[j:-num_cities + i - 1:-1] (we've hardcoded 5 as the number of cities here)\nprint(small_tour[j:-5 + i - 1:-1])\n\n#see what's in the tour[j + 1:num_cities] - ths is the bit that's after the part we're swapping\nprint(small_tour[j + 1:5])\n\n#if we concatenate all that together....\nprint(np.concatenate((small_tour[0:i], small_tour[j:-5 + i - 1:-1],\n                              small_tour[j + 1:5])))\n","output":{"0":{"name":"stdout","output_type":"stream","text":"[2]\n[0 4 1]\n[3]\n[2 0 4 1 3]\n"}},"pos":15,"type":"cell"}
{"cell_type":"code","exec_count":73,"id":"a9a5ea","input":"#this is our objective function. It measures the current state (tour) that's passed in.\n#it needs the distance matrix to do its work.\ndef tour_distance(tour, dist_mat):\n    distance = dist_mat[tour[-1]][tour[0]]\n    for gene1, gene2 in zip(tour[0:-1], tour[1:]):\n        distance += dist_mat[gene1][gene2]\n    return distance/1000 # convert to kilometers\n\n#get the distance for our starting tour\ntour_distance(current_tour, distance_matrix)","output":{"0":{"data":{"text/plain":"80447.668"},"exec_count":73,"output_type":"execute_result"}},"pos":17,"type":"cell"}
{"cell_type":"code","exec_count":80,"id":"50d482","input":"#let's set some variables so we can run code without calling the function\ndist_mat = distance_matrix\n#let's use our small tour for demo purposes - remember - just five cities\ntour = small_tour\n\n#what's the initial distance variable?\n#remember, to get the distance between any two cities, we use indexing. \n#tour[0] is the first city in our tour\nprint('First city:', tour[0])\n#tour[-1] is the last city in our tour\nprint('Last city:',tour[-1])\n\n#so this bit, is functionally the same as doing dist_mat[3][2] - uncomment the next line to prove it to yourself\n#print(dist_mat[3][2])\n\n#this is getting the distance from the last city to our first city\ndistance = dist_mat[tour[-1]][tour[0]]\nprint('Distance from last city to first city:', distance)","output":{"0":{"name":"stdout","output_type":"stream","text":"First city: 2\nLast city: 3\nDistance from last city to first city: 2607102\n"}},"pos":19,"type":"cell"}
{"cell_type":"code","exec_count":82,"id":"faba15","input":"#We have to wrap the zip with a list to be able to print it.\nlist(zip(tour[0:-1], tour[1:]))","output":{"0":{"data":{"text/plain":"[(2, 1), (1, 4), (4, 0), (0, 3)]"},"exec_count":82,"output_type":"execute_result"}},"pos":21,"type":"cell"}
{"cell_type":"code","exec_count":83,"id":"574ad4","input":"for start, end in zip(tour[0:-1], tour[1:]):\n    print('Start city:', start, 'end city:', end)\n    distance += dist_mat[start][end]\n    print('New Running Total for Distance:', distance)","output":{"0":{"name":"stdout","output_type":"stream","text":"Start city: 2 end city: 1\nNew Running Total for Distance: 4420969\nStart city: 1 end city: 4\nNew Running Total for Distance: 5358598\nStart city: 4 end city: 0\nNew Running Total for Distance: 7215308\nStart city: 0 end city: 3\nNew Running Total for Distance: 10438601\n"}},"pos":23,"type":"cell"}
{"cell_type":"code","exec_count":84,"id":"279882","input":"# You could call this function anything you want. The idea is that it's going to try a bunch of moves and track the best state \ndef random_reversals(dist_mat, max_no_improve):\n    #get the total number of cities - this will be the length of our state variable \n    num_cities = len(dist_mat)\n    \n    # starts from a random tour - this is the initial state (IDEA #1)\n    current_tour = np.random.permutation(np.arange(num_cities))\n    \n    #this is geting our initial measurement of our objective function (IDEA #3)\n    current_dist = tour_distance(current_tour, dist_mat)\n    best_tour = current_tour\n    best_dist = current_dist\n\n    # stop search if no better tour is found within max_no_improve iterations, can increase to eliminate crossovers\n    num_moves_no_improve = 0\n    iterations = 0\n    while (num_moves_no_improve < max_no_improve):\n        num_moves_no_improve += 1\n        iterations += 1  # just for tracking\n        #this is how we're altering our state (IDEA #2)\n        new_tour = sub_tour_reversal(current_tour)\n        #here we're measuring our objective function again (IDEA #3)\n        new_dist = tour_distance(new_tour, dist_mat)\n        #if the current state improves our objective function....\n        if new_dist < current_dist:\n            num_moves_no_improve = 0\n            current_tour = new_tour\n            current_dist = new_dist\n            if current_dist < best_dist:  # not really needed since current_tour will be best\n                best_tour = current_tour  # but we'll use this in the next lesson\n                best_dist = current_dist\n    return best_tour, best_dist, iterations\n\n#Remember that if your function returns multiple variables like ours does, we have to give it multiple variables to \"fill up\"\nbest_tour, best_dist, iterations = random_reversals(distance_matrix, 1000)\nplot_tour(best_tour, xy, best_dist, 9, 6)\nprint('The minimum distance found is {:d} after {:d} iterations'.format(\n    int(best_dist), iterations))","output":{"0":{"name":"stdout","output_type":"stream","text":"The minimum distance found is 18430 after 4698 iterations\n"},"1":{"data":{"image/png":"f17748660572102ad9712ee5cf2646a7b7d6bd29","text/plain":"<Figure size 648x432 with 1 Axes>"},"output_type":"display_data"}},"pos":25,"type":"cell"}
{"cell_type":"markdown","id":"0cd7e7","input":"#### Idea 1: The Initial State\nSo we have a distance matrix which is our source data, but we don't yet have a starting state. We need some way to generate that. We know that we have 48 cities to traverse. We could traverse them in numerical order as our starting state. That would be a valid choice. But, in our code, we chose instead to start from a randomly ordered permutation. We're using numpy's random permutation function to put the numbers 0-47 into a randomly-ordered numpy array.","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"2f62ea","input":"Note that this code works because we are sorting the i and j numbers. If i is larger than j, this wouldn't work.\n\n#### Idea Three: Measuring the State (the Objective Function)\nFor this problem, we want to find the route with the shortest distance to travel. So, we need some way to measure the distance on this route. Enter our tour_distance function.","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"2f7119","input":"This gives us a list of tuples for each city-to-city \"hop.\" Remember that if you have a list of tuples (or a zip object of tuples) you can iterate over it and assign each of the numbers within each tuple to a variable. The function uses gene1 and gene2 as the variable names because it was originally written for a genetic algorithm. But, we could change that to start and end if we wanted to.","pos":22,"type":"cell"}
{"cell_type":"markdown","id":"3fc7f6","input":"#### Idea Two: Changing The State\nNow we need some way to alter this state. We have a function for this called sub_tour_reversal. All this function does is take 2 of the numbers in our state (the numpy array) and swap their places.","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"5de377","input":"Let's manually choose to swap the 1 and the 0. We'll set i to 1 (the 1 is in the second place in the array, starting from zero) and j to 3 (the zero is in the fourth place in the array, starting from zero), and then we'll look at each bit of the return function.","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"5e56de","input":"### Putting It Together\nThis problem does not have any constaints. All of the routes we might find are feasible routes. So now we just need to try a bunch of routes and see if we can find the best one. ","pos":24,"type":"cell"}
{"cell_type":"markdown","id":"61bb3b","input":"The distance between city 4 and city 2 will be the same.","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"62e705","input":"There's one piece of this code that's a bit thick, so let's break it down with a smaller example. Let's get a random set of 5 cities:","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"65ff5b","input":"#### The Distance Matrix\nOkay, so what's this distance matrix and how do we use it? You can think of the distance matrix like an excel spreadsheet, with the column names and row names the cities we want to visit on our tour and the values where they intersect the distance between those two cities. \n\nLet's look at just a snippet of the matrix. We'll fetch the first 5 rows and the first 5 columns of the matrix and print them. We'll also cast to a dataframe and print the first 5 rows and columns that way because it's a little more readable.\n\nNote that there's a diagonal of zeros going through our dataframe. That's because the distance from city 0 to city 0 (the diagonal) is always zero. It's the same place!","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"76927c","input":"Once again this code is pretty dense. Let's break it out bit-by-bit.","pos":18,"type":"cell"}
{"cell_type":"markdown","id":"8ebb9f","input":"If I want to find the distance between any two cities, I can use indexing on the matrix to get it. Looking at our output above, we can see that the distance from city 2 to city 4 is 1241692 meters. Let's fetch that from the matrix:","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"baaa7e","input":"Now we have the distance from the last city to first city, but we need to get the distance between each of the other cities. The next bit does just that. First let's see what we get with this zip bit.","pos":20,"type":"cell"}
{"cell_type":"markdown","id":"f117db","input":"# Traveling Salesman Deep Dive\n\nIn lessons 5 and 6, we cover the traveling salesman problem. We skim over some of the code, because you truly do not need to understand what's happening inside some of the functions in order to be able to use them. But, for those that are curious, let's take a deep dive into the guts of the functions.\n\n\n## Discrete Optimization Big Ideas\nBefore we do that, though, let's touch on the big ideas behind all of our discrete optimization problems. There are few commonalities, and if you understand them, you'll see why you don't need to understand what's happening inside the provided functions. You just need to know the purpose of the function.\n\n### Idea One: Every Problem Starts with an Initial State\nA \"state\" is just the current value or set of values for your decision variable(s). We often start with a randomly selected state, but not always. In the knapsack problem, the initial state is an empty backpack. For the traveling salesman problem, the initial state is a randomly selected route that goes through each location. For the gerrymandering problem, the initial state is cities randomly assigned to districts.  \n\n### Idea Two: Every Problem Requires Some Way to Alter the State\nThe whole point of these optimization problems is that we alter the state to find some minimum or maximum value associated with the state. To get there, we need a way to alter the state. For hand-coded local search, this could be a single line of code that \"flips a bit\" (like in the knapsack problem) or a function that alters the state in some way (like the subtour_reversal function in the TSP problem). When we do simulated annealing, this will be the \"move\" function. In genetic algorithms, changing the state is handled by selection, crossover, and mutation. Sometimes we call this \"making a move.\" Sometimes we call this \"perturbing the state.\" \n\nWhatever we call it, what we're doing is making some **minor** modification to the state, in the hopes that the new state will give us a better result. We want these to be **small moves** so that we find a \"nearby\" state. We don't want to start with a completely random state every time. We're hoping that we're taking steps \"towards\" an optimal state, which is called \"converging\" on the optimal state. If we jump all over the place, it's hard to ever get closer to our goal/converge. \n\n### Idea Three: Every Problem Requires A Way to Measure the State (the Objective Function)\nSo we've changed the state. Now what? Every problem requires some way to measure that state. This is the same as having an objective fuction. \n\nFor the knapsack problem, we're summing the value of the items in the knapsack. For the traveling salesman problem, we're figuring out the total length of the route. For the gerrymandering problem, we're determining the number of districts that Republicans win. In our hand-coded problem, this is usually some bit of code the result of which is assigned to the variable new_value. In simulated annealing, this is the function called \"energy\" and in genetic algorithms this is called evaluating the fitness.\n\n### Idea Four: SOME Problems Include Constraints\nFor discrete problems, we can use either soft constraints or hard constraints. Detailed information about constraints are covered in the <a href=\"https://github.com/DeannaDS/shared/blob/master/ds775/Lesson_05_Load_Balancing_With_Constraints.ipynb\">Load Balancing with Constraints</a> example.\n\nOkay, with that out of the way, let's dive in to the TSP problem. \n\nFirst off, all of the data for this problem is stored in a json file. The json file also handily tells us what the best tour is, so we can start by plotting our best tour. See commented code below.\n","pos":0,"type":"cell"}
{"id":0,"time":1677102451896,"type":"user"}
{"last_load":1645754680245,"type":"file"}