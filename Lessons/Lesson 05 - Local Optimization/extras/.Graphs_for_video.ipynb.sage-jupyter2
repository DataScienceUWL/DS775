{"backend_state":"running","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":248672256},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.9"},"toc":{"base_numbering":1,"nav_menu":{},"number_sections":true,"sideBar":true,"skip_h1_title":false,"title_cell":"Table of Contents","title_sidebar":"Contents","toc_cell":false,"toc_position":{"height":"calc(100% - 180px)","left":"10px","top":"150px","width":"294.588px"},"toc_section_display":true,"toc_window_display":false},"varInspector":{"cols":{"lenName":16,"lenType":16,"lenVar":40},"kernels_config":{"python":{"delete_cmd_postfix":"","delete_cmd_prefix":"del ","library":"var_list.py","varRefreshCmd":"print(var_dic_list())"},"r":{"delete_cmd_postfix":") ","delete_cmd_prefix":"rm(","library":"var_list.r","varRefreshCmd":"cat(var_dic_list()) "}},"types_to_exclude":["module","function","builtin_function_or_method","instance","_Feature"],"window_display":false}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":1,"id":"185371","input":"# includes some css for styling the notebook, not important\nfrom IPython.display import display, HTML\n\ndisplay(HTML(data=\"\"\"\n\n<style>\n    div#notebook-container    { width: 95%; }\n    div#menubar-container     { width: 65%; }\n    div#maintoolbar-container { width: 99%; }\n</style>\n\n<style>\n th{font-size:14px}\n td{font-size:14px}\n.tleft td{text-align:left;}\n.tleft th{text-align:left;}\n.tbrdtop td{border-top: thin solid;}\n.tc td{text-align:center;}\n</style>\n\n\"\"\"))\n\nimport warnings\nwarnings.filterwarnings('ignore')\nwarnings.simplefilter('ignore')","metadata":{"code_folding":[0]},"output":{"0":{"data":{"text/html":"\n\n<style>\n    div#notebook-container    { width: 95%; }\n    div#menubar-container     { width: 65%; }\n    div#maintoolbar-container { width: 99%; }\n</style>\n\n<style>\n th{font-size:14px}\n td{font-size:14px}\n.tleft td{text-align:left;}\n.tleft th{text-align:left;}\n.tbrdtop td{border-top: thin solid;}\n.tc td{text-align:center;}\n</style>\n\n","text/plain":"<IPython.core.display.HTML object>"},"output_type":"display_data"}},"pos":1,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"e93f6e","input":"# imports\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom scipy import interpolate\nfrom scipy.optimize import minimize_scalar, minimize\nimport babel.numbers as numbers\nimport seaborn as sns\nimport plotly.graph_objs as go\nimport plotly.offline as py\nimport plotly\nfrom ipywidgets import *\nfrom sklearn.datasets import make_classification, make_circles #libraries to generate data\nfrom sklearn.neural_network import MLPClassifier #to use neural net\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import log_loss, accuracy_score\nfrom IPython.display import display\n\nsns.set_style(\"darkgrid\")","metadata":{"code_folding":[]},"pos":2,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"2b5984","input":"# unfold to see code for interactive graph, not important to understand\n\ndef f(x):\n    return x**5 - x**4 - 18*x**3 + 16*x**2 + 32*x - 2 \n\ndef fprime(x):\n    return 5*x**4 - 4*x**3 - 54*x**2 + 32*x + 32 \n\nxmin = -4\nxmax = 3.6\n\nsteps = 200\ndt = 0.001\n\ndef descend(x):\n    trajectory = np.zeros(steps)\n    trajectory[0] = x\n    for j in range(1,steps):\n        trajectory[j] = trajectory[j-1] - dt*fprime(trajectory[j-1])\n        trajectory[j] = np.maximum(xmin,trajectory[j])\n        trajectory[j] = np.minimum(xmax,trajectory[j])\n    return trajectory\n\ntraj = descend(0)\nytraj = f(traj)\n\nx = np.linspace(-4,4,1001)\ny = f(x)\ntrace0 = go.Scatter(x = x, y = y, mode = 'lines',hoverinfo = 'none')\n\nidx = 501\ntrace1 = go.Scatter(x = [x[idx]], \n                    y = [y[idx]],\n                    hoverinfo = 'skip',\n                    mode = 'markers',\n                    marker = dict(\n                                size = 10,\n                                color = 'green',\n                                line = dict(\n                                    width = 2,\n                                    color = 'rgb(0, 0, 0)'\n                                            )\n                    )\n                   )\n\ntrace2 = go.Scatter( x = traj, y = ytraj, mode = 'lines',line = dict(width=3,color='black'),hoverinfo='skip')\n\ntrace3 = go.Scatter(x = [traj[-1]], \n                    y = [ytraj[-1]],\n                    hoverinfo = 'skip',\n                    mode = 'markers',\n                    marker = dict(\n                                size = 10,\n                                color = 'red',\n                                line = dict(\n                                    width = 2,\n                                    color = 'rgb(0, 0, 0)'\n                                            )\n                    )\n                   )\n\ndata = [trace0, trace1, trace2, trace3]\n\nlayout = go.Layout(width=500,height=500,\n                   xaxis=dict(range=[-4, 4]),\n                   yaxis=dict(range=[-150, 250]),\n                   showlegend = False,\n                   hovermode = 'closest'\n)\n\nfig = go.Figure(data=data, layout=layout)\nfw = go.FigureWidget(data=fig.data, layout=fig.layout)\n\n# create our callback function\ndef update_point(trace, points, selector):\n    if trace.mode=='lines':\n        with fw.batch_update():\n            x0 = fw.data[0].x[points.point_inds[0]]\n            y0 = fw.data[0].y[points.point_inds[0]]\n            traj = descend(x0)\n            ytraj = f(traj)\n            # update trace1 (green point)\n            fw.data[1].x = [x0]\n            fw.data[1].y = [y0]\n            # update trace 2 (black curve)\n            fw.data[2].x = traj\n            fw.data[2].y = ytraj\n            # update trace 3\n            fw.data[3].x = [traj[-1]]\n            fw.data[3].y = [ytraj[-1]]\n            #f.layout.title = {'text':trace}\n\nfw.data[0].on_click(update_point)\nfw","metadata":{"code_folding":[0]},"output":{"0":{"data":{"application/vnd.jupyter.widget-view+json":{"model_id":"a2ae4f50061944719959c6a2c0f66ad5","version_major":2,"version_minor":0},"text/plain":"FigureWidget({\n    'data': [{'hoverinfo': 'none',\n              'mode': 'lines',\n              'type': 'scatteâ€¦"},"output_type":"display_data"}},"pos":4,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"4461ae","input":"# embed neural network playground\nfrom IPython.display import IFrame    \nIFrame(\"http://playground.tensorflow.org/\", width=1100, height = 700)","metadata":{"code_folding":[0]},"output":{"0":{"data":{"text/html":"\n        <iframe\n            width=\"1100\"\n            height=\"700\"\n            src=\"http://playground.tensorflow.org/\"\n            frameborder=\"0\"\n            allowfullscreen\n        ></iframe>\n        ","text/plain":"<IPython.lib.display.IFrame at 0x7f2ce274d550>"},"exec_count":4,"output_type":"execute_result"}},"pos":7,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"c11a45","input":"# unfold to see code for 1D Rastrigin\ndef rastrigin_1D(x):\n    return(10 + x**2 - 10 * np.cos(2*np.pi*x))\n\nx = np.linspace(-5.12,5.12,201)\ny = rastrigin_1D(x)\n\nfig = plt.figure(figsize=(5,5))\nax = fig.add_subplot(111)\nax.plot(x,y)\nax.set_xlabel('x');\nax.set_ylabel('y');","metadata":{"code_folding":[]},"output":{"0":{"data":{"image/png":"bbd094dfb43df609ac6eaf74d986702662c84472","text/plain":"<Figure size 360x360 with 1 Axes>"},"metadata":{"image/png":{"height":316,"width":325}},"output_type":"display_data"}},"pos":10,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"37acc8","input":"# unfold to see code for interactive graph, not important to understand\nimport plotly.graph_objs as go\nimport plotly.offline as py\nimport plotly\n\nfrom ipywidgets import interactive, HBox, VBox\n\nimport numpy as np\n\ndef f(x):\n    return 10 + x**2 - 10 * np.cos(2*np.pi*x)\n\ndef fprime(x):\n    return 2*x + 20*np.pi*np.sin(2*np.pi*x)\n\nxmin = -5.12\nxmax = 5.12\n\nsteps = 200\ndt = 0.001\n\ndef descend(x):\n    trajectory = np.zeros(steps)\n    trajectory[0] = x\n    for j in range(1,steps):\n        trajectory[j] = trajectory[j-1] - dt*fprime(trajectory[j-1])\n        trajectory[j] = np.maximum(xmin,trajectory[j])\n        trajectory[j] = np.minimum(xmax,trajectory[j])\n    return trajectory\n\ntraj = descend(1.6384)\nytraj = f(traj)\n\nx = np.linspace(-5.12,5.12,1001)\ny = f(x)\ntrace0 = go.Scatter(x = x, y = y, mode = 'lines',hoverinfo = 'none')\n\nidx = 660\ntrace1 = go.Scatter(x = [x[idx]], \n                    y = [y[idx]],\n                    hoverinfo = 'skip',\n                    mode = 'markers',\n                    marker = dict(\n                                size = 10,\n                                color = 'green',\n                                line = dict(\n                                    width = 2,\n                                    color = 'rgb(0, 0, 0)'\n                                            )\n                    )\n                   )\n\ntrace2 = go.Scatter( x = traj, y = ytraj, mode = 'lines',line = dict(width=3,color='black'),hoverinfo='skip')\n\ntrace3 = go.Scatter(x = [traj[-1]], \n                    y = [ytraj[-1]],\n                    hoverinfo = 'skip',\n                    mode = 'markers',\n                    marker = dict(\n                                size = 10,\n                                color = 'red',\n                                line = dict(\n                                    width = 2,\n                                    color = 'rgb(0, 0, 0)'\n                                            )\n                    )\n                   )\n\ndata = [trace0, trace1, trace2, trace3]\n\nlayout = go.Layout(title='1D Rastrigin Function',width=600,height=600,\n                   xaxis=dict(range=[-5.12, 5.12]),\n                   yaxis=dict(range=[-2, 42]),\n                   showlegend = False,\n                   hovermode = 'closest'\n)\n\nfig = go.Figure(data=data, layout=layout)\nfw = go.FigureWidget(data=fig.data, layout=fig.layout)\n\n# create our callback function\ndef update_point(trace, points, selector):\n    if trace.mode=='lines':\n        with fw.batch_update():\n            x0 = fw.data[0].x[points.point_inds[0]]\n            y0 = fw.data[0].y[points.point_inds[0]]\n            traj = descend(x0)\n            ytraj = f(traj)\n            # update trace1 (green point)\n            fw.data[1].x = [x0]\n            fw.data[1].y = [y0]\n            # update trace 2 (black curve)\n            fw.data[2].x = traj\n            fw.data[2].y = ytraj\n            # update trace 3\n            fw.data[3].x = [traj[-1]]\n            fw.data[3].y = [ytraj[-1]]\n            #f.layout.title = {'text':trace}\n\nfw.data[0].on_click(update_point)\nfw","metadata":{"code_folding":[0]},"output":{"0":{"data":{"application/vnd.jupyter.widget-view+json":{"model_id":"1a0d915c6f084473af57520c088d770f","version_major":2,"version_minor":0},"text/plain":"FigureWidget({\n    'data': [{'hoverinfo': 'none',\n              'mode': 'lines',\n              'type': 'scatteâ€¦"},"output_type":"display_data"}},"pos":11,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"289924","input":"# plot of 2D Rastrigin with contours, uses Plotly\nx = np.linspace(-5.12, 5.12, 201)     \ny = np.linspace(-5.12, 5.12, 201)     \nX, Y = np.meshgrid(x, y) \nZ = (X**2 - 10 * np.cos(2 * np.pi * X)) + \\\n  (Y**2 - 10 * np.cos(2 * np.pi * Y)) + 20\n\ndata = [\n    go.Surface( x = X, y = Y, z = Z, colorscale = 'Jet',\n        contours=go.surface.Contours(\n            z=go.surface.contours.Z(\n              show=True,\n              usecolormap=True,\n              highlightcolor=\"#42f462\",\n              project=dict(z=True)\n            )\n        )\n    )\n]\n\nlayout = go.Layout(title='2D Rastrigin',width=600,height=600)\nfig = go.Figure(data=data, layout=layout)\npy.iplot(fig)","metadata":{"code_folding":[]},"output":{"0":{"data":{"text/html":"<iframe\n    scrolling=\"no\"\n    width=\"620px\"\n    height=\"620\"\n    src=\"iframe_figures/figure_0.html?fullscreen=kiosk\"\n    frameborder=\"0\"\n    allowfullscreen\n></iframe>\n"},"output_type":"display_data"}},"pos":12,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"2f3eda","input":"# Matplotlib Trajectory Explorer\n\ndef rastrigin(xy):\n    z = (xy[0]**2 - 10 * np.cos( 2 * np.pi * xy[0]) ) + \\\n    (xy[1]**2 - 10 * np.cos( 2 * np.pi * xy[1] ) ) + 20\n    return(z)\n\ndef grad_rastrigin(coord):\n    x = coord[0]\n    y = coord[1]\n    zx = (2*x + 20 * np.pi * np.sin( 2 * np.pi * x ) )\n    zy = (2*y + 20 * np.pi * np.sin( 2 * np.pi * y ) )\n    grad = np.array([zx,zy])\n    return(grad)\n\nxlim = -2 # usually 5.12\nylim = -2 # usually 5.12\nx = np.linspace(-xlim, xlim, 100)     \ny = np.linspace(-ylim, ylim, 100)     \nX, Y = np.meshgrid(x, y) \nZ = rastrigin(np.array([X,Y]))\ndXdY = -grad_rastrigin(np.array([X,Y]))\ndX = dXdY[0]\ndY = dXdY[1]\n\ndef descend( xy0 ):\n    nsteps = 100\n    xy = np.zeros([nsteps,2])\n    xy[0,:] = xy0\n    for i in range(1,nsteps):\n        xy[i,:] = xy[i-1,:] - .001*grad_rastrigin( xy[i-1,:] )\n    return (xy)\n\nx0 = 1; y0 = 1;\ntrajectory = descend( np.array( [x0,y0] ) )\nzstart = rastrigin(trajectory[0,:])\nzend = rastrigin(trajectory[-1,:])\n\nfig = plt.figure(figsize=(6,6))\nax = fig.add_subplot(111)\nax.set_aspect(1.0)\nplt.contour(X,Y,Z,cmap=cm.jet)\npt, = plt.plot(x0,y0,'g.',markersize = 14)\ntraj, = plt.plot(trajectory[:,0],trajectory[:,1],'k')\npt2, = plt.plot(trajectory[-1,0],trajectory[-1,1],'r.',markersize = 14)\n\nq = ax.quiver(X[::3,::3], Y[::3,::3], dX[::3,::3], dY[::3,::3])\nax.quiverkey(q, X=0.3, Y=10.1, U=10,label = '')\n\nnum2str = '{0:.{1}f}'.format\ntxt = plt.text(-2,2.1,'At start: ')\ntxt2 = plt.text(-1.2,2.1,num2str(zstart,1),color='green')\ntxt3 = plt.text(0,2.1,'At end: ')\ntxt4 = plt.text(1,2.1,num2str(zend,1),color='red')\n\n\ndef onclick(event):\n    x0 = event.xdata\n    y0 = event.ydata\n    trajectory = descend( np.array( [x0,y0] ) )\n    pt.set_xdata(trajectory[0,0])\n    pt.set_ydata(trajectory[0,1])\n    pt2.set_xdata(trajectory[-1,0])\n    pt2.set_ydata(trajectory[-1,1])\n    traj.set_xdata(trajectory[:,0])\n    traj.set_ydata(trajectory[:,1])\n    zstart = rastrigin(trajectory[0,:])\n    zend = rastrigin(trajectory[-1,:])    \n    txt2.set_text(num2str(zstart,1))\n    txt4.set_text(num2str(zend,1))\n\ncid = fig.canvas.mpl_connect('button_press_event', onclick)","metadata":{"code_folding":[0]},"output":{"0":{"data":{"image/png":"fe336fbda667e7260e9ead476235fef15a70dbcf","text/plain":"<Figure size 432x432 with 1 Axes>"},"metadata":{"image/png":{"height":372,"width":374}},"output_type":"display_data"}},"pos":13,"type":"cell"}
{"cell_type":"code","id":"54a3eb","input":"","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"69fe1d","input":"# Machine Learning and Local Minima","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"6a9c52","input":"The Rastrigin function is a common test case for optimization algorithms because it has many local minima.  The definition of the function is \n$$f(\\mathbf{x})=10 n+\\sum_{i=1}^{n}\\left[x_{i}^{2}-10 \\cos \\left(2 \\pi x_{i}\\right)\\right]$$\nWhere $n$ is the dimensionality of input vector $\\mathbf{x}$.  For instance if $n=2$ then $\\mathbf{x} = (x_1, x_2)$.  \n\nThe domain is restricted so that each $x_i \\in [-5.12, 5.12].$ \n\nThe global minimum value is 0 and occurs when $x_i = 0$ for all $i.$\n\nYou can count from the graph that there are 11 local minima and 1 global minimum.  \n\nThe number of local minima increases exponentially as $11^n$ but there is only global minimum.\n\nHere is a graph of the the Rastrigin function with dimension $n=1.$ ","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"89e06c","input":"This demo is inspired by the <a href=\"https://playground.tensorflow.org/\"> Neural Network Playground from Tensorflow.</a> The Playground is a seriously fun and interesting tool for beginning to develop some understanding of using neural networks for classification.  **Go to the link above and play, or use the embedded version below**","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"986d9f","input":"# Gradient Descent and Local Minima","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"ef1acb","input":"**Some code in this notebook does not work in the Cocalc Jupyter interface, please run this using a Classic Jupyter Notebook**","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"fe4202","input":"# The Rastrigin Function","pos":8,"type":"cell"}
{"id":0,"time":1595437382724,"type":"user"}
{"last_load":1595437825208,"type":"file"}