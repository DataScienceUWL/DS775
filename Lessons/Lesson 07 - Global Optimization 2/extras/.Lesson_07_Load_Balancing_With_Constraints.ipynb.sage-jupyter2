{"backend_state":"init","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.2"},"toc":{"base_numbering":1,"nav_menu":{},"number_sections":true,"sideBar":true,"skip_h1_title":false,"title_cell":"Table of Contents","title_sidebar":"Contents","toc_cell":false,"toc_position":{"height":"calc(100% - 180px)","left":"10px","top":"150px","width":"250.696px"},"toc_section_display":true,"toc_window_display":true},"varInspector":{"cols":{"lenName":16,"lenType":16,"lenVar":40},"kernels_config":{"python":{"delete_cmd_postfix":"","delete_cmd_prefix":"del ","library":"var_list.py","varRefreshCmd":"print(var_dic_list())"},"r":{"delete_cmd_postfix":") ","delete_cmd_prefix":"rm(","library":"var_list.r","varRefreshCmd":"cat(var_dic_list()) "}},"types_to_exclude":["module","function","builtin_function_or_method","instance","_Feature"],"window_display":false}},"trust":false,"type":"settings"}
{"cell_type":"code","exec_count":1,"id":"c8c841","input":"#imports\nimport numpy as np","pos":0,"type":"cell"}
{"cell_type":"code","exec_count":10,"id":"ee630d","input":"# local search function\ndef load_balance_local_feasible(times, k, max_no_improve,conproc,conmax):\n    n = len(times)\n    ###############################################\n    #NEW - get a random sample of size n using choices from the unconstrained processors\n    #this will assign all to one processor if only one is unconstrained\n    unconstrained = [x for x in list(range(k)) if x not in conproc]\n    current_x = np.random.choice(unconstrained,size=n,replace=True)\n    ###############################################\n    current_f = balance_metric(current_x, times, k)\n    best_x = current_x\n    best_f = current_f\n    ##########################\n    # New - track convergence\n    converged = False\n    ##########################\n    # stop search if no better x is found within max_no_improve iterations\n    num_moves_no_improve = 0\n    iterations = 0\n    while (num_moves_no_improve < max_no_improve):\n        num_moves_no_improve += 1\n        iterations += 1  # just for tracking\n        ##################################\n        # NEW - pass the extra parameters to reassign_one\n        new_x = reassign_one_constrained(current_x,k,conproc,conmax)\n        ##################################\n        new_f = balance_metric(new_x, times, k)\n        if new_f < current_f:\n            #################################\n            #NEW - track if we ever accept a solution\n            converged = True\n            #################################      \n            num_moves_no_improve = 0\n            current_x = new_x\n            current_f = new_f\n            if current_f < best_f:  \n                best_x = current_x  \n                best_f = current_f\n    return best_x, best_f, iterations, converged\n\n","pos":20,"type":"cell"}
{"cell_type":"code","exec_count":11,"id":"12f5a9","input":"best_assign, best_f, num_iter, converged = load_balance_local_feasible(times,k,5000,[0],[1100]) \nprint('The algorithm found a solution that met the criteria:', converged)\nprint('The best assignment is', best_assign)\nprint('Total time on each processor:', [ sum(times[best_assign==j]) for j in range(k)])\nprint('The deviation from balance is', best_f)\nprint('It took', num_iter, 'iterations.')","output":{"0":{"name":"stdout","output_type":"stream","text":"The algorithm found a solution that met the criteria: True\nThe best assignment is [0 2 1 1 2 0 2 1 0 0 0 1 1 1 1 0 2 2 0 1 0 2 2 2 0 1 1 2 1 0]\nTotal time on each processor: [1093, 1297, 1272]\nThe deviation from balance is 24760.666666666664\nIt took 5292 iterations.\n"}},"pos":22,"type":"cell"}
{"cell_type":"code","exec_count":12,"id":"d2a9ac","input":"best_assign, best_f, num_iter, converged = load_balance_local_feasible(times,k,5000,[0,1],[1200,1100]) #adding our 2 additional parameters here\nprint('The algorithm found a solution that met the criteria:', converged)\nprint('The best assignment is', best_assign)\nprint('Total time on each processor:', [ sum(times[best_assign==j]) for j in range(k)])\nprint('The deviation from balance is', best_f)\nprint('It took', num_iter, 'iterations.')","output":{"0":{"name":"stdout","output_type":"stream","text":"The algorithm found a solution that met the criteria: True\nThe best assignment is [2 2 1 2 0 1 2 1 2 1 2 1 1 2 0 1 0 0 0 0 2 2 1 0 2 2 1 0 1 0]\nTotal time on each processor: [1178, 1077, 1407]\nThe deviation from balance is 57180.666666666664\nIt took 5093 iterations.\n"}},"pos":24,"type":"cell"}
{"cell_type":"code","exec_count":13,"id":"dbd0e7","input":"\ndef custom_simanneal(times, k, max_no_improve, temp, alpha, conproc, conmax):\n    #get the length of our jobs\n    n = len(times)\n    # starts from a random assignment to the unconstrained processors\n    unconstrained = [x for x in list(range(k)) if x not in conproc]\n    current_x = np.random.choice(unconstrained,size=n,replace=True)\n    current_f = balance_metric(current_x, times, k)\n    best_x = current_x\n    best_f = current_f\n    \n    #this is just for tracking\n    iterations = 1\n    trajectory = [[iterations,current_f]]\n    trajectory_best = [[iterations,best_f]]\n    ##########################\n    # New - track convergence\n    converged = False\n    ##########################\n\n    # stop search if no better x is found within max_no_improve iterations\n    num_moves_no_improve = 0\n    while (num_moves_no_improve < max_no_improve):\n        num_moves_no_improve += 1\n        iterations += 1  # just for tracking\n        ###################################\n        #NEW - add the 2 extra parameters\n        new_x = reassign_one_constrained(current_x,k, conproc, conmax)\n        ###################################\n        new_f = balance_metric(new_x, times, k)\n      \n        #determine the change in score\n        delta = new_f - current_f\n        #determine the probability of accepting this solution\n        prob = np.exp(min(delta, 0) / temp)\n        \n        #determine if we'll accept this solution\n        accept = new_f < current_f or np.random.uniform() < prob          \n        if accept:   \n            current_x = new_x\n            current_f = new_f\n            if current_f < best_f:  \n                #################\n                #New - track if we ever got a better solution than the first\n                converged = True\n                #################\n                best_x = current_x  \n                best_f = current_f\n                num_moves_no_improve = 0\n        temp *= alpha\n        iterations += 1\n        trajectory.append([iterations,current_f])\n        trajectory_best.append([iterations,best_f])        \n    return best_x, best_f, iterations, trajectory, trajectory_best,converged ####NEW: Return extra variable\n    \n\n#######\n# New - add the 2 extra parameters\nbest_x, best_f, iterations, trajectory, trajectory_best, converged = custom_simanneal(times, k, 1000, 500, .99, [0],[1100])\n\nprint('The algorithm found a solution that met the criteria:', converged)\nprint('The best assignment is', best_f)\nprint('Total time on each processor:', [ sum(times[best_x==j]) for j in range(k)])\nprint('The deviation from balance is', best_f)","output":{"0":{"name":"stdout","output_type":"stream","text":"The algorithm found a solution that met the criteria: True\nThe best assignment is 22858.666666666668\nTotal time on each processor: [1098, 1294, 1270]\nThe deviation from balance is 22858.666666666668\n"}},"pos":26,"type":"cell"}
{"cell_type":"code","exec_count":14,"id":"672947","input":"#this line just imports the package\nfrom simanneal import Annealer\n\n#this is the line where we decide what we're calling this problem\nclass loadProblemHC(Annealer):\n\n    # Here's where we pass extra data if we need it. We need to pass our times (jobs) variable and the number of servers (k)\n    ##############################\n    #NEW - add 2 extra parameters\n    def __init__(self, state, times, k, conproc, conmax):\n        ###############################\n        #this line makes the times accessible within the other two functions\n        self.times = times\n        self.k = k\n        ###########################\n        # New Set up 2 new variables\n        self.conproc = conproc\n        self.conmax = conmax\n        ###########################\n        #this is how we initialize - note we're calling super with the same name as above (loadProblem)\n        super(loadProblemHC, self).__init__(state)  # important!\n\n    def move(self):\n        \"\"\"This corresponds to our previous reassign one function\"\"\"\n        # pick one of the jobs and assign it to one of k processors\n        \n        #############################\n        #NEW - We have to COPY the state\n        assign = self.state.copy()\n        n = len(assign)\n        k = self.k\n        # choose a job and a new processor assignment\n        which_job = np.random.randint(0,n,1)[0]\n        which_proc = np.random.randint(0,k,1)[0]\n        assign[which_job] = which_proc\n        \n        #################################################\n        # NEW - hard constraint enforcement\n        over_max = True in [sum(self.times[assign==c]) > self.conmax[c] for c in self.conproc]\n        # Only update the state if it meets our requirements\n        if over_max == False:\n            #we only update the state if we've met our constraints\n            self.state = assign\n        \n    \n    def energy(self):\n        \"\"\"This corresponds to our balance_metric function\"\"\"\n        times = self.times\n        assign = self.state\n        k = self.k\n        target = sum(times)/k\n        return sum( (sum(times[assign==j])-target)**2 for j in range(k) )\n\n\n    \n    \n################################\n#NEW - generate an initial feasible assignment\n################################\nunconstrained = [x for x in list(range(k)) if x not in [0]]\nassign = np.random.choice(unconstrained,size=n,replace=True)\n#initialize the class\nld = loadProblemHC(assign, times, k, [0], [1100])\nld.set_schedule(ld.auto(minutes=.2)) #set approximate time to find results\n\n# since our state is a numpy array, we need deepcopy\nld.copy_strategy = \"deepcopy\" \n#this is what kicks it off\nbest_assign, best_score = ld.anneal()\n\n\n\nprint('The best set is: ', best_assign)\nprint('Total time on each processor:', [ sum(times[best_assign==j]) for j in range(k)])\nprint('The best score is:', best_score) ","output":{"0":{"name":"stderr","output_type":"stream","text":" Temperature        Energy    Accept   Improve     Elapsed   Remaining\n   730.00000      22620.67    55.30%     0.00%     0:00:02     0:00:001 Temperature        Energy    Accept   Improve     Elapsed   Remaining\n   730.00000      27402.67    56.20%     0.06%     0:00:14     0:00:003"},"1":{"name":"stdout","output_type":"stream","text":"The best set is:  [0 2 2 1 2 2 0 2 1 1 1 2 1 0 0 1 1 1 2 1 0 1 2 2 0 0 2 1 0 0]\nTotal time on each processor: [1100, 1281, 1281]\nThe best score is: 21840.666666666668\n"}},"pos":28,"type":"cell"}
{"cell_type":"code","exec_count":15,"id":"c3990c","input":"#this line just imports the package\nfrom simanneal import Annealer\n\n#this is the line where we decide what we're calling this problem\nclass loadProblemHCWithFunctions(Annealer):\n\n    # Here's where we pass extra data if we need it. We need to pass our times (jobs) variable and the number of servers (k)\n    ##############################\n    #NEW - add 2 extra parameters\n    def __init__(self, state, times, k, conproc, conmax):\n        ###############################\n        #this line makes the times accessible within the other two functions\n        self.times = times\n        self.k = k\n        ###########################\n        # New Set up 2 new variables\n        self.conproc = conproc\n        self.conmax = conmax\n        ###########################\n        #this is how we initialize - note we're calling super with the same name as above (loadProblem)\n        super(loadProblemHCWithFunctions, self).__init__(state)  # important!\n\n    def move(self):\n        \"\"\"Can directly call our reassign one constrained function\"\"\"\n        #since we're copying in our reassign_one_constrained function, we can pass the self.state directly\n        self.state = reassign_one_constrained(self.state,self.k, self.conproc, self.conmax)\n        \n    \n    def energy(self):\n        \"\"\"Can directly call our balance_metric function\"\"\"        \n        return balance_metric(self.state, self.times, self.k)\n\n\n    \n    \n################################\n#AGAIN - generate an initial feasible assignment\n################################\nunconstrained = [x for x in list(range(k)) if x not in [0]]\nassign = np.random.choice(unconstrained,size=n,replace=True)\n#initialize the class\nld2 = loadProblemHCWithFunctions(assign, times, k, [0], [1100])\nld2.set_schedule(ld2.auto(minutes=.2)) #set approximate time to find results\n\n# since our state is a numpy array, we need deepcopy\nld2.copy_strategy = \"deepcopy\" \n#this is what kicks it off\nbest_assign, best_score = ld2.anneal()\n\n\n\nprint('The best set is: ', best_assign)\nprint('Total time on each processor:', [ sum(times[best_assign==j]) for j in range(k)])\nprint('The best score is:', best_score) ","output":{"0":{"name":"stderr","output_type":"stream","text":" Temperature        Energy    Accept   Improve     Elapsed   Remaining\n   490.00000      27220.67    55.95%     0.00%     0:00:02     0:00:001 Temperature        Energy    Accept   Improve     Elapsed   Remaining\n   490.00000      22082.67    55.09%     0.14%     0:00:13     0:00:001"},"1":{"name":"stdout","output_type":"stream","text":"The best set is:  [0 0 1 2 1 1 1 2 1 0 0 0 1 2 0 1 2 0 1 1 2 2 1 1 0 2 2 0 2 2]\nTotal time on each processor: [1100, 1281, 1281]\nThe best score is: 21840.666666666668\n"}},"pos":30,"type":"cell"}
{"cell_type":"code","exec_count":16,"id":"bcfc2d","input":"\n# constrained objective function = total squared deviation of times from balanced times, providing a penalty for constraints\ndef balance_metric_constrained(assign,times,k,conproc,conmax, penalty_multiplier):\n    #get the unconstrained balance metric\n    dev_uncon = balance_metric(assign,times,k)\n    #sum the constrained processors and apply our penalty\n    dev_penalty = penalty_multiplier * sum( max(sum(times[assign==c])-conmax[c],0)**2 for c in conproc )\n    return (dev_uncon + dev_penalty)","pos":33,"type":"cell"}
{"cell_type":"code","exec_count":17,"id":"c1782b","input":"#testing perfectly balanced unconstrained\nk = 3\ntimes = np.array([2,4,6,2,4,6,2,4,6])\nassign=np.array([0,0,0,1,1,1,2,2,2])\n\n# total time on each processor ... should be the same\nprint('Total time on each processor:', [ sum(times[assign==j]) for j in range(k)])\n#print the original balance metric\nprint('Unconstrained Balance Metric:', balance_metric(assign,times,k))","output":{"0":{"name":"stdout","output_type":"stream","text":"Total time on each processor: [12, 12, 12]\nUnconstrained Balance Metric: 0.0\n"}},"pos":35,"type":"cell"}
{"cell_type":"code","exec_count":18,"id":"8a891a","input":"# total time on each processor has not changed\nprint('Total time on each processor (has not changed):', [ sum(times[assign==j]) for j in range(k)])\n#Constrain processor 1 to 10\nprint('Constrained Balance Metric:', balance_metric_constrained(assign,times,k,[0],[10], 5))","output":{"0":{"name":"stdout","output_type":"stream","text":"Total time on each processor (has not changed): [12, 12, 12]\nConstrained Balance Metric: 20.0\n"}},"pos":37,"type":"cell"}
{"cell_type":"code","exec_count":19,"id":"e86446","input":"# total time on each processor has not changed\nprint('Total time on each processor (has not changed):', [ sum(times[assign==j]) for j in range(k)])\n#Constrain processor 1 to 10, with a penalty of 10\nprint('Constrained Balance Metric:', balance_metric_constrained(assign,times,k,[0],[10], 10))","output":{"0":{"name":"stdout","output_type":"stream","text":"Total time on each processor (has not changed): [12, 12, 12]\nConstrained Balance Metric: 40.0\n"}},"pos":39,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"70300f","input":"# original objective function = total squared deviation of times from balanced times\ndef balance_metric(assign,times,k):\n    target = sum(times)/k\n    return sum( (sum(times[assign==j])-target)**2 for j in range(k) )\n","pos":4,"type":"cell"}
{"cell_type":"code","exec_count":20,"id":"53c3ae","input":"#new assignments\nassign=np.array([1,0,0,1,1,1,2,2,2])\nprint('Total time on each processor (has changed):', [ sum(times[assign==j]) for j in range(k)])\n\n#check the unconstrained balance metric\nprint('Balance Metric without constraints', balance_metric(assign,times,k))\n#check the constrained balance metric\nprint('Constrained Balance Metric:', balance_metric_constrained(assign,times,k,[0],[10],5))","output":{"0":{"name":"stdout","output_type":"stream","text":"Total time on each processor (has changed): [10, 14, 12]\nBalance Metric without constraints 8.0\nConstrained Balance Metric: 8.0\n"}},"pos":41,"type":"cell"}
{"cell_type":"code","exec_count":21,"id":"e49b3b","input":"#this line just imports the package\nfrom simanneal import Annealer\n\n#this is the line where we decide what we're calling this problem\nclass loadProblemSC(Annealer):\n\n    # Here's where we pass extra data if we need it. We need to pass our times (jobs) variable and the number of servers (k)\n    ##############################\n    #NEW - add 2 extra parameters\n    def __init__(self, state, times, k, conproc, conmax, penalty_multiplier):\n        ###############################\n        #this line makes the times accessible within the other two functions\n        self.times = times\n        self.k = k\n        ###########################\n        # New Set up 3 new variables\n        self.conproc = conproc\n        self.conmax = conmax\n        self.penalty_multiplier = penalty_multiplier\n        ###########################\n        #this is how we initialize - note we're calling super with the same name as above (loadProblem)\n        super(loadProblemSC, self).__init__(state)  # important!\n\n    def move(self):\n        \"\"\"This corresponds to our previous reassign one function\"\"\"\n        # pick one of the jobs and assign it to one of k processors\n        ##################################\n        #NEW - back to just changing the state directly\n        assign = self.state\n        n = len(assign)\n        k = self.k\n        # choose a job and a new processor assignment\n        which_job = np.random.randint(0,n,1)[0]\n        which_proc = np.random.randint(0,k,1)[0]\n        assign[which_job] = which_proc\n\n        \n    \n    def energy(self):\n        \"\"\"This corresponds to our balance_metric function\"\"\"\n        times = self.times\n        assign = self.state\n        k = self.k\n        conproc = self.conproc\n        conmax = self.conmax\n        ############################################\n        #NEW - determing the energy and assign a penalty\n        target = sum(times)/k\n        #sum the total processor deviation\n        dev_uncon = sum( (sum(times[assign==j])-target)**2 for j in range(k) )\n        #sum the constrained processor deviation and apply penalty\n        dev_penalty = self.penalty_multiplier * sum( max(sum(times[assign==c])-conmax[c],0)**2 for c in conproc )\n\n        return (dev_uncon + dev_penalty)/100","pos":44,"type":"cell"}
{"cell_type":"code","exec_count":22,"id":"e0989b","input":"# generate random job times\nnp.random.seed(666) #comment this out to play with new numbers\n#we'll start with 20 execution times\nn = 30\n#we'll start with 2 processors\nk = 3\nmin_time = 20\nmax_time = 200\ntimes = np.random.randint(low=min_time, high = max_time, size = n)\nassign = np.random.randint(low=0,high=k,size=n)\n# total time on each processor\nprint('Total time on each processor, if completely balanced:', sum(times)/k)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Total time on each processor, if completely balanced: 1220.6666666666667\n"}},"pos":46,"type":"cell"}
{"cell_type":"code","exec_count":23,"id":"cf4115","input":"#initialize the class\nld = loadProblemSC(assign, times, k, [0], [1100], 5) #penalty = 5\nld.set_schedule(ld.auto(minutes=.2)) #set approximate time to find results\n\n# since our state is a numpy array, we need deepcopy\nld.copy_strategy = \"deepcopy\" \n#this is what kicks it off\nbest_assign, best_score = ld.anneal()\n\n\n\n#print('The best set is: ', best_assign)\nprint('Total time on each processor:', [ sum(times[best_assign==j]) for j in range(k)])\nprint('The best score is:', best_score) ","output":{"0":{"name":"stderr","output_type":"stream","text":" Temperature        Energy    Accept   Improve     Elapsed   Remaining\n     3.00000        181.21    33.80%     0.00%     0:00:02     0:00:00 Temperature        Energy    Accept   Improve     Elapsed   Remaining\n     3.00000        168.09    33.42%     0.00%     0:00:13     0:00:00"},"1":{"name":"stdout","output_type":"stream","text":"Total time on each processor: [1128, 1267, 1267]\nThe best score is: 168.00666666666663\n"}},"pos":48,"type":"cell"}
{"cell_type":"code","exec_count":24,"id":"167d7d","input":"# No changes to this function\ndef create_individual(k,n):\n    current_x = np.random.randint(low=0,high=k,size=n)\n    return current_x.tolist() #this converts our np array back to a list\n\n\n# no changes here, call this to execute the genetic algorithm\ndef customGA(in_toolbox,in_tools,in_stats,pop_size, cx_prob, mut_prob, max_gen, max_no_improve):\n\n    pop = in_toolbox.population(n=pop_size)\n    logbook = in_tools.Logbook()\n    hof = in_tools.HallOfFame(1)\n\n    # Evaluate the entire population\n    fitnesses = list(map(in_toolbox.evaluate, pop))\n    for ind, fit in zip(pop, fitnesses):\n        ind.fitness.values = fit\n\n    hof.update(pop)\n    best_val = hof[0].fitness.values\n    num_no_improve = 0\n    generation = 0\n\n    while num_no_improve < max_no_improve and generation < max_gen:\n\n        # Select the next generation individuals\n        selected = in_toolbox.select(pop, len(pop))\n        # Clone the selected individuals\n        offspring = list(map(in_toolbox.clone, selected))\n\n        # Apply crossover and mutation on the offspring\n        for child1, child2 in zip(offspring[::2], offspring[1::2]):\n            if random.random() < cx_prob:\n                in_toolbox.mate(child1, child2)\n                del child1.fitness.values\n                del child2.fitness.values\n\n        for mutant in offspring:\n            if random.random() < mut_prob:\n                in_toolbox.mutate(mutant)\n                del mutant.fitness.values\n\n        # Evaluate the individuals with an invalid fitness\n        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]\n        fitnesses = map(in_toolbox.evaluate, invalid_ind)\n        num_evals = 0\n        for ind, fit in zip(invalid_ind, fitnesses):\n            num_evals += 1\n            ind.fitness.values = fit\n\n        # The population is entirely replaced by the offspring\n        pop[:] = offspring\n        \n        # track the best value and reset counter if there is a change\n        hof.update(pop)\n        curr_best_val = hof[0].fitness.values[0]\n        num_no_improve += 1\n        if curr_best_val != best_val:\n            best_val = curr_best_val\n            num_no_improve = 0\n\n        # record stats\n        record = in_stats.compile(pop)\n        logbook.record(gen=generation, evals=num_evals, **record)\n\n        # increment generation\n        generation += 1\n\n    best_x = list(hof[0])\n\n    return best_val, best_x, logbook","pos":50,"type":"cell"}
{"cell_type":"code","exec_count":25,"id":"fe8854","input":"# objective function = total squared deviation of times from balanced times\ndef balance_metric_tuple(assign,times,k,conproc, conmax, penalty):\n    #make the list a numpy array\n    assign_np = np.array(assign)\n    ## call the balance_metric function\n    metric = balance_metric_constrained(assign_np, times, k, conproc, conmax, penalty)\n    return (metric, ) #note that we're returning a tuple\n\n#let's test this function\nbalance_metric_tuple(assign,times,k, [0], [10], 5)","output":{"0":{"data":{"text/plain":"(3058021.6666666665,)"},"exec_count":25,"output_type":"execute_result"}},"pos":52,"type":"cell"}
{"cell_type":"code","exec_count":26,"id":"a5103b","input":"import random\nfrom deap import base\nfrom deap import creator\nfrom deap import tools\nfrom functools import partial\n\ncreator.create(\"FitnessLoad\", base.Fitness, weights=(-1.0,))\ncreator.create(\"Individual\", list, fitness=creator.FitnessLoad)\ntoolbox = base.Toolbox()\ntoolbox.register(\"assignments\",create_individual,k,n)\ntoolbox.register(\"individual\", tools.initIterate, creator.Individual, toolbox.assignments)\ntoolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)\n###############################\n#NEW - this line needs additional parameters\n###############################\ntoolbox.register(\"evaluate\", balance_metric_tuple, times=times, k=k, conproc=[0], conmax=[10], penalty=5)\ntoolbox.register(\"select\", tools.selTournament, tournsize=3)\ntoolbox.register(\"mate\", tools.cxTwoPoint) \ntoolbox.register(\"mutate\", tools.mutUniformInt, low = 0, up = k-1, indpb=0.1)\nstats = tools.Statistics(key=lambda ind: ind.fitness.values)\nstats.register(\"avg\", np.mean)\nstats.register(\"std\", np.std)\nstats.register(\"min\", np.min)\nstats.register(\"max\", np.max)\n\n# define search parameters\npop_size = 200\ncrossover_prob = 0.3\nmutation_prob = 0.5\nmax_gen = 2000\nmax_no_improve = 200\n\n# get solution\nbest_balance, best_assign, log = customGA(toolbox,tools,stats, pop_size, crossover_prob, mutation_prob,\n                                     max_gen, max_no_improve)\n\nprint('Genetic Algorithm Best Result', best_balance)\nprint('Total time on each processor:', [ sum(times[np.array(best_assign)==j]) for j in range(k)])","output":{"0":{"name":"stdout","output_type":"stream","text":"Genetic Algorithm Best Result 1691209.6666666665\nTotal time on each processor: [289, 1687, 1686]\n"}},"pos":54,"type":"cell"}
{"cell_type":"code","exec_count":27,"id":"9a488b","input":"####################################\n# Setting up a new bigger problem\n####################################\nn = 1000\nk = 10\n#we're going to set some min/max times here for the jobs\nmin_time = 20\nmax_time = 200\n#randomly generate some jobs\ntimes = np.random.randint(low=min_time, high = max_time, size = n, dtype='int64')\n\n# total time on each processor\nprint('Total time on each processor, if completely balanced:', sum(times)/k)\n\nconproc = [0,1]\nconmax=[8000,8000]","output":{"0":{"name":"stdout","output_type":"stream","text":"Total time on each processor, if completely balanced: 11282.9\n"}},"pos":56,"type":"cell"}
{"cell_type":"code","exec_count":28,"id":"ff30f1","input":"#set up a dataframe for storing results \nimport pandas as pd\nr_df = pd.DataFrame({'Score': [None,None,None,None,None,None,None,None,None,None,None,None,None],\n                     'Constrained Score': [None,None,None,None,None,None,None,None,None,None,None,None,None],\n                      'Time on Processor': [None,None,None,None,None,None,None,None,None,None,None,None,None],\n                    'Over Constraints': [None,None,None,None,None,None,None,None,None,None,None,None,None]}, \n                     index=['Baseline', 'HC-Local Search', 'HC-Custom Annealing',\n                            'HC-Simanneal','SC-Simanneal-5', 'SC-Simanneal-50', 'SC-Simanneal-500',\n                           'SC-GA-5', 'SC-GA-50', 'SC-GA-500', 'SC-GA-5-FStart', 'SC-GA-50-FStart', 'SC-GA-500-FStart'])\n\n\npd.set_option('display.float_format', '{:.2f}'.format)\npd.set_option('max_colwidth', 200)\n#create a function for updating the grid\ndef updateResults(df,score,c_score,time,approach,assign,conproc,conmax):\n    over_max = True in [sum(times[assign==c]) > conmax[c] for c in conproc]\n    df.loc[approach, 'Score'] = score\n    df.loc[approach, 'Constrained Score'] = c_score\n    df.loc[approach, 'Time on Processor'] = time\n    df.loc[approach, 'Over Constraints'] = over_max\n    return(df)\nr_df    ","output":{"0":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Score</th>\n      <th>Constrained Score</th>\n      <th>Time on Processor</th>\n      <th>Over Constraints</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Baseline</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>HC-Local Search</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>HC-Custom Annealing</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>HC-Simanneal</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>SC-Simanneal-5</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>SC-Simanneal-50</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>SC-Simanneal-500</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>SC-GA-5</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>SC-GA-50</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>SC-GA-500</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>SC-GA-5-FStart</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>SC-GA-50-FStart</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>SC-GA-500-FStart</th>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n      <td>None</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"                    Score Constrained Score Time on Processor Over Constraints\nBaseline             None              None              None             None\nHC-Local Search      None              None              None             None\nHC-Custom Annealing  None              None              None             None\nHC-Simanneal         None              None              None             None\nSC-Simanneal-5       None              None              None             None\nSC-Simanneal-50      None              None              None             None\nSC-Simanneal-500     None              None              None             None\nSC-GA-5              None              None              None             None\nSC-GA-50             None              None              None             None\nSC-GA-500            None              None              None             None\nSC-GA-5-FStart       None              None              None             None\nSC-GA-50-FStart      None              None              None             None\nSC-GA-500-FStart     None              None              None             None"},"exec_count":28,"output_type":"execute_result"}},"pos":58,"type":"cell"}
{"cell_type":"code","exec_count":29,"id":"caafce","input":"# constrained objective function = total squared deviation of times from balanced times, accounting for constraints\ndef get_c_metric(assign,times,k,conproc,conmax):\n    #get the total time\n    total = sum(times)\n    #get the total that should be balanced\n    balance_target = ((total-sum(conmax))/(k-len(conproc)))\n    #get the unconstrained processors\n    uncon = np.delete(np.array(range(k)), np.array(conproc))\n    #sum the unconstrained processor deviation\n    dev_uncon = sum( (sum(times[assign==j])-balance_target)**2 for j in uncon )\n    #sum the absolute difference on constrained processors\n    dev_cons = sum( (sum(times[assign==j])-conmax[j])**2 for j in conproc )\n    return dev_uncon + dev_cons\n\n\n#get the baseline\nassign = np.random.randint(low=0,high=k,size=n)\ntime_on_proc = [ sum(times[assign==j]) for j in range(k)]\nbaseline = balance_metric(assign,times,k)\nprint('Baseline with random assignments:', baseline)\nc_metric = get_c_metric(assign,times,k,conproc,conmax)\nprint('Baseline constrained metric', c_metric)\n\nr_df = updateResults(r_df,baseline,c_metric,time_on_proc,'Baseline', assign, conproc, conmax)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Baseline with random assignments: 5143156.899999999\nBaseline constrained metric 39721121.875\n"}},"pos":60,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"127901","input":"# define a move function which changes one processor assignment randomly\ndef reassign_one(assign,k):\n    n = len(assign)\n    # choose a job and a new processor assignment\n    which_job = np.random.randint(0,n,1)[0]\n    which_proc = np.random.randint(0,k,1)[0]\n    new_assign = assign.copy()\n    new_assign[which_job] = which_proc\n    return new_assign\n","pos":6,"type":"cell"}
{"cell_type":"code","exec_count":30,"id":"ffa9fa","input":"#### Greedy Local Search #####\n#####################\n#Parameters\nmax_no_improve = 5000\n#####################\nbest_assign, best_f, num_iter, converge = load_balance_local_feasible(times,k,max_no_improve,conproc,conmax)\nprint('Greedy Local Search best result:', best_f)\nprint('The algorithm found a solution that met the criteria:', converged)\nprint('Total time on each processor:', [ sum(times[best_assign==j]) for j in range(k)])\nc_metric = get_c_metric(best_assign,times,k,conproc,conmax)\nprint('Constrained metric', c_metric)\n\nr_df = updateResults(r_df,best_f,c_metric,[ sum(times[best_assign==j]) for j in range(k)],'HC-Local Search',best_assign,conproc,conmax)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Greedy Local Search best result: 27050792.900000002\nThe algorithm found a solution that met the criteria: True\nTotal time on each processor: [8000, 7987, 12109, 12113, 12093, 12107, 12100, 12100, 12110, 12110]\nConstrained metric 517.625\n"}},"pos":62,"type":"cell"}
{"cell_type":"code","exec_count":31,"id":"4ad9a2","input":"#### Custom Simulated Annealing ####\n#####################\n#Parameters\nmax_no_improve = 1000\ntemp = 500 \nalpha = .99\n#####################\n\n\nbest_x, best_f, iterations, trajectory, trajectory_best, converge = custom_simanneal(times, k, max_no_improve, temp, alpha, conproc, conmax)\nprint('Custom Simulated Annealing best result:', best_f)\nprint('The algorithm found a solution that met the criteria:', converged)\nprint('Total time on each processor:', [ sum(times[best_x==j]) for j in range(k)])\nc_metric = get_c_metric(best_x,times,k,conproc,conmax)\nprint('Constrained metric', c_metric)\nr_df = updateResults(r_df,best_f,c_metric,[ sum(times[best_x==j]) for j in range(k)],'HC-Custom Annealing',best_x,conproc,conmax)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Custom Simulated Annealing best result: 39844248.9\nThe algorithm found a solution that met the criteria: True\nTotal time on each processor: [7866, 7909, 12927, 13944, 11136, 11193, 12832, 12770, 10051, 12201]\nConstrained metric 11054036.625\n"}},"pos":64,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":32,"id":"42a5c5","input":"#### Simanneal Package ####\n#####################\n#Parameters\nwait_time = .2\n#####################\n\nunconstrained = [x for x in list(range(k)) if x not in conproc]\nassign = np.random.choice(unconstrained,size=n,replace=True)\nld = loadProblemHC(assign, times, k, conproc, conmax)\nld.set_schedule(ld.auto(minutes=wait_time)) \nld.copy_strategy = \"deepcopy\" \nbest_assign, best_score = ld.anneal()\nprint('Simanneal Package best result', best_score)\nprint('Total time on each processor:', [ sum(times[best_assign==j]) for j in range(k)])\nc_metric = get_c_metric(best_assign,times,k,conproc,conmax)\nprint('Constrained metric', c_metric)\nr_df = updateResults(r_df,best_score,c_metric,[ sum(times[best_assign==j]) for j in range(k)],'HC-Simanneal',best_assign,conproc,conmax)\n","output":{"0":{"name":"stderr","output_type":"stream","text":" Temperature        Energy    Accept   Improve     Elapsed   Remaining\n    39.00000   27100358.90    28.90%     0.00%     0:00:28    -1:59:4960 Temperature        Energy    Accept   Improve     Elapsed   Remaining\n    39.00000   27001600.90    31.71%     0.00%     0:00:12     0:00:000 "},"1":{"name":"stdout","output_type":"stream","text":"Simanneal Package best result 27001554.900000006\nTotal time on each processor: [7998, 7995, 12102, 12102, 12111, 12094, 12114, 12112, 12092, 12109]\nConstrained metric 523.125\n"}},"pos":66,"type":"cell"}
{"cell_type":"code","exec_count":33,"id":"c2fb20","input":"#return to random assignments\nassign = np.random.randint(low=0,high=k,size=n)\n#initialize the class\nld = loadProblemSC(assign, times, k, conproc, conmax, 5) #penalty 5\nld.set_schedule(ld.auto(minutes=.2)) #set approximate time to find results\n\n# since our state is a numpy array, we need deepcopy\nld.copy_strategy = \"deepcopy\" \n#this is what kicks it off\nbest_assign, best_score = ld.anneal()\n\nprint('Total time on each processor:', [ sum(times[best_assign==j]) for j in range(k)])\nprint('The best score is:', best_score) \nc_metric = get_c_metric(best_assign,times,k,conproc,conmax)\nprint('Constrained metric', c_metric)\nr_df = updateResults(r_df,best_score,c_metric,[ sum(times[best_assign==j]) for j in range(k)],'SC-Simanneal-5',best_assign,conproc,conmax)\n","output":{"0":{"name":"stderr","output_type":"stream","text":" Temperature        Energy    Accept   Improve     Elapsed   Remaining\n     1.30000     215556.02     9.20%     0.00%     0:00:33    -1:59:45 Temperature        Energy    Accept   Improve     Elapsed   Remaining\n     1.30000     215568.74     9.41%     0.00%     0:00:12     0:00:00"},"1":{"name":"stdout","output_type":"stream","text":"Total time on each processor: [8656, 8649, 11937, 11954, 11935, 11948, 11937, 11944, 11933, 11936]\nThe best score is: 215556.01899999997\nConstrained metric 1064797.125\n"}},"pos":68,"type":"cell"}
{"cell_type":"code","exec_count":34,"id":"66fc49","input":"#return to random assignments\nassign = np.random.randint(low=0,high=k,size=n)\n#initialize the class\nld = loadProblemSC(assign, times, k, conproc, conmax, 50) #penalty 50\nld.set_schedule(ld.auto(minutes=.2)) #set approximate time to find results\n\n# since our state is a numpy array, we need deepcopy\nld.copy_strategy = \"deepcopy\" \n#this is what kicks it off\nbest_assign, best_score = ld.anneal()\n\nprint('Total time on each processor:', [ sum(times[best_assign==j]) for j in range(k)])\nprint('The best score is:', best_score) \nc_metric = get_c_metric(best_assign,times,k,conproc,conmax)\nprint('Constrained metric', c_metric)\nr_df = updateResults(r_df,best_score,c_metric,[ sum(times[best_assign==j]) for j in range(k)],'SC-Simanneal-50',best_assign,conproc,conmax)\n","output":{"0":{"name":"stderr","output_type":"stream","text":" Temperature        Energy    Accept   Improve     Elapsed   Remaining\n     0.73000     262891.15    10.90%     0.00%     0:00:38    -1:59:405 Temperature        Energy    Accept   Improve     Elapsed   Remaining\n     0.73000     262920.43    10.29%     0.29%     0:00:12     0:00:002"},"1":{"name":"stdout","output_type":"stream","text":"Total time on each processor: [8083, 8086, 12084, 12091, 12086, 12076, 12077, 12080, 12071, 12095]\nThe best score is: 262891.149\nConstrained metric 18309.125\n"}},"pos":70,"type":"cell"}
{"cell_type":"code","exec_count":35,"id":"7be9d0","input":"#return to random assignments\nassign = np.random.randint(low=0,high=k,size=n)\n#initialize the class\nld = loadProblemSC(assign, times, k, conproc, conmax, 500) #penalty 500\nld.set_schedule(ld.auto(minutes=.2)) #set approximate time to find results\n\n# since our state is a numpy array, we need deepcopy\nld.copy_strategy = \"deepcopy\" \n#this is what kicks it off\nbest_assign, best_score = ld.anneal()\n\nprint('Total time on each processor:', [ sum(times[best_assign==j]) for j in range(k)])\nprint('The best score is:', best_score) \nc_metric = get_c_metric(best_assign,times,k,conproc,conmax)\nprint('Constrained metric', c_metric)\nr_df = updateResults(r_df,best_score,c_metric,[ sum(times[best_assign==j]) for j in range(k)],'SC-Simanneal-500',best_assign,conproc,conmax)\n","output":{"0":{"name":"stderr","output_type":"stream","text":" Temperature        Energy    Accept   Improve     Elapsed   Remaining\n     0.33000     269110.31     9.70%     0.00%     0:00:45    -1:59:339 Temperature        Energy    Accept   Improve     Elapsed   Remaining\n     0.33000     269258.09    10.00%     0.00%     0:00:13     0:00:000"},"1":{"name":"stdout","output_type":"stream","text":"Total time on each processor: [8000, 8007, 12112, 12094, 12100, 12114, 12104, 12102, 12099, 12097]\nThe best score is: 269110.30900000007\nConstrained metric 400.625\n"}},"pos":72,"type":"cell"}
{"cell_type":"code","exec_count":36,"id":"ee1b1d","input":"#### DEAP Genetic Algorithm ####\n####################\n#Parameters\npop_size = 200\ncrossover_prob = 0.5\nmutation_prob = 0.5\nmax_gen = 3000\nmax_no_improve = 500\n#####################\n\n\n###################################\n# Leave everything below here alone\n###################################\n\n# how we create our individuals\ndef create_individual(k,n):\n    current_x = np.random.randint(low=0,high=k,size=n)\n    return current_x.tolist() #this converts our np array back to a list\n\n# objective function = total squared deviation of times from balanced times\ndef balance_metric_tuple(assign,times,k,conproc, conmax, penalty):\n    #make the list a numpy array\n    assign_np = np.array(assign)\n    ## call the balance_metric function\n    metric = balance_metric_constrained(assign_np, times, k, conproc, conmax, penalty)\n    return (metric, ) #note that we're returning a tuple\n# delete references to classes to avoid warning\ndel creator.FitnessLoad\ndel creator.Individual\ncreator.create(\"FitnessLoad\", base.Fitness, weights=(-1.0,))\ncreator.create(\"Individual\", list, fitness=creator.FitnessLoad)\ntoolbox = base.Toolbox()\ntoolbox.register(\"assignments\",create_individual,k,n)\ntoolbox.register(\"individual\", tools.initIterate, creator.Individual, toolbox.assignments)\ntoolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)\ntoolbox.register(\"evaluate\", balance_metric_tuple, times=times, k=k, conproc=conproc,conmax=conmax,penalty=5)\ntoolbox.register(\"select\", tools.selTournament, tournsize=3)\ntoolbox.register(\"mate\", tools.cxTwoPoint) \ntoolbox.register(\"mutate\", tools.mutUniformInt, low = 0, up = k-1, indpb=0.1)\nstats = tools.Statistics(key=lambda ind: ind.fitness.values)\nstats.register(\"avg\", np.mean)\nstats.register(\"std\", np.std)\nstats.register(\"min\", np.min)\nstats.register(\"max\", np.max)\n\n# get solution\nbest_balance, best_assign, log = customGA(toolbox,tools,stats, pop_size, crossover_prob, mutation_prob,\n                                     max_gen, max_no_improve)\n\nprint('Genetic Algorithm Best Result', best_balance)\n\nprint('Total time on each processor:', [ sum(times[np.array(best_assign)==j]) for j in range(k)])\nc_metric = get_c_metric(np.array(best_assign),times,k,conproc,conmax)\nprint('Constrained metric', c_metric)\nr_df = updateResults(r_df,best_balance,c_metric,[ sum(times[np.array(best_assign)==j]) for j in range(k)],'SC-GA-5',np.array(best_assign),conproc,conmax)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Genetic Algorithm Best Result 21557311.9\nTotal time on each processor: [8644, 8661, 11928, 11930, 11960, 11927, 11951, 11926, 11952, 11950]\nConstrained metric 1065907.125\n"}},"pos":74,"type":"cell"}
{"cell_type":"code","exec_count":37,"id":"8add92","input":"toolbox.unregister(\"evaluate\")\ntoolbox.register(\"evaluate\", balance_metric_tuple, times=times, k=k, conproc=conproc,conmax=conmax,penalty=50)\n\n# get solution\nbest_balance, best_assign, log = customGA(toolbox,tools,stats, pop_size, crossover_prob, mutation_prob,\n                                     max_gen, max_no_improve)\n\nprint('Genetic Algorithm Best Result', best_balance)\nprint('Total time on each processor:', [ sum(times[np.array(best_assign)==j]) for j in range(k)])\nc_metric = get_c_metric(np.array(best_assign),times,k,conproc,conmax)\nprint('Constrained metric', c_metric)\nr_df = updateResults(r_df,best_balance,c_metric,[ sum(times[np.array(best_assign)==j]) for j in range(k)],'SC-GA-50',np.array(best_assign),conproc,conmax)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Genetic Algorithm Best Result 26297626.900000006\nTotal time on each processor: [8090, 8089, 12083, 12103, 12064, 12056, 12077, 12072, 12101, 12094]\nConstrained metric 22093.625\n"}},"pos":76,"type":"cell"}
{"cell_type":"code","exec_count":38,"id":"0aa479","input":"toolbox.unregister(\"evaluate\")\ntoolbox.register(\"evaluate\", balance_metric_tuple, times=times, k=k, conproc=conproc,conmax=conmax,penalty=500)\n\n# get solution\nbest_balance, best_assign, log = customGA(toolbox,tools,stats, pop_size, crossover_prob, mutation_prob,\n                                     max_gen, max_no_improve)\n\nprint('Genetic Algorithm Best Result', best_balance)\nprint('Total time on each processor:', [ sum(times[np.array(best_assign)==j]) for j in range(k)])\nc_metric = get_c_metric(np.array(best_assign),times,k,conproc,conmax)\nprint('Constrained metric', c_metric)\nr_df = updateResults(r_df,best_balance,c_metric,[ sum(times[np.array(best_assign)==j]) for j in range(k)],'SC-GA-500',np.array(best_assign),conproc,conmax)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Genetic Algorithm Best Result 27743348.9\nTotal time on each processor: [8041, 8017, 12058, 12371, 12264, 12115, 12172, 11906, 11726, 12159]\nConstrained metric 290788.375\n"}},"pos":78,"type":"cell"}
{"cell_type":"code","exec_count":39,"id":"5f0298","input":"# how we create our individuals\ndef create_individual(k,n,conproc):\n    unconstrained = [x for x in list(range(k)) if x not in conproc]\n    current_x = np.random.choice(unconstrained,size=n,replace=True)\n    return current_x.tolist() #this converts our np array back to a list\n\ndel creator.Individual\ncreator.create(\"Individual\", list, fitness=creator.FitnessLoad)\ntoolbox.unregister(\"assignments\")\ntoolbox.register(\"assignments\",create_individual,k,n,conproc)\n\ntoolbox.unregister(\"evaluate\")\ntoolbox.register(\"evaluate\", balance_metric_tuple, times=times, k=k, conproc=conproc,conmax=conmax,penalty=5)\n\n# get solution\nbest_balance, best_assign, log = customGA(toolbox,tools,stats, pop_size, crossover_prob, mutation_prob,\n                                     max_gen, max_no_improve)\n\nprint('Genetic Algorithm Best Result', best_balance)\nprint('Total time on each processor:', [ sum(times[np.array(best_assign)==j]) for j in range(k)])\nc_metric = get_c_metric(np.array(best_assign),times,k,conproc,conmax)\nprint('Constrained metric', c_metric)\nr_df = updateResults(r_df,best_balance,c_metric,[ sum(times[np.array(best_assign)==j]) for j in range(k)],'SC-GA-5-FStart',np.array(best_assign),conproc,conmax)\n\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Genetic Algorithm Best Result 21560589.9\nTotal time on each processor: [8652, 8671, 11930, 11941, 11943, 11976, 11970, 11903, 11923, 11920]\nConstrained metric 1098475.625\n"}},"pos":80,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"173e6e","input":"# define a move function which changes one processor assignment randomly\ndef reassign_one_constrained(assign,k,conproc, conmax):\n    #get the reassignment\n    new_assign = reassign_one(assign, k)\n    ###################\n    # NEW - Evaluate if the new assignments meet our constraint\n    over_max = True in [sum(times[new_assign==c]) > conmax[c] for c in conproc]\n    # Only return a new assignment if it meets our constraints\n    #uncomment this line to see total time on processor\n    #print('Total time on each processor (inside function):', [ sum(times[new_assign==j]) for j in range(k)])\n    if over_max == False:\n        #print('Not over max') #uncomment this line to see if it passed\n        return new_assign\n    else:\n        #print('Over max') #uncomment this line to see if it failed\n        return assign\n","pos":8,"type":"cell"}
{"cell_type":"code","exec_count":40,"id":"f3e60a","input":"toolbox.unregister(\"evaluate\")\ntoolbox.register(\"evaluate\", balance_metric_tuple, times=times, k=k, conproc=conproc,conmax=conmax,penalty=50)\n\n# get solution\nbest_balance, best_assign, log = customGA(toolbox,tools,stats, pop_size, crossover_prob, mutation_prob,\n                                     max_gen, max_no_improve)\n\nprint('Genetic Algorithm Best Result', best_balance)\nprint('Total time on each processor:', [ sum(times[np.array(best_assign)==j]) for j in range(k)])\nc_metric = get_c_metric(np.array(best_assign),times,k,conproc,conmax)\nprint('Constrained metric', c_metric)\nr_df = updateResults(r_df,best_balance,c_metric,[ sum(times[np.array(best_assign)==j]) for j in range(k)],'SC-GA-50-FStart',np.array(best_assign),conproc,conmax)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Genetic Algorithm Best Result 26439400.900000006\nTotal time on each processor: [8089, 8098, 12182, 12282, 12032, 11989, 12080, 12222, 11883, 11972]\nConstrained metric 154325.625\n"}},"pos":82,"type":"cell"}
{"cell_type":"code","exec_count":41,"id":"1829c9","input":"toolbox.unregister(\"evaluate\")\ntoolbox.register(\"evaluate\", balance_metric_tuple, times=times, k=k, conproc=conproc,conmax=conmax,penalty=500)\n\n# get solution\nbest_balance, best_assign, log = customGA(toolbox,tools,stats, pop_size, crossover_prob, mutation_prob,\n                                     max_gen, max_no_improve)\n\nprint('Genetic Algorithm Best Result', best_balance)\nprint('Total time on each processor:', [ sum(times[np.array(best_assign)==j]) for j in range(k)])\nc_metric = get_c_metric(np.array(best_assign),times,k,conproc,conmax)\nprint('Constrained metric', c_metric)\nr_df = updateResults(r_df,best_balance,c_metric,[ sum(times[np.array(best_assign)==j]) for j in range(k)],'SC-GA-500-FStart',np.array(best_assign),conproc,conmax)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Genetic Algorithm Best Result 27398408.900000006\nTotal time on each processor: [8019, 7995, 12013, 11713, 12084, 11836, 12283, 12388, 12230, 12268]\nConstrained metric 389229.375\n"}},"pos":84,"type":"cell"}
{"cell_type":"code","exec_count":42,"id":"b45045","input":"r_df.sort_values(by=['Constrained Score'])","output":{"0":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Score</th>\n      <th>Constrained Score</th>\n      <th>Time on Processor</th>\n      <th>Over Constraints</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>SC-Simanneal-500</th>\n      <td>269110.31</td>\n      <td>400.62</td>\n      <td>[8000, 8007, 12112, 12094, 12100, 12114, 12104, 12102, 12099, 12097]</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>HC-Local Search</th>\n      <td>27050792.90</td>\n      <td>517.62</td>\n      <td>[8000, 7987, 12109, 12113, 12093, 12107, 12100, 12100, 12110, 12110]</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>HC-Simanneal</th>\n      <td>27001554.90</td>\n      <td>523.12</td>\n      <td>[7998, 7995, 12102, 12102, 12111, 12094, 12114, 12112, 12092, 12109]</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>SC-Simanneal-50</th>\n      <td>262891.15</td>\n      <td>18309.12</td>\n      <td>[8083, 8086, 12084, 12091, 12086, 12076, 12077, 12080, 12071, 12095]</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>SC-GA-50</th>\n      <td>26297626.90</td>\n      <td>22093.62</td>\n      <td>[8090, 8089, 12083, 12103, 12064, 12056, 12077, 12072, 12101, 12094]</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>SC-GA-50-FStart</th>\n      <td>26439400.90</td>\n      <td>154325.62</td>\n      <td>[8089, 8098, 12182, 12282, 12032, 11989, 12080, 12222, 11883, 11972]</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>SC-GA-500</th>\n      <td>27743348.90</td>\n      <td>290788.38</td>\n      <td>[8041, 8017, 12058, 12371, 12264, 12115, 12172, 11906, 11726, 12159]</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>SC-GA-500-FStart</th>\n      <td>27398408.90</td>\n      <td>389229.38</td>\n      <td>[8019, 7995, 12013, 11713, 12084, 11836, 12283, 12388, 12230, 12268]</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>SC-Simanneal-5</th>\n      <td>215556.02</td>\n      <td>1064797.12</td>\n      <td>[8656, 8649, 11937, 11954, 11935, 11948, 11937, 11944, 11933, 11936]</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>SC-GA-5</th>\n      <td>21557311.90</td>\n      <td>1065907.12</td>\n      <td>[8644, 8661, 11928, 11930, 11960, 11927, 11951, 11926, 11952, 11950]</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>SC-GA-5-FStart</th>\n      <td>21560589.90</td>\n      <td>1098475.62</td>\n      <td>[8652, 8671, 11930, 11941, 11943, 11976, 11970, 11903, 11923, 11920]</td>\n      <td>True</td>\n    </tr>\n    <tr>\n      <th>HC-Custom Annealing</th>\n      <td>39844248.90</td>\n      <td>11054036.62</td>\n      <td>[7866, 7909, 12927, 13944, 11136, 11193, 12832, 12770, 10051, 12201]</td>\n      <td>False</td>\n    </tr>\n    <tr>\n      <th>Baseline</th>\n      <td>5143156.90</td>\n      <td>39721121.88</td>\n      <td>[12725, 10771, 10092, 12104, 11441, 11464, 11533, 10978, 10597, 11124]</td>\n      <td>True</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"                          Score Constrained Score  \\\nSC-Simanneal-500      269110.31            400.62   \nHC-Local Search     27050792.90            517.62   \nHC-Simanneal        27001554.90            523.12   \nSC-Simanneal-50       262891.15          18309.12   \nSC-GA-50            26297626.90          22093.62   \nSC-GA-50-FStart     26439400.90         154325.62   \nSC-GA-500           27743348.90         290788.38   \nSC-GA-500-FStart    27398408.90         389229.38   \nSC-Simanneal-5        215556.02        1064797.12   \nSC-GA-5             21557311.90        1065907.12   \nSC-GA-5-FStart      21560589.90        1098475.62   \nHC-Custom Annealing 39844248.90       11054036.62   \nBaseline             5143156.90       39721121.88   \n\n                                                                          Time on Processor  \\\nSC-Simanneal-500       [8000, 8007, 12112, 12094, 12100, 12114, 12104, 12102, 12099, 12097]   \nHC-Local Search        [8000, 7987, 12109, 12113, 12093, 12107, 12100, 12100, 12110, 12110]   \nHC-Simanneal           [7998, 7995, 12102, 12102, 12111, 12094, 12114, 12112, 12092, 12109]   \nSC-Simanneal-50        [8083, 8086, 12084, 12091, 12086, 12076, 12077, 12080, 12071, 12095]   \nSC-GA-50               [8090, 8089, 12083, 12103, 12064, 12056, 12077, 12072, 12101, 12094]   \nSC-GA-50-FStart        [8089, 8098, 12182, 12282, 12032, 11989, 12080, 12222, 11883, 11972]   \nSC-GA-500              [8041, 8017, 12058, 12371, 12264, 12115, 12172, 11906, 11726, 12159]   \nSC-GA-500-FStart       [8019, 7995, 12013, 11713, 12084, 11836, 12283, 12388, 12230, 12268]   \nSC-Simanneal-5         [8656, 8649, 11937, 11954, 11935, 11948, 11937, 11944, 11933, 11936]   \nSC-GA-5                [8644, 8661, 11928, 11930, 11960, 11927, 11951, 11926, 11952, 11950]   \nSC-GA-5-FStart         [8652, 8671, 11930, 11941, 11943, 11976, 11970, 11903, 11923, 11920]   \nHC-Custom Annealing    [7866, 7909, 12927, 13944, 11136, 11193, 12832, 12770, 10051, 12201]   \nBaseline             [12725, 10771, 10092, 12104, 11441, 11464, 11533, 10978, 10597, 11124]   \n\n                    Over Constraints  \nSC-Simanneal-500                True  \nHC-Local Search                False  \nHC-Simanneal                   False  \nSC-Simanneal-50                 True  \nSC-GA-50                        True  \nSC-GA-50-FStart                 True  \nSC-GA-500                       True  \nSC-GA-500-FStart                True  \nSC-Simanneal-5                  True  \nSC-GA-5                         True  \nSC-GA-5-FStart                  True  \nHC-Custom Annealing            False  \nBaseline                        True  "},"exec_count":42,"output_type":"execute_result"}},"pos":86,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"385aef","input":"k = 3\ntimes = np.array([2,4,6,2,4,6,2,4,6])\nassign=np.array([0,0,0,1,1,1,2,2,2])\n\n# total time on each processor ... should be the same\nprint('Total time on each processor (going in):', [ sum(times[assign==j]) for j in range(k)])\n#reassign one, with processor 0 constrained to 10\nnew_assign = reassign_one_constrained(assign,k, [0], [10])\nprint('Processor 0 Constrained to 10:', new_assign)\nprint('Total time on each processor (coming out):', [ sum(times[new_assign==j]) for j in range(k)])","output":{"0":{"name":"stdout","output_type":"stream","text":"Total time on each processor (going in): [12, 12, 12]\nProcessor 0 Constrained to 10: [0 0 0 1 1 1 2 2 2]\nTotal time on each processor (coming out): [12, 12, 12]\n"}},"pos":10,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"cbafb1","input":"# local search function\ndef load_balance_local_loop_constraint(times, k, max_no_improve,conproc,conmax):\n    n = len(times)\n    # starts from a random assignment to k processors\n    current_x = np.random.randint(low=0,high=k,size=n)\n    current_f = balance_metric(current_x, times, k)\n    best_x = current_x\n    best_f = current_f\n    ##########################\n    # New - track convergence\n    converged = False\n    ##########################\n    # stop search if no better x is found within max_no_improve iterations\n    num_moves_no_improve = 0\n    iterations = 0\n    while (num_moves_no_improve < max_no_improve):\n        num_moves_no_improve += 1\n        iterations += 1  # just for tracking\n        #this is the same as before - using our original reassign_one function\n        new_x = reassign_one(current_x,k)\n        ##########################################################\n        # NEW - Evaluate if the new assignments meet our constraint\n        over_max = True in [sum(times[new_x==c]) > conmax[c] for c in conproc] \n        ##################################\n        new_f = balance_metric(new_x, times, k)\n        ####################################\n        #NEW - check both that the new value is less than the old and that we are within our constraints\n        if new_f < current_f and over_max == False:\n            #################################\n            #NEW - track if we ever accept a solution\n            converged = True\n            #################################      \n            num_moves_no_improve = 0\n            current_x = new_x\n            current_f = new_f\n            if current_f < best_f:  \n                best_x = current_x  \n                best_f = current_f\n    return best_x, best_f, iterations, converged","pos":12,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"0073d3","input":"# local search function\ndef load_balance_local_function_constraint(times, k, max_no_improve,conproc,conmax):\n    n = len(times)\n    # starts from a random assignment to k processors\n    current_x = np.random.randint(low=0,high=k,size=n)\n    current_f = balance_metric(current_x, times, k)\n    best_x = current_x\n    best_f = current_f\n    ##########################\n    # New - track convergence\n    converged = False\n    ##########################\n    # stop search if no better x is found within max_no_improve iterations\n    num_moves_no_improve = 0\n    iterations = 0\n    while (num_moves_no_improve < max_no_improve):\n        num_moves_no_improve += 1\n        iterations += 1  # just for tracking\n        ##################################\n        # NEW - pass the extra parameters to reassign_one\n        new_x = reassign_one_constrained(current_x,k,conproc,conmax)\n        ##################################\n        new_f = balance_metric(new_x, times, k)\n        if new_f < current_f:\n            #################################\n            #NEW - track if we ever accept a solution\n            converged = True\n            #################################      \n            num_moves_no_improve = 0\n            current_x = new_x\n            current_f = new_f\n            if current_f < best_f:  \n                best_x = current_x  \n                best_f = current_f\n    return best_x, best_f, iterations, converged","pos":14,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"dd2294","input":"# generate random job times\nnp.random.seed(666) #comment this out to play with new numbers\n#we'll start with 20 execution times\nn = 30\n#we'll start with 2 processors\nk = 3\nmin_time = 20\nmax_time = 200\ntimes = np.random.randint(low=min_time, high = max_time, size = n)\nassign = np.random.randint(low=0,high=k,size=n)\n# total time on each processor\nprint('Total time on each processor, if completely balanced:', sum(times)/k)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"Total time on each processor, if completely balanced: 1220.6666666666667\n"}},"pos":16,"type":"cell"}
{"cell_type":"code","exec_count":9,"id":"bff6c2","input":"#####################\n# NEW: adding our 2 additional parameters to the function and one additional return variable\n#####################\nprint('Using the Constraint Directly in the Loop')\nbest_assign, best_f, num_iter, converged = load_balance_local_loop_constraint(times,k,5000,[0],[1100]) \nprint('The algorithm found a solution that met the criteria:', converged)\nprint('The best assignment is', best_assign)\nprint('Total time on each processor:', [ sum(times[best_assign==j]) for j in range(k)])\nprint('The deviation from balance is', best_f)\nprint('It took', num_iter, 'iterations.')\nprint('------------------------------------------')\n\nprint('Using the Constraint in the Function')\nbest_assign, best_f, num_iter, converged = load_balance_local_function_constraint(times,k,5000,[0],[1100]) \nprint('The algorithm found a solution that met the criteria:', converged)\nprint('The best assignment is', best_assign)\nprint('Total time on each processor:', [ sum(times[best_assign==j]) for j in range(k)])\nprint('The deviation from balance is', best_f)\nprint('It took', num_iter, 'iterations.')","output":{"0":{"name":"stdout","output_type":"stream","text":"Using the Constraint Directly in the Loop\nThe algorithm found a solution that met the criteria: False\nThe best assignment is [2 0 0 2 0 0 1 1 1 1 1 1 0 0 0 2 1 2 1 0 0 1 2 0 0 2 1 1 2 2]\nTotal time on each processor: [1353, 1373, 936]\nThe deviation from balance is 121752.66666666666\nIt took 5000 iterations.\n------------------------------------------\nUsing the Constraint in the Function\nThe algorithm found a solution that met the criteria: True\nThe best assignment is [2 1 2 0 0 1 1 2 1 1 2 0 2 2 0 1 2 0 0 0 1 1 1 0 0 2 2 1 1 0]\nTotal time on each processor: [1077, 1306, 1279]\nThe deviation from balance is 31324.666666666668\nIt took 5022 iterations.\n"}},"pos":18,"type":"cell"}
{"cell_type":"markdown","id":"110328","input":"### Greedy Local Search - Hard Constraint  In the Move Function\n\nNext, let's implement the hard constraint directly in our move function (reassign_one_constrained). \n\nAgain, to use that, we need our two additional parameters, so we'll update our load_balance_local function to take in 2 additional parameters:\n\n* conproc - a list of the processors to constrain\n* conmax - a list of the max times on each processor.\n\nWe'll again track whether the algorithm ever finds a solution that meets the constraints. \n","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"14b8e3","input":"### The simanneal Package - Hard Constraints - No External Functions\nWe can also use a hard constraint with the simanneal package. Let's see what it looks like if don't use external functions. To do this, you add your code within the package's move and energy functions. To use a hard constraint in simanneal, you'd enforce the constraint in the **move** function, just like we did with our hand-coding. \n\nWe again need our two extra variables:\n* conproc - a list of the processors to constrain\n* conmax - a list of the max times on each processor.\n\nBut this time we'll pass them into the initialization function of the simanneal package.\n\nTo start with a feasible solution, we'll need to generate it outside the package and pass in the initial assignment.\n\nLet's see what that looks like.\n\n","pos":27,"type":"cell"}
{"cell_type":"markdown","id":"1a17d6","input":"Let's create a pandas dataframe for storing our results. We'll update this after each algorithm and at the end we can sort and compare to see which algorithm performed the best.","pos":57,"type":"cell"}
{"cell_type":"markdown","id":"21626e","input":"The only other thing we'll need to change is how we set up our evaluate function. Most of this code is identical to what you've seen before. Note the one changed line","pos":53,"type":"cell"}
{"cell_type":"markdown","id":"231794","input":"### DEAP Genetic Algorithm - Penalty 5\nDEAP has a lot of parameters to tweak. Try tweaking some of the following to see if you can get a better result.\n\n* pop_size = 200\n* crossover_prob = 0.3\n* mutation_prob = 0.5\n* max_gen = 2000\n* max_no_improve = 200\n\n(*Note*: we need to repeat a lot of code when we're changing the problem space with DEAP. DEAP hard-codes the k and n in our functions when we set it up, so we need to essentially start from scratch. We've included all the necessary code without comments in the cell below.) \n\n**Warning**: This code will be slow to run.","pos":73,"type":"cell"}
{"cell_type":"markdown","id":"24b8b6","input":"### Custom Simulated Annealing - Hard Constraint\nFor our custom simulated annealing, we can tweak the following parameters:\n* max_no_improve = 1000\n* temp = 500\n* alpha = .99 \n\nTry tweaking these parameters to see if you can get a better result","pos":63,"type":"cell"}
{"cell_type":"markdown","id":"27bce3","input":"Let's see what the constrained move function looks like with a simple problem. We'll create some sample data, and run the reassign_one_constrained() function, constraining processor 0 to a total processing time of 10. You can uncomment the print statements in the function to see what's happening inside the function, or you can just compare what goes in with what comes out below. Note that if we start with more than 10 on constrained processor (0), we'll still end up with more than 10 on it if our reassignment doesn't \"fix\" it.\n","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"2861d1","input":"### DEAP Genetic Algorithm - Penalty 50\nTo update just the penalty, we can unregister and register the evaluate function.\n\n**Warning**: This code will be slow to run.","pos":75,"type":"cell"}
{"cell_type":"markdown","id":"2e118b","input":"Let's generate some more test data and run our soft constraint version of simanneal.","pos":45,"type":"cell"}
{"cell_type":"markdown","id":"2ef6aa","input":"## Genetic Algorithm with DEAP - Soft Constraints\n\nAgain with DEAP we'll do a soft constraint in our energy function. This requires a few small, but important changes. First, the things that stay the same. \n* Our create_individual() function\n* Our custom_ga() function\n\nNeither of these change at all and we can just copy/paste the code from the load balance without constraints example.","pos":49,"type":"cell"}
{"cell_type":"markdown","id":"35f819","input":"# Load Balancing With Contraints Example\n\n**Note: Make sure you've already read Part 1, in which we do this problem without constraints. We'll only be explaining the new bits here.**\n\nIn this example we're going to show how you could use various approaches to solve a **constrained** load balancing problem. \n\nFor this problem, we're talking execution times on computer processors, with total execution time on certain processors limited to a certain amount. You might see this happen when one processor needs to \"reserve\" processing cycles for some other job not in our load balancing list. \n\nWe can describe it as:\n\ngiven a list of $n$ execution times, divide them to be executed on $k$ processors so that the total execution time on each processor is as close to the same as possible, while $y$ constrained processors are under $x$ execution time limit.\n\nThere are two kinds of constraints we can implement with our metaheuristic algorithms:\n* hard constraints\n* soft constraints\n\nWe'll start with hard constraints.","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"371ffc","input":"### Simanneal Package - Soft Constraint - Penalty Multiplier 500\nThe only parameter you can tweak in the simanneal package is how long you're willing to wait. Try changing that to see if you can get a better result.\n* wait_time = .2","pos":71,"type":"cell"}
{"cell_type":"markdown","id":"3e6b00","input":"### Hard Constraint - Objective Function\nFor a hard constraint, our objective function remains identical. (If you need a refresher on what the objective function is doing, please see the Lesson_05_Load_Balancing notebook.)\n","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"3f50f7","input":"So much better! We consisently find a feasible solution.\n\nWhat if we wanted to constrain 2 of our processors? Easy! We just add to our conproc and conmax lists. This time, let's constrain processor 0 to a max time of 1200 and processor 1 to a max time of 1100. Again, run this code multiple times and see how often the algorithm converges.","pos":23,"type":"cell"}
{"cell_type":"markdown","id":"3fa88d","input":"### The simanneal Package - Soft Constraint\nWith simanneal, instead of adding our hard constraint to the move() function, we'd add our soft constraint to the energy() function. We'll need to pass in the penalty multiplier at initialization.\n","pos":43,"type":"cell"}
{"cell_type":"markdown","id":"41b3f3","input":"## Final Results\nThe results below are sorted by the constrained score - which identifies how close to both meeting the constraints and having the processing evenly distributed among the constrained processors. Based on these results, which of the algorithms performed \"best\" for you? ","pos":85,"type":"cell"}
{"cell_type":"markdown","id":"434771","input":"With the constraint in place, what was a completely balanced solution no longer looks so great. What would happen if we switch our assignments around some?","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"469ecf","input":"## DEAP Genetic Algorithm - Feasible Start - Penalty 50\nOnce again, to just update the penalty, we only need to unregister and register in the evaluate function.","pos":81,"type":"cell"}
{"cell_type":"markdown","id":"4913cf","input":"Now we'll add some constraints. Note that neither our times nor assignments are changing. But, we're essentially changing the target for some of our processors. We're going to set processor 0 to a max limit of 10 and a penalty of 5.","pos":36,"type":"cell"}
{"cell_type":"markdown","id":"4c8229","input":"Our balance_metric_tuple function does need to be updated. We need to take in the 3 additional parameters (do you have these down yet?):\n* conproc - a list of constrained processors\n* conmax - a list of the max times on each processor\n* penalty_multiplier - integer to control how \"hard\" the penalty is\n ","pos":51,"type":"cell"}
{"cell_type":"markdown","id":"5a9b84","input":"### Hard Constraint - Enforced in the Move Function\nBut, we can put the hard constraint directly in our move function, instead. We'll implement it by first completing the move, then checking to see if the new assignments meet our constraints. If they do not, we'll return the original assignments. If they do, we'll return the new assignments.\n\nTo do this, we'll need to pass in two additional parameters:\n\n* conproc - the list of constrained processors\n* conmax - the list of max total processing time allowed on each constrained processor\n\nLet's look at the function first.\n\n","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"5ea2e1","input":"## Increasing Problem Size\n\nWe used a very small problem to demonstrate each of the methods above. Now it's time to create a much larger problem and see how our algorithms perform. \n\nWe'll also set conproc and conmax to constrain 2 of our 10 processes.","pos":55,"type":"cell"}
{"cell_type":"markdown","id":"6acc38","input":"### Simanneal Package - Soft Constraint - Penalty Multiplier 5\nThe only parameter you can tweak in the simanneal package is how long you're willing to wait. Try changing that to see if you can get a better result.\n* wait_time = .2","pos":67,"type":"cell"}
{"cell_type":"markdown","id":"7adf2f","input":"#### Running local search with constraints\n\nLet's start with setting processor 0 to be constrained to a max processing time of 1100. Run this code several times. How often do you get convergence?","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"7ee9cd","input":"#### What's happening?\nThis isn't working very well, is it? Why not? Well, let's say we start with 1400 on our constrained processor and our largest processing time is 200. 1400-200 = 1200. 1200 is still larger than our constrained solution allows. In other words - there's no single move that can find a feasible solution.\n\n#### How do we fix it?\nThere are a couple of approaches we could take. We've already seen one approach in prior lesson - using multi-start. We could wrap our load_balance_local_function_constraint or our load_balance_local_loop_constraint in a multi-start function and cross our fingers and hope that at least one of our starts randomly starts with a feasible solution. With some algorithms, that's our only choice to avoid getting stuck in a local optimum.\n\nBut for our problem, we can use another approach. We can start from a random, but feasible solution. We can do this in 2 ways - we can put all of our processes on a single processor and let the algorithm \"spread them out\" or we can randomly distribute our processes across the unconstrained processors.\n\nWe'll actually write code that handles both, because with only 3 processors, if we constrain 2, we only have a single processor to start with. But, for larger problems, we'll randomly distribute across the unconstrained processors.\n\nWe'll need a new version of our load_balance_local function.","pos":19,"type":"cell"}
{"cell_type":"markdown","id":"7f0261","input":"## Hard Constraint\nA hard constraint is a constraint which rejects any solution that doesn't meet our specifications. We've seen these before in Pyomo when we build our lists of constraints or our bounds. \n\nWe can use hard constraints with some of our metaheuristics methods. We'll use hard constraints with greedy local search and simulated annealing.\n\nThere are two ways to implement hard constraints - directly in the loop of our hand-coded solutions, or in the move function. We'll look at both approaches with our greedy local search.\n","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"849909","input":"### Greedy Local Search - Hard Constraint  In the Loop\n\nLet's see what it looks like to use the original function in a greedy local search, and enforce the hard constraint right in the loop.\n\nWe'll also track whether the algorithm ever finds a solution that meets the constraints. It's possible with a hard constraint that we never find a solution that works.\n","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"9098c4","input":"**Note:** Simanneal evaluates the problem space before running. If your constraint is set too low, simanneal will print the first pink line, and then just hang. If you're playing with this and it gets stuck, you'll need to restart your kernel and loosen your constraints.","pos":31,"type":"cell"}
{"cell_type":"markdown","id":"9c39c4","input":"With completely balanced loads, we'd have 1220-ish on each processor. We'll set processor 0's constraint to 1100. Run this code several times. Change up the penalty multiplier. How often do you meet the constraint? How balanced does the workload seem compared to our hard constraint version?","pos":47,"type":"cell"}
{"cell_type":"markdown","id":"a12344","input":"## DEAP Genetic Algorithm - Feasible Start - Penalty 500\n\nOne last time...","pos":83,"type":"cell"}
{"cell_type":"markdown","id":"a372aa","input":"### DEAP Genetic Algorithm - Penalty 500\nTo update just the penalty, we can unregister and register the evaluate function.\n\n**Warning**: This code will be slow to run.","pos":77,"type":"cell"}
{"cell_type":"markdown","id":"a51e84","input":"#### Trying again\nNow let's try our code and see if we get feasible solutions. Run this multiple times.","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"a832c5","input":"### Simulated Annealing - By Hand - Hard Constraints\n\nWe can take the same hard constraint approach with our hand-coded simulated annealing problem. Once again, we'll add 2 parameters to our custom_simanneal function:\n\n* conproc - a list of the processors to constrain\n* conmax - a list of the max times on each processor.\n\nWe'll start with a feasible solution (no processes on the constrained processor).\n\nAnd once again we'll pass back a convergence variable to let us know if we ever found a solution that matched our constraints.\n\nPersonally, I think it's neater and cleaner to use the reassign_one_constrained function. So we'll use that one for our moves.\n\nWe'll use the same set of jobs from the previous example so you can compare. ","pos":25,"type":"cell"}
{"cell_type":"markdown","id":"a92e22","input":"Here, we've met our constraint, so our unconstrained and constrained balance metrics match.","pos":42,"type":"cell"}
{"cell_type":"markdown","id":"aade29","input":"## DEAP Genetic Algorithm - Feasible Start - Penalty 5\nWe found that the GA algorithm wasn't performing as well as we'd have thought it might. So we decided to try giving it a feasible start, even though we're using a soft constraint. Algorithms can only perform as well as we program them to perform. It's okay to try multiple options!\n\nTo create a feasible start, we needed a new version of our create individual function, and we need to register our individual class and assignments.","pos":79,"type":"cell"}
{"cell_type":"markdown","id":"b20215","input":"## Soft-Constraints\nAs we've seen, sometimes with hard constraints you can fail to get a feasible solution, and we can't even get closer to a feasible solution because we're rejecting any option that doesn't meet the constraint. Soft constraints fix that problem. We won't always get a solution that meets the constraint, but the algorithm will at least have a chance to get closer to an optimal solution. The Big M approach is a type of soft constraint.\n\nIn the metaheuristic algorithms we're exploring, soft constraints are implemented in the objective function. Instead of rejecting a solution outright, a penalty is incorporated. For a minimization problem, a positive number is added when the constraint isn't met. For a maximization problem, a negative number is added. \n\nIn our code, we're adding a multiplier to the penalty. The larger the multipler, the \"harder\" the soft constraint. We'll add the penalty as a parameter so we can adjust the penalty on the fly.\n\nLet's look at what this would look like with a hand-solved problem.\n\nWe'll keep our original objective function (balanced_metric), but we'll add a new wrapper function (balanced_metric_constrained). This one will take in 3 additional parameters:\n* a list of constrained processors\n* a list of the max times on each processor\n* a penalty multiplier (integer)","pos":32,"type":"cell"}
{"cell_type":"markdown","id":"b28d75","input":"### Simanneal Package - Hard Constraint\nThe only parameter you can tweak in the simanneal package is how long you're willing to wait. Try changing that to see if you can get a better result.\n* wait_time = .2","pos":65,"type":"cell"}
{"cell_type":"markdown","id":"c3b215","input":"### Simanneal Package - Soft Constraint - Penalty Multiplier 50\nThe only parameter you can tweak in the simanneal package is how long you're willing to wait. Try changing that to see if you can get a better result.\n* wait_time = .2","pos":69,"type":"cell"}
{"cell_type":"markdown","id":"c42428","input":"What happens if we increase the penalty to 10?","pos":38,"type":"cell"}
{"cell_type":"markdown","id":"ca73f8","input":"### Greedy local search (hard constraint)\nThe only parameter we can fiddle with in our greedy local search is how many iterations we're willing to go with no improvement. Try changing the 5000 number to see if it gets better results\n\n* max_no_improve = 5000","pos":61,"type":"cell"}
{"cell_type":"markdown","id":"dc7e0e","input":"### Baseline\nLet's see what our baseline deviation from balanced loads is with a size this large. (Note, there's randomness here and some algorithms set their own baseline. But this should give us a general idea.)\n\nWe'll also create a new metric to get an apples to apples comparision of the scores, using the max constraints as a target and evenly distributed processes on unconstrained processors.","pos":59,"type":"cell"}
{"cell_type":"markdown","id":"e699f1","input":"### Hard Constraint - Directly In the loop Move Function\nWhen we implement our hard constraint directly in our loop for greedy local search, the move function remains the same as it was without constraints. ","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"ecfd5e","input":"Let's run each of these with a small number of processors and a small number of job execution times. First let's generate some random data and see what the time on each processor would be if it loads were completely balanced.","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"ee8bed","input":"### Testing the Soft Constraint\n\nWe'll test our two functions with some hand-coded assignments. We'll use 9 jobs on 3 processors. First we'll look at them as an unconstrained, perfectly balanced problem.","pos":34,"type":"cell"}
{"cell_type":"markdown","id":"f5f685","input":"### The simanneal Package - Hard Constraints - External Functions\nThe simanneal package will also work with external functions. Remember, we've already written nice, self-contained functions that correspond to simanneal's functions.\n\n* move = reassign_one_constrained\n* energy = balance_metric\n\nWe can just plop those external functions in to simanneal's functions and run our code.","pos":29,"type":"cell"}
{"id":0,"time":1631905623897,"type":"user"}
{"last_load":1631905618234,"type":"file"}