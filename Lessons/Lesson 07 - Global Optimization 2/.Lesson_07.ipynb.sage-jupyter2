{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-023519d4-4f6c-4243-9f67-b3e7bc9cac49.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"},"toc":{"base_numbering":1,"nav_menu":{},"number_sections":true,"sideBar":true,"skip_h1_title":false,"title_cell":"Table of Contents","title_sidebar":"Contents","toc_cell":false,"toc_position":{"height":"calc(100% - 180px)","left":"10px","top":"150px","width":"250.696px"},"toc_section_display":true,"toc_window_display":true},"varInspector":{"cols":{"lenName":16,"lenType":16,"lenVar":40},"kernels_config":{"python":{"delete_cmd_postfix":"","delete_cmd_prefix":"del ","library":"var_list.py","varRefreshCmd":"print(var_dic_list())"},"r":{"delete_cmd_postfix":") ","delete_cmd_prefix":"rm(","library":"var_list.r","varRefreshCmd":"cat(var_dic_list()) "}},"types_to_exclude":["module","function","builtin_function_or_method","instance","_Feature"],"window_display":false}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"e7a7ff","input":"","pos":97,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"a8a516","input":"def obj_Sphere(x):\n    x = np.array(x) # force a numpy arrray here so that the math below works\n    return np.sum(x**2)\n\npop_size=10\nind_size = 20\nlower=-100\nupper=100\n\npop1 = np.random.uniform(low=lower, high=upper, size =(pop_size,ind_size))\nfitness1 = ga.computeFitness(obj_Sphere, pop1)\nprint('fitness1', fitness1)\n\nind_size=5\npop2 = np.random.uniform(low=lower, high=upper, size =(pop_size,ind_size))\nfitness2 = ga.computeFitness(obj_Sphere, pop2)\n\nprint('fitness2', fitness2)","output":{"0":{"ename":"NameError","evalue":"name 'np' is not defined","output_type":"error","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)","\u001b[0;32m/tmp/ipykernel_959/1572230996.py\u001b[0m in \u001b[0;36m<cell line: 10>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      8\u001b[0m \u001b[0mupper\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m100\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      9\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 10\u001b[0;31m \u001b[0mpop1\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrandom\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0muniform\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlow\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mlower\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhigh\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mupper\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msize\u001b[0m \u001b[0;34m=\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpop_size\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mind_size\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     11\u001b[0m \u001b[0mfitness1\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcomputeFitness\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mobj_Sphere\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpop1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     12\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'fitness1'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfitness1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mNameError\u001b[0m: name 'np' is not defined"]}},"pos":66,"type":"cell"}
{"cell_type":"code","exec_count":10,"id":"fc4143","input":"#review the documentation for sortPop\n?ga.sortPop","output":{"0":{"data":{"text/plain":"\u001b[0;31mSignature:\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msortPop\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfitness\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;31mDocstring:\u001b[0m\nSorts a population with minimal fitness in first place.\n\nParameters:\npop (numpy array, required): The population to sort, individuals in rows\nfitness (numpy array, required): The values used to sort the population\n\nReturns:\nSorted numpy array of population\n\u001b[0;31mFile:\u001b[0m      ~/Lessons/Lesson 07 - Global Optimization 2/GAUtilities.py\n\u001b[0;31mType:\u001b[0m      function\n"},"exec_count":10,"output_type":"execute_result","start":0}},"pos":21,"type":"cell"}
{"cell_type":"code","exec_count":11,"id":"3b47ba","input":"pop = ga.sortPop(pop, fitness)#sort population\npop","output":{"0":{"data":{"text/plain":"array([[4, 1, 2],\n       [2, 3, 4],\n       [2, 3, 4],\n       [3, 6, 4],\n       [6, 2, 5],\n       [6, 4, 5]])"},"exec_count":11,"output_type":"execute_result"}},"pos":22,"type":"cell"}
{"cell_type":"code","exec_count":12,"id":"9b988c","input":"#review the documentation for tournamentSelection\n?ga.tournamentSelection","output":{"0":{"data":{"text/plain":"\u001b[0;31mSignature:\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtournamentSelection\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtourn_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdebug\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;31mDocstring:\u001b[0m\nImplements tournameent selection on a population.\n\nParameters:\npop (numpy array, required): The sorted population from which selections will be drawn.\ntourn_size (between 2 and population size, required): The number of individuals that will compete in each tournament\ndebug (boolean, optional, default=False): Flag to indicate whether to output debugging print statements.\n\nReturns:\nNumpy Array of the selected population.\n\u001b[0;31mFile:\u001b[0m      ~/Lessons/Lesson 07 - Global Optimization 2/GAUtilities.py\n\u001b[0;31mType:\u001b[0m      function\n"},"exec_count":12,"output_type":"execute_result","start":0}},"pos":24,"type":"cell"}
{"cell_type":"code","exec_count":13,"id":"7144b6","input":"tourn_size = 2\nselected_pop = ga.tournamentSelection(pop, tourn_size, debug=True).astype(int) ","output":{"0":{"name":"stdout","output_type":"stream","text":"Individuals in tournament: [5 0]\nIndividual selected: 0\nIndividuals in tournament: [3 2]\nIndividual selected: 2\nIndividuals in tournament: [5 2]\nIndividual selected: 2\nIndividuals in tournament: [0 1]\nIndividual selected: 0\nIndividuals in tournament: [4 3]\nIndividual selected: 3\nIndividuals in tournament: [1 4]\nIndividual selected: 1\n"}},"pos":26,"type":"cell"}
{"cell_type":"code","exec_count":14,"id":"0405eb","input":"print('Original fitness\\n', fitness)\n#get the new fitness\nselected_fitness = ga.computeFitness(obj_sumDice, selected_pop)\nprint('Selected fitness\\n', selected_fitness)","output":{"0":{"name":"stdout","output_type":"stream","text":"Original fitness\n [ 9. 13.  9. 15. 13.  7.]\nSelected fitness\n [ 7.  9.  9.  7. 13.  9.]\n"}},"pos":28,"type":"cell"}
{"cell_type":"code","exec_count":15,"id":"cb84fc","input":"parent1 = np.arange(10) + 10 # use sequences to make it easy to see crossover\nparent2 = parent1 + 10\n\nchild1, child2 = parent1.copy(), parent2.copy()\ncx_point = 3\nchild1[0:cx_point], child2[0:cx_point] = parent2[0:cx_point], parent1[0:cx_point]\n\nprint('Parents')\nprint(parent1)\nprint(parent2)\nprint('\\nChildren')\nprint(child1)\nprint(child2)","output":{"0":{"name":"stdout","output_type":"stream","text":"Parents\n[10 11 12 13 14 15 16 17 18 19]\n[20 21 22 23 24 25 26 27 28 29]\n\nChildren\n[20 21 22 13 14 15 16 17 18 19]\n[10 11 12 23 24 25 26 27 28 29]\n"}},"pos":31,"type":"cell"}
{"cell_type":"code","exec_count":16,"id":"9a751f","input":"#review the documentation for ga.onePointCrossover\n?ga.onePointCrossover","output":{"0":{"data":{"text/plain":"\u001b[0;31mSignature:\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0monePointCrossover\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcx_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdebug\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;31mDocstring:\u001b[0m\nPeforms one-point crossover on integer, boolean or real populations.\n\nParameters:\npop (numpy array, required): The population, individuals as rows\ncx_prob (real between 0 and 1, required): The probability that any two individuals will mate\ndebug (boolean, optional, default=False): Flag to indicate whether to output debugging print statements.\n\nReturns: \nPopulation (will return as reals, should be cast if integer or boolean is desired)\n\u001b[0;31mFile:\u001b[0m      ~/Lessons/Lesson 07 - Global Optimization 2/GAUtilities.py\n\u001b[0;31mType:\u001b[0m      function\n"},"exec_count":16,"output_type":"execute_result","start":0}},"pos":33,"type":"cell"}
{"cell_type":"code","exec_count":17,"id":"9e0edb","input":"cx_prob = .8\ncx_pop = ga.onePointCrossover(selected_pop, cx_prob, debug=True).astype(int)","output":{"0":{"name":"stdout","output_type":"stream","text":"Crossover happened between Individuals 0 and 1 at point 2\nCrossover happened between Individuals 2 and 3 at point 1\nCrossover happened between Individuals 4 and 5 at point 1\n"}},"pos":35,"type":"cell"}
{"cell_type":"code","exec_count":18,"id":"e2699e","input":"print('Individuals before crossover.')\npd.DataFrame(selected_pop)","output":{"0":{"name":"stdout","output_type":"stream","text":"Individuals before crossover.\n"},"1":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>4</td>\n      <td>1</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>3</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2</td>\n      <td>3</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>1</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>3</td>\n      <td>6</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>2</td>\n      <td>3</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"   0  1  2\n0  4  1  2\n1  2  3  4\n2  2  3  4\n3  4  1  2\n4  3  6  4\n5  2  3  4"},"exec_count":18,"output_type":"execute_result"}},"pos":37,"type":"cell"}
{"cell_type":"code","exec_count":19,"id":"0b3d77","input":"print('Individuals after crossover.')\npd.DataFrame(cx_pop)","output":{"0":{"name":"stdout","output_type":"stream","text":"Individuals after crossover.\n"},"1":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2</td>\n      <td>3</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>4</td>\n      <td>1</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>4</td>\n      <td>3</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2</td>\n      <td>1</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2</td>\n      <td>6</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>3</td>\n      <td>3</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"   0  1  2\n0  2  3  2\n1  4  1  4\n2  4  3  4\n3  2  1  2\n4  2  6  4\n5  3  3  4"},"exec_count":19,"output_type":"execute_result"}},"pos":38,"type":"cell"}
{"cell_type":"code","exec_count":20,"id":"b882b3","input":"#review the documentation for ga.uniformIntMutation\n?ga.uniformIntMutation","output":{"0":{"data":{"text/plain":"\u001b[0;31mSignature:\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0muniformIntMutation\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmut_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mind_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbounds\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdebug\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;31mDocstring:\u001b[0m\nPeforms uniform integer mutation on integer populations.\n\nParameters:\npop (numpy array, required): The population, individuals as rows\nmut_prob (real between 0 and 1, required): The probability that any individual will mutate\nind_prob (real between 0 and 1, required): The probability that a gene will mutate\nbounds (list, required): the [lower, upper] bounds of possible values for each gene   \ndebug (boolean, optional, default=False): Flag to indicate whether to output debugging print statements.\n\nReturns: \nPopulation of integer variables\n\u001b[0;31mFile:\u001b[0m      ~/Lessons/Lesson 07 - Global Optimization 2/GAUtilities.py\n\u001b[0;31mType:\u001b[0m      function\n"},"exec_count":20,"output_type":"execute_result","start":0}},"pos":41,"type":"cell"}
{"cell_type":"code","exec_count":21,"id":"e6c27a","input":"mut_prob = 1.0 # all individuals can mutate, usually around 0.1 to 0.3\nind_prob = 0.25 # about a quarter the genes can mutate, usually around .1 or .2\n\nmut_pop = ga.uniformIntMutation(cx_pop, mut_prob, ind_prob, bounds, debug=True)","output":{"0":{"name":"stdout","output_type":"stream","text":"Gene 0 in Individual 0 mutated.\nGene 1 in Individual 0 mutated.\nGene 0 in Individual 1 mutated.\nGene 1 in Individual 4 mutated.\n"}},"pos":42,"type":"cell"}
{"cell_type":"code","exec_count":22,"id":"39de14","input":"pd.DataFrame(cx_pop-mut_pop)","output":{"0":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>-4</td>\n      <td>-3</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>0</td>\n      <td>4</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"   0  1  2\n0 -4 -3  0\n1  2  0  0\n2  0  0  0\n3  0  0  0\n4  0  4  0\n5  0  0  0"},"exec_count":22,"output_type":"execute_result"}},"pos":44,"type":"cell"}
{"cell_type":"code","exec_count":23,"id":"446756","input":"#review documentation for ga.addElitism\n?ga.addElitism","output":{"0":{"data":{"text/plain":"\u001b[0;31mSignature:\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0maddElitism\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minitPop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmutPop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnum_elite\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;31mDocstring:\u001b[0m\nPeforms elitism by pulling in num_elite best individuals from initPop to mutPop.\n\nParameters:\ninitPop (numpy array, required): The population from the beginning of the loop, individuals as rows\nmutPop (numpy array, required): The population post-mutation.\n\nReturns: \nPopulation numpy array population\n\u001b[0;31mFile:\u001b[0m      ~/Lessons/Lesson 07 - Global Optimization 2/GAUtilities.py\n\u001b[0;31mType:\u001b[0m      function\n"},"exec_count":23,"output_type":"execute_result","start":0}},"pos":47,"type":"cell"}
{"cell_type":"code","exec_count":24,"id":"402c33","input":"num_elite = 1 #just pull the best individual forward\npop = ga.addElitism(pop, mut_pop, num_elite)\npop","output":{"0":{"data":{"text/plain":"array([[4, 1, 2],\n       [2, 1, 4],\n       [4, 3, 4],\n       [2, 1, 2],\n       [2, 2, 4],\n       [3, 3, 4]])"},"exec_count":24,"output_type":"execute_result"}},"pos":48,"type":"cell"}
{"cell_type":"code","exec_count":25,"id":"7c16ee","input":"pop = mut_pop.copy() #only run this line if not using elitism\nfitness = ga.computeFitness(obj_sumDice, pop)\nfitness","output":{"0":{"data":{"text/plain":"array([14.,  7., 11.,  5.,  8., 10.])"},"exec_count":25,"output_type":"execute_result"}},"pos":50,"type":"cell"}
{"cell_type":"code","exec_count":27,"id":"8199f5","input":"lower = -5.12\nupper = 5.12\npop_size = 6\nind_size = 4\n\npop = np.random.uniform(low=lower, high=upper, size =(pop_size,ind_size))\npop","output":{"0":{"data":{"text/plain":"array([[ 2.85517742,  2.21244473, -0.74732965, -2.50086199],\n       [ 2.57318573, -2.59268847,  1.39411371,  4.1511759 ],\n       [ 1.62040313,  3.38724382, -4.05127846, -4.87040522],\n       [-5.00271721, -2.19121951, -2.48391392,  1.879771  ],\n       [-4.84664512, -3.48522145,  0.66336117,  3.98529509],\n       [-3.89013374,  4.79252411, -1.3669146 , -3.92801455]])"},"exec_count":27,"output_type":"execute_result"}},"pos":54,"type":"cell"}
{"cell_type":"code","exec_count":28,"id":"fdf930","input":"#review documentation for ga.blendedCrossover\n?ga.blendedCrossover","output":{"0":{"data":{"text/plain":"\u001b[0;31mSignature:\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mblendedCrossover\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcx_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0malpha\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbounds\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdebug\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;31mDocstring:\u001b[0m\nPeforms blended crossover on real populations.\n\nParameters:\npop (numpy array, required): The population, individuals as rows\ncx_prob (real between 0 and 1, required): The probability that any two individuals will mate\nalpha (real, required): the amount of expansion\nbounds (list, required): the [lower, upper] bounds of possible values for each gene\ndebug (boolean, optional, default=False): Flag to indicate whether to output debugging print statements.\n\nReturns: \nPopulation of real variables\n\u001b[0;31mFile:\u001b[0m      ~/Lessons/Lesson 07 - Global Optimization 2/GAUtilities.py\n\u001b[0;31mType:\u001b[0m      function\n"},"exec_count":28,"output_type":"execute_result","start":0}},"pos":56,"type":"cell"}
{"cell_type":"code","exec_count":29,"id":"88c204","input":"print('Before\\n', pop)\ncx_prob = .3\nalpha = .2\nlower = -5.12\nupper = 5.12\n\n#call our blended crossover function\ncx_pop = ga.blendedCrossover(pop, cx_prob, alpha, [lower, upper], debug=True)\nprint('After\\n', cx_pop)","output":{"0":{"name":"stdout","output_type":"stream","text":"Before\n [[ 2.85517742  2.21244473 -0.74732965 -2.50086199]\n [ 2.57318573 -2.59268847  1.39411371  4.1511759 ]\n [ 1.62040313  3.38724382 -4.05127846 -4.87040522]\n [-5.00271721 -2.19121951 -2.48391392  1.879771  ]\n [-4.84664512 -3.48522145  0.66336117  3.98529509]\n [-3.89013374  4.79252411 -1.3669146  -3.92801455]]\nCrossover occurred between 4 and 5\nAfter\n [[ 2.85517742  2.21244473 -0.74732965 -2.50086199]\n [ 2.57318573 -2.59268847  1.39411371  4.1511759 ]\n [ 1.62040313  3.38724382 -4.05127846 -4.87040522]\n [-5.00271721 -2.19121951 -2.48391392  1.879771  ]\n [-4.22159496  0.11972393 -0.59974703  0.72018136]\n [-3.97427964  2.93570813 -0.85805246 -0.50609066]]\n"}},"pos":58,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"4ba77f","input":"pop_size = 6 # should be even due to the way we'll implement crossover\nind_size = 3 # determines number of decision variables within each individual\nbounds = [1,7] #range of integers. remember for integers, you need to go one over the number you really want\ntourn_size = 2 # tournament size for selection\ncx_prob = 0.8 # probability a pair of parents crossover to produce two children\nmut_prob = 0.2 # probability an individual mutates\nind_prob = 0.1 # probability each variable in an individual mutates\nnum_iter = 200 # number of genetic algorithm mutations\nupdate_iter = 20 # how often to display output\n\n\n# objective or fitness function. \n#It's not important this is defined in this spot, just that it's defined somewhere before the code below\ndef obj_sumDice(x):\n    x = np.array(x) # force a numpy arrray here so that the math below works\n    return np.sum(x)\n\n#initialize population and fitness\npop = np.random.randint(low=bounds[0], high=bounds[1], size =(pop_size,ind_size))\nfitness = ga.computeFitness(obj_sumDice, pop)\n\n# initialize stats and output\nstats, best_fitness, best_x = ga.initStats(fitness, pop, num_iter)\n\n#This is where the guts of the algorithm start\nfor iter in range(num_iter):\n    \n    # tournament selection\n    pop = ga.sortPop(pop, fitness)#sort population\n    selected_pop = ga.tournamentSelection(pop, tourn_size).astype(int)\n\n    # one-point crossover (mating)\n    cx_pop = ga.onePointCrossover(selected_pop, cx_prob).astype(int)\n\n    # uniformIntMutation\n    #note that bounds should be an array and we need to pass back ints because this is an integer problem\n    mut_pop = ga.uniformIntMutation(cx_pop, mut_prob, ind_prob, bounds)\n    \n    #choose one of the following two options, based on the complexity of your problem\n    # copy mutated pop\n    pop = mut_pop.copy()\n    #or run elitism\n    #pop = ga.addElitism(pop, mut_pop, 1)\n    \n    #re-calculate fitness\n    fitness = ga.computeFitness(obj_sumDice, pop)\n    \n    # collect stats and output to screen\n    stats, best_fitness, best_x = ga.updateStats(stats, fitness,best_x, pop, iter, update_iter)\n\n\n#####################\n# Everything in the algorithm is done, and now we're just outputting the final result\n#####################\nprint(f\"The minimum value found of dice total is {best_fitness:.0f}\")\nprint(\"The location of that minimum is:\")\nprint('(',', '.join(f\"{x:.0f}\" for x in best_x),')')","output":{"0":{"name":"stdout","output_type":"stream","text":"Iteration | Best this iter |    Best ever\n        1 |      4.000e+00 |    4.000e+00\n       20 |      4.000e+00 |    4.000e+00\n       40 |      3.000e+00 |    3.000e+00\n       60 |      3.000e+00 |    3.000e+00\n       80 |      3.000e+00 |    3.000e+00\n      100 |      3.000e+00 |    3.000e+00\n      120 |      3.000e+00 |    3.000e+00\n      140 |      3.000e+00 |    3.000e+00\n      160 |      3.000e+00 |    3.000e+00\n      180 |      3.000e+00 |    3.000e+00\n      200 |      3.000e+00 |    3.000e+00\nThe minimum value found of dice total is 3\nThe location of that minimum is:\n( 1, 1, 1 )\n"}},"pos":6,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"9ad6ba","input":"# EXECUTE FIRST\nimport GAUtilities as ga # this is a local package\n\n# computational imports\nimport numpy as np\nimport pandas as pd\n\nfrom scipy.optimize import minimize\nimport json\nfrom simanneal import Annealer\n\n# plotting imports\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style(\"darkgrid\")\n\n# display import\nfrom IPython.display import display, IFrame\nfrom IPython.core.display import HTML\n\n# for playing videos, customize height and width if desired\ndef play_video(vid_name, w=640, h=360):\n    vid_path = \"https://media.uwex.edu/content/ds/ds775_r19/\" + vid_name + \"/index.html\"\n    hlink = '<a href = ' + vid_path + ' target = \"\"\"_blank\"\"\">Open video in new tab</a>'\n    display(IFrame(vid_path, width=w, height=h))\n    display(HTML(hlink))\n\n# for this notebook we get rid of a bunch of warnings that don't hurt anything\nimport warnings\nwarnings.filterwarnings('ignore')\n\nfrom time import time","metadata":{"code_folding":[]},"pos":0,"type":"cell"}
{"cell_type":"code","exec_count":30,"id":"1af485","input":"?ga.gaussianMutation","output":{"0":{"data":{"text/plain":"\u001b[0;31mSignature:\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgaussianMutation\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmut_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mind_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbounds\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msigma\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdebug\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;31mDocstring:\u001b[0m\nPeforms gaussian mutation on real populations.\n\nParameters:\npop (numpy array, required): The population, individuals as rows\nmut_prob (real between 0 and 1, required): The probability that any individual will mutate\nind_prob (real between 0 and 1, required): The probability that a gene will mutate\nbounds (list, required): the [lower, upper] bounds of possible values for each gene\nsigma (real, required): standard deviation used to generate new mutations\ndebug (boolean, optional, default=False): Flag to indicate whether to output debugging print statements.\n\nReturns: \nPopulation of real variables\n\u001b[0;31mFile:\u001b[0m      ~/Lessons/Lesson 07 - Global Optimization 2/GAUtilities.py\n\u001b[0;31mType:\u001b[0m      function\n"},"exec_count":30,"output_type":"execute_result","start":0}},"pos":60,"type":"cell"}
{"cell_type":"code","exec_count":31,"id":"a8f05c","input":"#set variables\nupper = 5.12\nlower = -5.12\nsigma = (upper-lower)/6\nmut_prob = 1\nind_prob= .5\nmut_pop = ga.gaussianMutation(cx_pop, mut_prob, ind_prob, [lower, upper], sigma, debug=True)\nprint('Before', cx_pop)\nprint('After', mut_pop)","output":{"0":{"name":"stdout","output_type":"stream","text":"Mutation probability met for individual 0\nMutation probability met for individual 1\nMutation probability met for individual 2\nMutation probability met for individual 3\nMutation probability met for individual 4\nMutation probability met for individual 5\nBefore [[ 2.85517742  2.21244473 -0.74732965 -2.50086199]\n [ 2.57318573 -2.59268847  1.39411371  4.1511759 ]\n [ 1.62040313  3.38724382 -4.05127846 -4.87040522]\n [-5.00271721 -2.19121951 -2.48391392  1.879771  ]\n [-4.22159496  0.11972393 -0.59974703  0.72018136]\n [-3.97427964  2.93570813 -0.85805246 -0.50609066]]\nAfter [[ 0.95312112  2.30843574 -0.74732965 -2.50086199]\n [ 1.44414373 -1.73572574  1.39411371  4.14895243]\n [ 2.09002083  3.38724382 -4.4004727  -4.87040522]\n [-5.00271721 -5.12       -2.48391392  3.99813338]\n [-3.44030682  0.11972393 -0.59974703 -0.54925899]\n [-3.97427964  2.0488328   1.55648275 -0.50609066]]\n"}},"pos":61,"type":"cell"}
{"cell_type":"code","exec_count":32,"id":"9231ca","input":"x = np.linspace(-100,100,201)\ny = (x**2) #this is the 1-dimensional version of the Sphere code\n\nfig = plt.figure(figsize=(5,5)) # adjust figsize as needed for your display\nplt.plot(x,y)\nplt.xlabel('x');\nplt.ylabel('y');\n","output":{"0":{"data":{"image/png":"7028d0e81f800f698dadbfbc8d87136302bc0a9a","text/plain":"<Figure size 360x360 with 1 Axes>"},"exec_count":32,"metadata":{"image/png":{"height":316,"width":346}},"output_type":"execute_result"}},"pos":63,"type":"cell"}
{"cell_type":"code","exec_count":33,"id":"a3d4c4","input":"# Graph of Sphere with dimension n = 2\n%run scripts/sphere2d.py","output":{"0":{"data":{"iframe":"f9c57a0f138dacea5363fa7873839cddb2d6e027"},"output_type":"execute_result"},"1":{"data":{"text/plain":"<Figure size 864x504 with 0 Axes>"},"exec_count":33,"output_type":"execute_result"}},"pos":64,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":35,"id":"5ab99b","input":"###Using lists of variables - note how they're called in the code with an index. We'll have 3 sets.\npop_size = [6, 100, 1000] # should be even due to the way we'll implement crossover\nind_size = [2, 5, 20] # determines number of input variables for Rastrigin and each individual\ntourn_size = [2,3,3] # tournament size for selection\ncx_prob = [0.8, .7, .8] # probability a pair of parents crossover to produce two children\nmut_prob = [0.3,.2,.1] # probability an individual mutates\nind_prob = [0.1, .1, .2] # probability each variable in an individual mutates\nnum_iter = [10, 100, 200] # number of genetic algorithm mutations (may want the first set to be 1 to start)\nupdate_iter =[1, 20, 50] # how often to display output\nnum_elite = [0, 1, 3] #how many of the original population to pass through to the next unchanged\n\n#these stay the same for every iteration\nbounds = [-100, 100] #lower and upper bounds for the decision variables\nsigma = (bounds[1]-bounds[0])/6\nalpha = .2\n\n#current index to use - starting with index 0 - look for the places we've added [idx]\n#change to idx 1 when you've got code that works, then idx 2 to run a large problem.\nidx=0\n\n#initialize population and fitness\npop = np.random.uniform(low=lower, high=upper, size =(pop_size[idx],ind_size[idx]))\nfitness = ga.computeFitness(obj_Sphere, pop)\n\n# initialize stats and output\nstats, best_fitness, best_x = ga.initStats(fitness, pop, num_iter[idx])\n\n#This is where the guts of the algorithm start\nfor iter in range(num_iter[idx]):\n    \n    # tournament selection\n    pop = ga.sortPop(pop, fitness)#sort population\n\n    selected_pop = ga.tournamentSelection(pop, tourn_size[idx])\n\n    # blended crossover (mating)\n    cx_pop = ga.blendedCrossover(selected_pop, cx_prob[idx], alpha, bounds)\n    \n    # gaussianMutation\n    mut_pop = ga.gaussianMutation(cx_pop, mut_prob[idx], ind_prob[idx], bounds, sigma)\n    \n    #choose one of the following two options, based on the complexity of your problem\n    # copy mutated pop\n    #pop = mut_pop.copy()\n    #or run elitism\n    pop = ga.addElitism(pop, mut_pop, num_elite[idx])\n    #re-calculate fitness\n    fitness = ga.computeFitness(obj_Sphere, pop)\n    \n    # collect stats and output to screen\n    stats, best_fitness, best_x = ga.updateStats(stats, fitness, best_x, pop, iter, update_iter[idx])\n\n\n#####################\n# Everything in the algorithm is done, and now we're just outputting the final result\n#####################\nprint(f\"The minimum value found of the sphere is {best_fitness:.4f}\")\nprint(\"The location of that minimum is:\")\nprint('(',', '.join(f\"{x:.4f}\" for x in best_x),')')","output":{"0":{"name":"stdout","output_type":"stream","text":"Iteration | Best this iter |    Best ever\n        1 |      3.907e+00 |    3.907e+00\n        2 |      3.775e+00 |    2.463e+00\n        3 |      3.775e+00 |    2.463e+00\n        4 |      3.775e+00 |    2.463e+00\n        5 |      3.775e+00 |    2.463e+00\n        6 |      3.775e+00 |    2.463e+00\n        7 |      3.775e+00 |    2.463e+00\n        8 |      3.775e+00 |    2.463e+00\n        9 |      3.775e+00 |    2.463e+00\n       10 |      3.775e+00 |    2.463e+00\nThe minimum value found of the sphere is 2.4631\nThe location of that minimum is:\n( -1.1790, 1.5864 )\n"}},"pos":68,"type":"cell"}
{"cell_type":"code","exec_count":36,"id":"4514ad","input":"####################\n# Add location optimization at the end\n####################\nresult = minimize(obj_Sphere, best_x)\nprint(f\"The minimum value found of the sphere is {result.fun:.4f}\")\nprint(\"The location of that minimum is:\")\nprint('(',', '.join(f\"{x:.4f}\" for x in result.x),')')\n","output":{"0":{"name":"stdout","output_type":"stream","text":"The minimum value found of the sphere is 0.0000\nThe location of that minimum is:\n( 0.0000, -0.0000 )\n"}},"pos":70,"type":"cell"}
{"cell_type":"code","exec_count":37,"id":"67154c","input":"##Binary population of 5 individuals with 5 genes\npop_size = 6\nind_size = 4\n\n# 0 and 1\npop = np.random.randint(0,2,size=(pop_size,ind_size))\n# False and True\npop = np.random.randint(0,2,size=(pop_size,ind_size)).astype(bool)\npop","output":{"0":{"data":{"text/plain":"array([[ True, False,  True,  True],\n       [ True, False,  True,  True],\n       [ True,  True, False, False],\n       [ True, False, False,  True],\n       [ True,  True, False,  True],\n       [False,  True,  True,  True]])"},"exec_count":37,"output_type":"execute_result"}},"pos":72,"type":"cell"}
{"cell_type":"code","exec_count":38,"id":"a8977e","input":"cx_prob =.8\n\ncx_pop = ga.onePointCrossover(pop, cx_prob, debug=True).astype(bool)\ncx_pop","output":{"0":{"name":"stdout","output_type":"stream","text":"Crossover happened between Individuals 0 and 1 at point 3\nCrossover happened between Individuals 2 and 3 at point 2\nCrossover happened between Individuals 4 and 5 at point 3\n"},"1":{"data":{"text/plain":"array([[ True, False,  True,  True],\n       [ True, False,  True,  True],\n       [ True, False, False, False],\n       [ True,  True, False,  True],\n       [False,  True,  True,  True],\n       [ True,  True, False,  True]])"},"exec_count":38,"output_type":"execute_result"}},"pos":74,"type":"cell"}
{"cell_type":"code","exec_count":39,"id":"b247ab","input":"#review documenation for ga.bitFlipMutation\n?ga.bitFlipMutation","output":{"0":{"data":{"text/plain":"\u001b[0;31mSignature:\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbitFlipMutation\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmut_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mind_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdebug\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;31mDocstring:\u001b[0m\nPeforms bit-flipping mutation on boolean populations.\n\nParameters:\npop (numpy array, required): The population, individuals as rows\nmut_prob (real between 0 and 1, required): The probability that any individual will mutate\nind_prob (real between 0 and 1, required): The probability that a gene will mutate\ndebug (boolean, optional, default=False): Flag to indicate whether to output debugging print statements.\n\nReturns: \nPopulation of boolean variables\n\u001b[0;31mFile:\u001b[0m      ~/Lessons/Lesson 07 - Global Optimization 2/GAUtilities.py\n\u001b[0;31mType:\u001b[0m      function\n"},"exec_count":39,"output_type":"execute_result","start":0}},"pos":76,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"6b1304","input":"# execute for video\nplay_video(\"ds775_lesson7_genetic-algorithm-intro\")","output":{"0":{"data":{"iframe":"45a87e2ec09e922cc72dad0bdfc270dd7693504d","text/plain":"<IPython.lib.display.IFrame at 0x7fdf01545d30>"},"exec_count":4,"output_type":"execute_result"},"1":{"data":{"text/html":"<a href = https://media.uwex.edu/content/ds/ds775_r19/ds775_lesson7_genetic-algorithm-intro/index.html target = \"\"\"_blank\"\"\">Open video in new tab</a>","text/plain":"<IPython.core.display.HTML object>"},"exec_count":4,"output_type":"execute_result"}},"pos":4,"type":"cell"}
{"cell_type":"code","exec_count":40,"id":"38d60b","input":"mut_prob = 1 #set high for demonstration\nind_prob = .5\nmut_pop = ga.bitFlipMutation(cx_pop, mut_prob, ind_prob, debug=True)\nmut_pop","output":{"0":{"name":"stdout","output_type":"stream","text":"Gene 3 in Individual 0 flipped.\nGene 0 in Individual 1 flipped.\nGene 2 in Individual 1 flipped.\nGene 3 in Individual 1 flipped.\nGene 0 in Individual 2 flipped.\nGene 1 in Individual 2 flipped.\nGene 3 in Individual 2 flipped.\nGene 1 in Individual 3 flipped.\nGene 2 in Individual 3 flipped.\nGene 3 in Individual 3 flipped.\nGene 2 in Individual 4 flipped.\nGene 0 in Individual 5 flipped.\nGene 2 in Individual 5 flipped.\nGene 3 in Individual 5 flipped.\n"},"1":{"data":{"text/plain":"array([[ True, False,  True, False],\n       [False, False, False, False],\n       [False,  True, False,  True],\n       [ True, False,  True, False],\n       [False,  True, False,  True],\n       [False,  True,  True, False]])"},"exec_count":40,"output_type":"execute_result"}},"pos":77,"type":"cell"}
{"cell_type":"code","exec_count":41,"id":"1a000d","input":"#remember that if want up to 5, we need to set the ind_size to 6\nind_size = 6\npop_size = 4\n#first we make the empty array\npop = np.empty((pop_size,ind_size),dtype=int)\n#then we fill it with permutations\nfor j in range(pop_size):\n    pop[j] = np.random.permutation(ind_size).astype(int)\n\n#view the population\npop","output":{"0":{"data":{"text/plain":"array([[1, 5, 4, 2, 3, 0],\n       [0, 4, 1, 5, 3, 2],\n       [3, 5, 4, 0, 2, 1],\n       [5, 1, 4, 0, 3, 2]])"},"exec_count":41,"output_type":"execute_result"}},"pos":79,"type":"cell"}
{"cell_type":"code","exec_count":43,"id":"63ebd1","input":"# Ordered Crossover on Sequences in Numpy\nparent1 = np.array([0, 1, 2, 3, 4, 5, 6])\nparent2 = np.array([3, 5, 6, 2, 0, 4, 1])\n\nind_size = parent1.shape[0]\n\n# uncomment the line below to choose subsequence randomly in your code\n# swap_idx = np.sort(np.random.randint(0,ind_size,2))\n\n# delete this for your code, we want a fixed sequence for our example\nswap_idx = np.array([ 3, 5]) # subseq in positions 3 through 5 inclusive\n\n# A - important to copy these in reverse order\nchild1,child2 = parent2.copy(), parent1.copy()\n# end A\n\n# B - These four lines are the actual crossover\nhole = np.full( ind_size, False, dtype = bool)\nswap_idx = np.sort(np.random.randint(0,ind_size,2))\nhole[swap_idx[0]:swap_idx[1]+1] = True\nchild1[~hole] = np.array([x for x in parent1 if x not in parent2[hole]])\nchild2[~hole] = np.array([x for x in parent2 if x not in parent1[hole]])\n# end B\n\nprint(hole)\nprint(parent1[hole])\nprint(parent2[hole])\nprint(parent1,parent2)\nprint(child1,child2)","output":{"0":{"name":"stdout","output_type":"stream","text":"[False False  True  True  True  True False]\n[2 3 4 5]\n[6 2 0 4]\n[0 1 2 3 4 5 6] [3 5 6 2 0 4 1]\n[1 3 6 2 0 4 5] [6 0 2 3 4 5 1]\n"}},"pos":83,"type":"cell"}
{"cell_type":"code","exec_count":44,"id":"268609","input":"#review documenation for ga.orderedCrossover\n?ga.orderedCrossover","output":{"0":{"data":{"text/plain":"\u001b[0;31mSignature:\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0morderedCrossover\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcx_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdebug\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;31mDocstring:\u001b[0m\nPeforms ordered crossover on permutation populations.\n\nParameters:\npop (numpy array of permutations, required): The population of permutations, individuals as rows\ncx_prob (real between 0 and 1, required): The probability that any two individuals will mate\ndebug (boolean, optional, default=False): Flag to indicate whether to output debugging print statements.\n\nReturns: \nPopulation of integers\n\u001b[0;31mFile:\u001b[0m      ~/Lessons/Lesson 07 - Global Optimization 2/GAUtilities.py\n\u001b[0;31mType:\u001b[0m      function\n"},"exec_count":44,"output_type":"execute_result","start":0}},"pos":85,"type":"cell"}
{"cell_type":"code","exec_count":45,"id":"ee623b","input":"cx_prob = .8\ncx_pop = ga.orderedCrossover(pop, cx_prob, True)\ncx_pop","output":{"0":{"name":"stdout","output_type":"stream","text":"Crossover happened for individual 0\nParent 1 [1 5 4 2 3 0]\nParent 2 [0 4 1 5 3 2]\nSwap Index: [1 4]\nHole [False  True  True  True  True False]\nChild1 [2 4 1 5 3 0]\nChild2 [0 5 4 2 3 1]\nCrossover happened for individual 1\nParent 1 [3 5 4 0 2 1]\nParent 2 [5 1 4 0 3 2]\nSwap Index: [0 0]\nHole [ True False False False False False]\nChild1 [5 3 4 0 2 1]\nChild2 [3 5 1 4 0 2]\n"},"1":{"data":{"text/plain":"array([[2, 4, 1, 5, 3, 0],\n       [0, 5, 4, 2, 3, 1],\n       [5, 3, 4, 0, 2, 1],\n       [3, 5, 1, 4, 0, 2]])"},"exec_count":45,"output_type":"execute_result"}},"pos":86,"type":"cell"}
{"cell_type":"code","exec_count":46,"id":"a7b9c6","input":"#review the documentation for ga.shuffleMutation\n?ga.shuffleMutation","output":{"0":{"data":{"text/plain":"\u001b[0;31mSignature:\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshuffleMutation\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmut_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mind_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdebug\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;31mDocstring:\u001b[0m\nPeforms index shuffling mutation on permutation populations.\n\nParameters:\npop (numpy array, required): The population, individuals as rows\nmut_prob (real between 0 and 1, required): The probability that any individual will mutate\nind_prob (real between 0 and 1, required): The probability that a gene will mutate\ndebug (boolean, optional, default=False): Flag to indicate whether to output debugging print statements.\n\nReturns: \nPopulation of permutation integer variables\n\u001b[0;31mFile:\u001b[0m      ~/Lessons/Lesson 07 - Global Optimization 2/GAUtilities.py\n\u001b[0;31mType:\u001b[0m      function\n"},"exec_count":46,"output_type":"execute_result","start":0}},"pos":88,"type":"cell"}
{"cell_type":"code","exec_count":47,"id":"6b4b35","input":"mut_prob = .8 #set high for demonstration\nind_prob = .5\nmut_pop = ga.shuffleMutation(cx_pop, mut_prob, ind_prob, True).astype(int)\nprint('Population before mutation')\nprint(cx_pop)\nprint('\\n\\nPopulation after mutation')\nprint(mut_pop)","output":{"0":{"name":"stdout","output_type":"stream","text":"Pop size: 4\nIndividual size: 6\nGene 1 in Individual 0 swapped with 0\nIndividual before\n [2 4 1 5 3 0]\nIndividual after\n [4 2 1 5 3 0]\nGene 3 in Individual 0 swapped with 2\nIndividual before\n [4 2 1 5 3 0]\nIndividual after\n [4 2 5 1 3 0]\nGene 4 in Individual 0 swapped with 5\nIndividual before\n [4 2 5 1 3 0]\nIndividual after\n [4 2 5 1 0 3]\nGene 0 in Individual 1 swapped with 0\nIndividual before\n [0 5 4 2 3 1]\nIndividual after\n [0 5 4 2 3 1]\nGene 3 in Individual 1 swapped with 0\nIndividual before\n [0 5 4 2 3 1]\nIndividual after\n [2 5 4 0 3 1]\nGene 4 in Individual 1 swapped with 2\nIndividual before\n [2 5 4 0 3 1]\nIndividual after\n [2 5 3 0 4 1]\nGene 5 in Individual 1 swapped with 3\nIndividual before\n [2 5 3 0 4 1]\nIndividual after\n [2 5 3 1 4 0]\nGene 0 in Individual 2 swapped with 4\nIndividual before\n [5 3 4 0 2 1]\nIndividual after\n [2 3 4 0 5 1]\nGene 1 in Individual 2 swapped with 1\nIndividual before\n [2 3 4 0 5 1]\nIndividual after\n [2 3 4 0 5 1]\nGene 2 in Individual 2 swapped with 3\nIndividual before\n [2 3 4 0 5 1]\nIndividual after\n [2 3 0 4 5 1]\nGene 3 in Individual 2 swapped with 0\nIndividual before\n [2 3 0 4 5 1]\nIndividual after\n [4 3 0 2 5 1]\nGene 4 in Individual 2 swapped with 1\nIndividual before\n [4 3 0 2 5 1]\nIndividual after\n [4 5 0 2 3 1]\nGene 5 in Individual 2 swapped with 3\nIndividual before\n [4 5 0 2 3 1]\nIndividual after\n [4 5 0 1 3 2]\nGene 0 in Individual 3 swapped with 3\nIndividual before\n [3 5 1 4 0 2]\nIndividual after\n [4 5 1 3 0 2]\nGene 1 in Individual 3 swapped with 2\nIndividual before\n [4 5 1 3 0 2]\nIndividual after\n [4 1 5 3 0 2]\nGene 2 in Individual 3 swapped with 0\nIndividual before\n [4 1 5 3 0 2]\nIndividual after\n [5 1 4 3 0 2]\nGene 3 in Individual 3 swapped with 2\nIndividual before\n [5 1 4 3 0 2]\nIndividual after\n [5 1 3 4 0 2]\nGene 4 in Individual 3 swapped with 2\nIndividual before\n [5 1 3 4 0 2]\nIndividual after\n [5 1 0 4 3 2]\nGene 5 in Individual 3 swapped with 0\nIndividual before\n [5 1 0 4 3 2]\nIndividual after\n [2 1 0 4 3 5]\nPopulation before mutation\n[[2 4 1 5 3 0]\n [0 5 4 2 3 1]\n [5 3 4 0 2 1]\n [3 5 1 4 0 2]]\n\n\nPopulation after mutation\n[[4 2 5 1 0 3]\n [2 5 3 1 4 0]\n [4 5 0 1 3 2]\n [2 1 0 4 3 5]]\n"}},"pos":89,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":48,"id":"d14775","input":"#review the documentation for ga.flipSegmentsMutation\n?ga.flipSegmentsMutation","output":{"0":{"data":{"text/plain":"\u001b[0;31mSignature:\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflipSegmentsMutation\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmut_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mind_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdebug\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;31mDocstring:\u001b[0m\nPerforms multiple random segment reversal on permutation populations\n\nParameters:\npop (numpy array, required):  The population, individuals\nmut_prob (real between 0 and 1, required): The probability an individual will mutate\nind_prob (real between 0 and 1, required): The probability a gene will be part of a segment reversal\n\u001b[0;31mFile:\u001b[0m      ~/Lessons/Lesson 07 - Global Optimization 2/GAUtilities.py\n\u001b[0;31mType:\u001b[0m      function\n"},"exec_count":48,"output_type":"execute_result","start":0}},"pos":91,"type":"cell"}
{"cell_type":"code","exec_count":49,"id":"01a15f","input":"mut_prob = 1 #set high for demonstration\nind_prob = .1\nmut_pop = ga.flipSegmentsMutation(cx_pop, mut_prob, ind_prob, True).astype(int)\nprint('pop before mutation')\nprint(cx_pop)\nprint('pop after mutation')\nprint(mut_pop)","output":{"0":{"name":"stdout","output_type":"stream","text":"pop before mutation\n[[2 4 1 5 3 0]\n [0 5 4 2 3 1]\n [5 3 4 0 2 1]\n [3 5 1 4 0 2]]\npop after mutation\n[[2 4 1 5 3 0]\n [0 5 4 2 3 1]\n [5 3 4 0 2 1]\n [3 5 1 4 0 2]]\n"}},"pos":92,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"0f0a65","input":"play_video(\"ds775_lesson5_genetic-alg-assembled\")","output":{"0":{"data":{"iframe":"bce8955f7215a244af40fe5ba523590213c83d18","text/plain":"<IPython.lib.display.IFrame at 0x7f0002b1caf0>"}},"1":{"data":{"text/html":"<a href = https://media.uwex.edu/content/ds/ds775_r19/ds775_lesson5_genetic-alg-assembled/index.html target = \"\"\"_blank\"\"\">Open video in new tab</a>","text/plain":"<IPython.core.display.HTML object>"},"exec_count":5,"output_type":"execute_result"}},"pos":52,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"42d63c","input":"np.random.seed(10101010) #for everything, everything, everything... (Courtesy of the Violent Femmes)\npop_size = 6 # should be even due to the way we'll implement crossover\nind_size = 3 #this is the number of genes in each individual\n\n#bounds are used for both real and integer problems. \n#For integer problems, the upper bound should be 1 over what you actually want\nbounds = [1,7]\n\n#each type of problem might use different types of populations. This one is a simple matrix of integers.\npop = np.random.randint(low=bounds[0], high=bounds[1], size =(pop_size,ind_size))","pos":10,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"e23e18","input":"# execute for video\nplay_video(\"ds775_lesson7_genetic-code-walkthrough\")","output":{"0":{"data":{"iframe":"2521b05d28b03396e8cfcd735f09fb0242470d7b","text/plain":"<IPython.lib.display.IFrame at 0x7fdee0d396a0>"},"exec_count":5,"output_type":"execute_result"},"1":{"data":{"text/html":"<a href = https://media.uwex.edu/content/ds/ds775_r19/ds775_lesson7_genetic-code-walkthrough/index.html target = \"\"\"_blank\"\"\">Open video in new tab</a>","text/plain":"<IPython.core.display.HTML object>"},"exec_count":5,"output_type":"execute_result"}},"pos":8,"type":"cell"}
{"cell_type":"code","exec_count":50,"id":"36f4b0","input":"# problem data and fitness function - DO NOT CHANGE\nnp.random.seed(123)\ntot_num_items = 1000 # should be divisible by 4\nnum_items = int(tot_num_items / 4)\nnum_groups = 4\nvalues = np.random.randint(10,100,size=num_items)\nvalues = np.hstack([values,values,values,values])\nnp.random.seed()\n\ndef group_fitness(groups,values,num_groups):\n    # groups must be a numpy array with ind_size entries (only one individual)\n    sums = np.array([ sum( values[ groups == i] ) for i in range(num_groups) ])\n    return max(sums)-min(sums)","pos":96,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"830b24","input":"play_video(\"ds775_lesson5_ordered-crossover\")","output":{"0":{"data":{"iframe":"6a6328b447c066dae03536433bff421329ab5f14","text/plain":"<IPython.lib.display.IFrame at 0x7f0002b1ca00>"}},"1":{"data":{"text/html":"<a href = https://media.uwex.edu/content/ds/ds775_r19/ds775_lesson5_ordered-crossover/index.html target = \"\"\"_blank\"\"\">Open video in new tab</a>","text/plain":"<IPython.core.display.HTML object>"},"exec_count":6,"output_type":"execute_result"}},"pos":81,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"e181e7","input":"pop","output":{"0":{"data":{"text/plain":"array([[2, 3, 4],\n       [3, 6, 4],\n       [2, 3, 4],\n       [6, 4, 5],\n       [6, 2, 5],\n       [4, 1, 2]])"},"exec_count":6,"output_type":"execute_result"}},"pos":12,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"9dcd39","input":"#see the documentation for the computeFitness function in the ga module\n?ga.computeFitness","output":{"0":{"data":{"text/plain":"\u001b[0;31mSignature:\u001b[0m \u001b[0mga\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcomputeFitness\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpop\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;31mDocstring:\u001b[0m\nComputes fitness based on passed in function.\n\nParameters:\nf (function, required): the function used to evaluate fitness\npop (numpy array, required): the population on which to evaluate fitness - individuals in rows.\n**kwargs (named arguments, optional): additional arguments that will be passed through to the fitness function\n\nReturns a numpy array of computed fitnesses.\n\u001b[0;31mFile:\u001b[0m      ~/Lessons/Lesson 07 - Global Optimization 2/GAUtilities.py\n\u001b[0;31mType:\u001b[0m      function\n"},"exec_count":7,"output_type":"execute_result","start":0}},"pos":14,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"ec9301","input":"#this is our objective function for this particular problem. Each problem requires a different objective function.\ndef obj_sumDice(x):\n    x = np.array(x) # force a numpy arrray here so that the math below works\n    return np.sum(x)\n\n#compute the fitness by passing in the function and population\nfitness = ga.computeFitness(obj_sumDice, pop)\n","pos":16,"type":"cell"}
{"cell_type":"code","exec_count":9,"id":"d64925","input":"fitness","output":{"0":{"data":{"text/plain":"array([ 9., 13.,  9., 15., 13.,  7.])"},"exec_count":9,"output_type":"execute_result"}},"pos":18,"type":"cell"}
{"cell_type":"markdown","id":"00c83c","input":"### Binary Variables\n\nBinary variables are a special case of integer variables with only 0 and 1 allowed.  \n\nIt is common to represent the binary variables as 0 and 1 or as False and True boolean variables.  Either one can be used in the homework.\n\n**Example Binary Variable Initialization:**\n\nThe following code demonstrates two ways to create binary populations.  Recall that when specifying a range of integers in Python most packages and data structures don't include the top number in the range.","pos":71,"type":"cell"}
{"cell_type":"markdown","id":"0300b3","input":"### Compute Fitness (again)\nIf we haven't already copied our population using elitism, we copy `mut_pop` into the original population `pop` and evaluate the fitness before returning to the start of the loop.","pos":49,"type":"cell"}
{"cell_type":"markdown","id":"05dd37","input":"#### Mutation for Real Variables\n\nGaussian Mutation is very common for real-valued variables.  First, we loop over the individuals in `cx_pop` and with probability `mut_prob` we mutate the individual.  If mutation occurs, we loop over the genes in each individual and with probability `ind_prob` we add a random number from a normal distribution with mean 0 and standard deviation `sigma`.  \n\nWe choose sigma by fitting six standard deviations in the range of each variable from lower to upper bounds (this is a guideline; smaller or larger mutations could be used and can definitely alter the behavior of the search).  \n\nWe'll also clip each mutated individual to stay inside the bounds.  Usually we'll set `mut_prob` to a value like 0.1 or 0.2, but we'll run it below with `mut_prob = 1.0` so we can see spot some mutations.\n\nOur function for this is called `gaussianMutation`. To see a definition of the function, run the code in the cell below.\n","pos":59,"type":"cell"}
{"cell_type":"markdown","id":"061392","input":"*Note that we use this function for both real numbers and integers. For integer problems, you'll want to cast the results to an integer.*","pos":34,"type":"cell"}
{"cell_type":"markdown","id":"08b90e","input":"### Elitism (optional)\nElitism is an optional step. On a problem this small, elitism isn't necessary. But on larger problems, elitism can help if you're finding that it's difficult to converge on a good solution. Elitism ensures that the best individuals from the beginning of each generation (each loop) pass on to the next generation unchanged. You don't want more than about 5% of your population to pass through unchanged, or you risk not doing enough exploration.\n\nImplementing elitism is simple. If you use elitism, you simply replace the `pop = mut_pop.copy()` step with `pop = ga.addElitism(pop, mut_pop, num_elite)`. Let's look at the population when we run elitism. What you should see is that the individual in the first slot is the same individual we had after we sorted our initial population.","pos":46,"type":"cell"}
{"cell_type":"markdown","id":"0adf93","input":"If you don't see some reversed segments in the mutated population, try running the cell again.","pos":93,"type":"cell"}
{"cell_type":"markdown","id":"0dc376","input":"#### *Self-Assessment:  Mutation Parameters:*\n\n* What is the effect of `mut_prob = 1`?\n* What is the effect of `mut_prob = 0`?\n* What is the effect of increasing `ind_prob`?\n","pos":45,"type":"cell"}
{"cell_type":"markdown","id":"1a9cc4","input":"### Real Variable Complete Example - Sphere\nMany real variable functions are used as <a href=\"https://en.wikipedia.org/wiki/Test_functions_for_optimization\">test functions</a> to assess the performance of optimization algorithms. You've already seen one of those - the Rastrigin function. Let's look at another one, the Sphere function. Like Rastrigin, the global minima of 0 occurs when all the decision variables are zero. The function is written out like this:\n\n\n$$ sphere = \\sum_{i=1}^{n} x_{i}^2 \\ ; \\ -100 \\leq x_i \\leq 100 \\ $$\n\nIt's a very simple function. It's simply the sum of the square of the decision variables within bounds evenly spaced around zero. Here we've used -100 to 100, but any evenly spaced numbers will do.\n\nWith the following code, we'll demonstrate a few concepts.\n\n1. We'll demonstrate using lists of our parameters to easily step through a grid of parameter options.\n2. We'll demonstrate a complete real variable genetic algorithm.\n3. We'll demonstrate using local optimization at the completion of the algorithm to further optimize the function.\n\nFirst let's visualize Sphere in one and 2 dimensions.\n","pos":62,"type":"cell"}
{"cell_type":"markdown","id":"1c8fee","input":"Just like with selection, we've written a helper function that allows you to easily do crossover. The helper function expects the selected population, the crossover probability, and if you want to show debugging, then pass in `debug=True`.","pos":32,"type":"cell"}
{"cell_type":"markdown","id":"20ff30","input":"Mutations are commonly called \"flipping a bit\" because 0's are toggled to 1's and 1's to 0's.  In a bit flipping mutation each variable is randomly switched with probability `ind_prob`.\n\nThe helper function for this is called bitFlipMutation. It takes in the population, the mut_prob, the ind_prob and an optional debug flag.","pos":75,"type":"cell"}
{"cell_type":"markdown","id":"224674","input":"Genetic algorithms are another example of metaheuristic global optimization. Think of a genetic algorithm as a smart version of random search.  Genetic algorithms are great at exploring large search spaces, but sometimes aren't so good at zeroing in on a solution once they've gotten close to a good solution.\n\nYou should have read about the basics of genetic algorithms in the textbook.  Genetic algorithms are a vast subject, and we'll just scratch the surface.  Fortunately, there seem to be tons of free tutorials and other resources available for learning more about genetic algorithms.  The pseudocode for a genetic algorithm is as follows:\n```\ngenerate the initial population\ncompute fitness\nrepeat\n    selection\n    crossover\n    mutation\n    elitism (optional)\n    compute fitness\nuntil population has converged\n```\n\nHere are just a few notes about the algorithm:\n* population = set of trial solutions that are also called individuals (or chromosomes)\n* fitness = objective function\n* selection = choosing the most promising solutions in the current population but leaving a few bad ones for diversity\n* crossover = combining or breeding the selected solutions to generate new candidate solutions\n* mutation = randomly tweaking some solutions in the current population to encourage exploration of the solution space\n\nIn terms of the **exploration and exploitation tradeoff** one can think of selection as being exploitation (local search) and crossover and mutation as being exploration (global search).  Changing the parameters used in selection, crossover, and mutation changes the balance between exploration and exploitation.\n\n\nWe will write our own genetic algorithm so that we can get a better understanding of their ingredients.  Before we dive into the details, we summarize some packages you could explore to apply genetic algorithms to your optimization problems.\n\n## Population Based Algorithms\n\nGenetic algorithms are an important example of a population based algorithm.  Note that in the previous methods we've studied:  local search, simulated annealing, and Bayesian optimization, we focus on updating a single point by using historical information from previous points.  In a population based algorithm, a set of points, called a population, is iteratively updated together to progress toward an optimal point.  In a genetic algorithm, rules inspired by natural evolution are used to update the population of potential solutions.  There are also many other population based algorithms such as Particle Swarm Optimization, Differential Evolution, and Evolution Strategies, where the latter includes genetic algorithms.  Genetic algorithms are a very flexible and popular population based method that can work over many problems and variable types.  <a href=\"https://bdataanalytics.biomedcentral.com/articles/10.1186/s41044-016-0003-3\">Here is a survey</a> of population based optimization algorithms in data science if you'd like to explore further on your own.\n\n## Genetic Algorithm Packages\n\nIf you need to use genetic algorithms in practice, it's probably better to seek out a package that has that functionality.  Some options include:\n* <a href=\"https://github.com/deap/deap\" target=\"_blank\">The `DEAP` package</a>.  This package is for genetic programming.  It's very powerful and flexible, but also abstract with a significant learning curve.  It's worth learning if you often need to use genetic algorithms or other types of evolutionary algorithms.\n* <a href=\"https://pypi.org/project/geneticalgorithm/\" target=\"_blank\">The `geneticalgorithm` package</a> This package is an easy to use, but limited, genetic algorithm for minimization.  It supports either real or integer variables.  It can't be used for problems with permutations such as TSP.  Also, the objective function can have only one argument so if you need additional data (e.g. the distance matrix) the function will have to find the data in the global scope.  It's slow with the default settings.\n* The `deap_wrapper` package.  This is something we've been working on but at the moment it's not a well documented package.  If you're curious, you can see examples of how to use it in the notebook `deap_wrapper_examples.ipynb` in the same folder as this lesson.\n* The `GA` package in R.  This is a really easy to use implementation of the genetic algorithms that handles several types of variables.  Documentation is <a href=\"https://cran.r-project.org/web/packages/GA/\" target=\"_blank\">here on CRAN</a>.  In our experience this is a lot easier to use than `DEAP`.  The notebook `Genetic_Algorithm_with_R.ipynb` gives an example and shows how you can include R in a Python Jupyter notebook (it's pretty cool).\n\n**For more help go here:** A fantastic place to get more details about genetic algorithms and the various bits and pieces is this <a href=\"https://www.tutorialspoint.com/genetic_algorithms/index.htm\" target=\"_blank\">free online tutorial at tutorialspoint.com.</a>\n","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"245f4d","input":"About 80% of individuals in `cx_pop` should now be children with crossovers.  We'll print out the members of the population before and after crossover to see what happened.  If crossover occurred then the right part of each pair should stay the same while the left part of each pair gets swapped.  Compare the parents in rows 0 and 1 with the children in rows 0 and 1. You should be able to see where the crossover happened. ","pos":36,"type":"cell"}
{"cell_type":"markdown","id":"25b791","input":"The next cell contains code (also discussed in the video) that demonstrates ordered crossover.","pos":82,"type":"cell"}
{"cell_type":"markdown","id":"319e2d","input":"Let's print out the population to see what we have. Remember, each row is an individual, and each value within that row represents each decision variable in that individual.","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"32a114","input":"### Selection\n\nWe want to select the fittest individuals from the population for breeding (crossover and mutation), but we also want to maintain diversity in the population so that breeding produces a variety of offspring to encourage exploration of the search space. Unlike in real breeding, our population size will remain constant, so our selected individuals will replace the initial individuals in the population. (Note: more sophisticated algorithms allow the population size to fluctuate.)\n\nWe'll implement **tournament selection** where we'll first choose a subset of individuals from the population and then select the fittest member of that subset for the new population.  The number of individuals in each subset is called the tournament size.  The larger the size of the tournament, the more likely that only the fittest members of the population are selected for the next generation.  Small tournament sizes mean that less fit individuals have a chance to be selected.  We'll use a `tourn_size = 2`.  You can read a bit about other selection operators in any genetic algorithms textbook.  A small explanation about some selection operators can be found on <a href=\"https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)#d._Tournament_Selection\">Wikipedia.</a>\n\nTo do our implementation of tournament selection, first we have to sort our population by fitness. We've made that easy to do with a single line of code.","pos":20,"type":"cell"}
{"cell_type":"markdown","id":"35beca","input":"As you can see, the Sphere function simply makes the bottom half of a sphere. But it's extensible into many dimensions, just like Rastrigin is. Let's create our objective function for Sphere with any number of dimensions, and test it with a couple of numpy arrays.","pos":65,"type":"cell"}
{"cell_type":"markdown","id":"376667","input":"If you look at the fitness values from the original population and the selected population fitness values, you should notice that there are fewer large values and more small values in the selected population.  You may also see that there are repeated values because the fittest individuals may be selected more than once.  That's selection in action.","pos":27,"type":"cell"}
{"cell_type":"markdown","id":"3b663d","input":"### Dice Game Code\n\nLet's see how our game translates into code. We'll break it down in just a bit, but first, let's take a look at the complete algorithm. Go ahead and run this code multiple times to see how quickly the genetic algorithm finds the optimal solution.  (Note:  this uses code we've supplied in `GAUtilities.py` which is in the same directory as this notebook and is loaded in the first cell of the notebook.)","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"3c5a91","input":"Once we've sorted our population, we'll randomly choose 2 integers between 0 and the population size, (say 3 and 6) and have a tournament between those two individuals.  Since the individual in row 3 is the fittest (in the sorted population) we'll select that individual.\n\nTo do the tournament selection, you can simply call our tournament selection helper function. The function has a parameter called \"debug.\" If we run it with `debug=True`, we can see which individuals went competed in a tournament, and of those, which were selected.","pos":23,"type":"cell"}
{"cell_type":"markdown","id":"458c97","input":"If everything is working well, then the fitness of the population should be generally be decreasing, but it's hard to tell if that is the case by looking at the fitness values from one iteration of the genetic algorithm.\n\n### Putting it Together\n\nFor our loop we'll just iterate a fixed number of times.  A more sophisticated genetic algorithm would monitor the convergence and use a dynamic stopping criteria.  Our implementation is not particularly efficient since the code was written for transparency and not efficiency ... this may be slow with large problems!\n\nThe goal for our genetic algorithm code is to increase your understanding of the genetic algorithm, not write code for a production setting. In practice, we should have a master function to run the algorithm.  Or better still would be to use a package such as `DEAP` or `GA` in the R world.\n\nThe video in the next cell gives an overview of the \"putting-it-together\" code:","pos":51,"type":"cell"}
{"cell_type":"markdown","id":"461ba9","input":"### Tuning your Genetic Algorithm\nIn addition to using different selection, crossover, and mutation approaches, we can also tune our genetic algorithm by changing the values of various parameters used in the algorithm. Below is a table that lists the parameters and which ones can be tuned.\n\n#### Adjustable Parameters Overview\n\n\n<table >\n\t<tbody>\n\t\t<tr>\n            <td><b>parameter</b></td>\n            <td><b>variable name</b></td>\n            <td><b>lower bound</b></td>\n            <td><b>upper bound</b></td>\n            <td><b>typical value(s)</b></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>population size</td>\n\t\t\t<td><code>pop_size</code></td>\n\t\t\t<td>2</td>\n\t\t\t<td>none</td>\n\t\t\t<td>number of variables * (5 to 20)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>individual size</td>\n\t\t\t<td><code>ind_size</code></td>\n\t\t\t<td>NA</td>\n\t\t\t<td>NA</td>\n\t\t\t<td>always = number of variables</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>lower bound for real var.</td>\n\t\t\t<td><code>lower</code></td>\n\t\t\t<td>NA</td>\n\t\t\t<td>NA</td>\n\t\t\t<td>problem dependent</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>upper bound for real var. </td>\n\t\t\t<td><code>upper</code></td>\n\t\t\t<td>NA</td>\n\t\t\t<td>NA</td>\n\t\t\t<td>problem dependent</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>tournament size for selection</td>\n\t\t\t<td><code>tourn_size</code></td>\n\t\t\t<td>1</td>\n\t\t\t<td><code>pop_size</code></td>\n\t\t\t<td>3 to 5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>crossover probability</td>\n\t\t\t<td><code>cx_prob</code></td>\n\t\t\t<td>0.0</td>\n\t\t\t<td>1.0</td>\n\t\t\t<td>0.8</td>\n\t\t</tr>\n        <tr>\n\t\t\t<td>mutation probability</td>\n\t\t\t<td><code>mut_prob</code></td>\n\t\t\t<td>0.0</td>\n\t\t\t<td>1.0</td>\n\t\t\t<td>0.2</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>single var. mutation prob.</td>\n\t\t\t<td><code>ind_prob</code></td>\n\t\t\t<td>0.0</td>\n\t\t\t<td>1.0</td>\n\t\t\t<td>0.05 to 0.1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>real var. mutation size</td>\n\t\t\t<td><code>sigma</code> </td>\n\t\t\t<td>0.0</td>\n\t\t\t<td>none</td>\n\t\t\t<td>(upper-lower)/6</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>number of iterations</td>\n\t\t\t<td><code>num_iter</code></td>\n\t\t\t<td>1</td>\n\t\t\t<td>none</td>\n\t\t\t<td>problem dependent</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>update to screen interval</td>\n\t\t\t<td><code>update_iter</code></td>\n\t\t\t<td>1</td>\n\t\t\t<td><code>num_iter</code></td>\n\t\t\t<td><code>num_iter/20</code></td>\n\t\t</tr>\n\t</tbody>\n</table>\n","pos":94,"type":"cell"}
{"cell_type":"markdown","id":"463d68","input":"Reminder: we use the prefix `obj_` to identify objective functions. In the genetic algorithm world, our objective functions determine the `fitness` of each individual.","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"4b3049","input":"#### *Self-Assessment:  Crossover probability*\nWhat happens if `cx_prob = 0`?  What happens if `cx_prob=1`? ","pos":39,"type":"cell"}
{"cell_type":"markdown","id":"502117","input":"## Genetic Algorithm Step by Step\n\nWe'll write a genetic algorithm to minimize a simple dice toss game. In our game, we want to get the lowest possible total in a toss of three dice. Before we look at code, let's first introduce the concepts of genetic algorithms with a hands-on version of our game.","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"562903","input":"**Example Permutation Variable Mutation - Reversing Segments**\n\nWhile shuffling indices is common, it doesn't work especially well for the Traveling Salesman Problem that you'll encounter in the homework (see <a href=\"https://arxiv.org/pdf/1203.3099.pdf\">this paper</a> for more info).\n\nThe mutation is very similar to the `sub_tour_reversal` that we used with simulated annealing and local search, but for the genetic algorithm there may be multiple reversed segments since we loop over the cities in the tour and use it as an endpoint of reversed segment with probability `ind_prob.`\n\nWe've created a function for you called `flipSegmentsMutation` that takes in the population, the mut_prob, the ind_prob, and the optional debug flag and returns the mutated population.","pos":90,"type":"cell"}
{"cell_type":"markdown","id":"68cd05","input":"#### Self Assessment: Using Maximization with GA\n\nOur genetic code only performs minimization. It's common with optimization code to only optimize in one direction - either maximizing or minimizing. It's easy for people using the algorithm to switch the direction of the optimization by altering the objective function. Alter the objective function above to maximize the sum of the dice.","pos":19,"type":"cell"}
{"cell_type":"markdown","id":"69a523","input":"#### *Self-Assessment:  Exploring Tournament Selection*\n\nTry running the tournament selection code above with both smaller and larger tournament sizes.  What happens for smaller tournament sizes?  For larger tournament sizes?  For tournament size 1?  What if the tournament size the same as the population size?  How does tournament size impact selection? (Feel free to make a bigger population to play with.)\n","pos":29,"type":"cell"}
{"cell_type":"markdown","id":"6b2005","input":"### Permutation Variables \n\nPermutations are sets of unique numbers in which order matters. These can come from problems where we are looking for the best order for a process of some kind.  For instance, in the Traveling Salesperson Problem we are trying to find the order to visit cities 1 through 7 (and back to 1) that minimizes the total distance traveled.  The crossover and mutation operators we've discussed so far don't work in this situation. And, initializing the population is slightly different as well.\n\n**Example Permutation Variable Initialization**\n\nFor this example, we'll make a population of 4 individuals, with permutations from 0 to 5 in each row.","pos":78,"type":"cell"}
{"cell_type":"markdown","id":"6e3f04","input":"This is a relatively easy problem for the genetic algorithm to solve. You can see that even with this small population, it takes less than 200 iterations to solve. We're solving a small problem so it's easier to demonstrate the code to you step-by-step. If you'd like to experiment with solving a larger problem, increase the individual size. You'll most likely need to also increase the population size and number of iterations, as well. You can also tinker with the various probabilities to increase or decrease the randomness (exploration).\n\n## GA Steps\nLet's take a look at what's happening in each step, starting with initialization.\n\n### Generate the Initial Population\nWe'll have an initial population of 6 individuals (sometimes called chromosomes), each with 3 genes (or decision variables). We're using numpy arrays extensively in this lesson. All of your populations should be numpy arrays.\n\nIn each population, the individuals are stored as the rows of the array, and the columns represent each gene in each individual.","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"6fe872","input":"Now watch this video where we step through the code above","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"750ac8","input":"# Lesson 7 - Global Optimization 2 - Genetic Algorithms","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"7661dd","input":"We can add a local minimization routine at the end of our algorithm to further fine-tune our results. We use scipy optimize's minimize function to incorporate local search. We'll use \"best_x\" as our starting point and do another local optimization.","pos":69,"type":"cell"}
{"cell_type":"markdown","id":"7fc129","input":"To visualize the mutations we'll print out the difference between the crossover population and the new mutated population.  Most of the differences should be zero, but approximately 25% will differ:","pos":43,"type":"cell"}
{"cell_type":"markdown","id":"8359c1","input":"## Other Problem Types\nSo far, we've only looked at problems that use integers in no particular order (combinatorial problems). But genetic algorithms can solve problems with real (floating point) numbers, booleans, and permutations (integers in a particular order). \n\nTournament Selection can be used for any problem type. Other kinds of selection are possible, but we've found tournament selection to work well in practice.  Choosing small tournament sizes (> 1) leads to a more diverse selection process, while large tournament sizes tend to promote only the fittest members of the population.  We won't discuss other selection operators in the lesson, but you will learn about one other selection operator in the homework.\n\nWe will need to use different initialization, crossover and mutation approaches for different problem types. Not all possible types are addressed, but we will cover a few that you'll use in the homework.\n\n### Real Variables\n\n#### Initialization of Real Variables\n\nInitializing with real numbers is almost as simple as initializing with integers, but instead of using numpy's <a href=\"https://numpy.org/doc/stable/reference/random/generated/numpy.random.randint.html\">random.randint</a> function, we'll use the <a href=\"https://numpy.org/doc/stable/reference/random/generated/numpy.random.uniform.html\">random.uniform</a> function. This function requires a lower and upper bound, and the pop_size and ind_size numbers to make the rows and columns of the array.","pos":53,"type":"cell"}
{"cell_type":"markdown","id":"860b69","input":"#### *Self-Assessment:  Genetic Algorithm for the Value Balancing Problem*\n\nFor this problem we'll apply the genetic algorithm to the Value Balancing Problem we visited in Lessons 5 and 6.  In the cell below we have the code for creating the values of 1000 items and also the fitness function we're trying to minimize.  Mimic the genetic algorithm from above to minimize the differences in the total values \n\nTo make the genetic algorithm work, you'll need to pay attention to the following:\n* The initial population should be individuals of length 1000 (`tot_num_items`) each having integer values between 0 and 3 with repeats allowed (there are `num_groups = 4` box cars to sort items into).  Use `numpy.random.randint`\n* You can use onePointCrossover to mate individuals.  That part of the code doesn't need to change at all.  \n* Use the uniformIntMutation() for mutation.\n* Pay attention to the order of parameters in your objective function. Note that our algorithm expects the X values first, and any other parameters can be passed in as named variables.\n* The objective function is `group_fitness` and is provided below for convenience along with code to generate a set of values that can be perfectly balanced for testing.\n* Consider reducing the tot_num_items for testing your algorithm so the code runs faster.  Remember to push it back to 1000 for your final runs.\n* Experiment with the algorithm parameters.  Can you find parameters that routinely achieve minimum fitness $\\leq 20.$","pos":95,"type":"cell"}
{"cell_type":"markdown","id":"8613ed","input":"Calling it is simple. It expects the population, the cx_prob, the alpha value, the bounds (as an array) and an optional debug parameter.)","pos":57,"type":"cell"}
{"cell_type":"markdown","id":"8ef3c4","input":"We provided an orderedCrossover function for you to call. It takes in the population, the cx_prob, and the debug flag, and returns the crossed population. ","pos":84,"type":"cell"}
{"cell_type":"markdown","id":"972d46","input":"### Compute Fitness\n\nWe want to apply the objective function to each individual or row in the numpy array `pop`. \n\nWe've created a helper function that let's you compute the fitness. It takes in the fitness function, the population, and any other keyword arguments you might need. A keyword argument is a named argument, such as `dist_mat=dist_mat`. You won't need any keyword arguments for this problem, but you will for other problems. All of our functions are documented, and you can read the documentation by putting a ? before the function name in a code cell and running it. Try it below.","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"a24241","input":"**Example Binary Variable Mating/Crossover**\n\nOne Point Crossover is common here. Remember to return your values as booleans.","pos":73,"type":"cell"}
{"cell_type":"markdown","id":"baedcf","input":"### Mutation\nFor integer problems like the dice game, we can use a very simple type of mutation, called Uniform Integer Mutation. In this type of mutation, if the probability of mutation for an individual is met, we look at each gene (decision variable) in the individual. If the probability that gene will mutate is met, we draw a new random integer from the range of allowable integers to replace the gene.\n\nOnce again, we have a helper function in our `gautilities` module. We have a few more parameters to pass to this function. It expects the cx_population, bounds, mut_prob, and ind_prob. Again, you can pass `debug=True` to get some print statements.","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"bffff1","input":"### Crossover (Mating)\n\nAt this point, the individuals in `select_pop` are in a random order after selection (if they weren't then we should shuffle them before continuing) so we're going to loop over pairs of individuals and with probability `cx_prob = 0.8` each pair will produce a pair of offspring using <a href=\"https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)\"> One Point Crossover </a> (<a href=\"https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)\">other kinds of crossover</a> are possible too) We randomly choose a \"crossover point\" and swap the two pieces of the two individuals.  The image below illustrates this nicely:\n\n<img src=\"./images/OnePointCrossover.png\" width=400>\n\nIn the next cell is a bit of Python that illustrates how One Point Crossover works when the crossover point is 3.","pos":30,"type":"cell"}
{"cell_type":"markdown","id":"c5ac90","input":"You can see from the fitness values above, the more genes each individual has (the larger the ind_size) the larger the base fitness is. If the goal is to get a fitness of zero, you can see that it will be more challenging the more dimensions we incorporate. It will take longer for our code to run, and we're less likely to find the global optimum.\n\nLet's look at using lists of parameters to make developing our code more user-friendly. We'll have an initial parameter at index 0 that uses a small population and a small individual to develop our code. Then we can \"turn up the dial\" once we have working code, by changing the index variable.","pos":67,"type":"cell"}
{"cell_type":"markdown","id":"c7ac1c","input":"**Example Permutation Variable Crossover - Ordered Crossover**\n\nA commonly used form of crossover is called Ordered Crossover in which two subsequences are swapped between the parents and the remainder of the variables filled in by preserving the order of variables.  The video below gives an example of how this works.","pos":80,"type":"cell"}
{"cell_type":"markdown","id":"c93365","input":"Let's print out the fitness values. These correspond to each row in our population. We have six rows (6 individuals) and each one has a fitness value.","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"e3e230","input":"Since this is an integer problem, we cast the result to integers using .astype(int). If you did not add this code, you would receive floats back.\n\n*Note: debug is great if you're doing a small problem. If you use debug=True on a large problem, you will have a lot of output. You can just call the function without debug passed in, as the default is False.)*","pos":25,"type":"cell"}
{"cell_type":"markdown","id":"e7b8fd","input":"#### Crossover\n\nOne Point Crossover will work with real variables, but it is not as common as Blended Crossover for real variable optimization.  In Blended Crossover, or BX$\\alpha$-crossover, each new variable in the resulting child is chosen from an interval that overlaps the two parents.  The following picture helps explain it:  \n\n<img src=\"images/blended_crossover.png\" width = 400>\n\nLet $x_i$ and $y_i$ be the variables from the two parents with $x_i < y_i$.  The idea is to sample uniformly from an interval that includes $x_i$ and $y_i$ but is expanded by, for example 20%, in each direction.  The exact amount of expansion is determined by the parameter $\\alpha$ which is usually between 0 and 1.  Values of $\\alpha$ are typically around 0.1 or 0.2.  \n\nFor each new variable, $z_i$ in the child here is the algorithm:\n1.  extract the corresponding variables $x_i$ and $y_i$ from the parents\n2.  find the min and max of $x_i$ and $y_i$ then range = $|x_i - y_i|$\n3.  the new variable $z_i$ is a random uniform number in the range [ min - $\\alpha$ * range, max + $\\alpha$ * range]\n\nSo if a pair of parents is randomly selected to mate, then form two children by looping (twice) over the parent variables and following the algorithm above for each pair.\n\nBlended Crossover seems to work better than One Point Crossover for problems with real variables.\n\nWe've written a helper function for Blended Crossover. Feel free to review the code in the GaUtilities.py file in this directory to see it. ","pos":55,"type":"cell"}
{"cell_type":"markdown","id":"fc61a6","input":"**Example Permutation Variable Mutation - Shuffling Indices**\n\nFor mutation of permutation variables it is common to use Shuffling Indices.  To do so just make a copy of the individual then loop over each variable and with probability `ind_prob` swap it with another randomly selected variable in the individual.  It's possible that you may end up swapping a variable with itself, but that's OK.\n\nWe've created a function for you called `shuffleMutation` that takes in the population, the mut_prob, the ind_prob, and the optional debug flag and returns the mutated population.","pos":87,"type":"cell"}
{"id":0,"time":1683513139551,"type":"user"}
{"last_load":1683588860888,"type":"file"}