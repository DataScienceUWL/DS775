{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-a75b24ef-0cc4-44c0-8a27-57861395b3a6.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"},"toc":{"base_numbering":1,"nav_menu":{},"number_sections":true,"sideBar":true,"skip_h1_title":false,"title_cell":"Table of Contents","title_sidebar":"Contents","toc_cell":false,"toc_position":{},"toc_section_display":true,"toc_window_display":true}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1661540148793,"exec_count":1,"id":"b2d27a","input":"# imports\nimport GAUtilities as ga\nimport numpy as np\nimport pandas as pd\nfrom simanneal import Annealer\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style(\"darkgrid\")\nfrom scipy.optimize import minimize\nimport random\nimport warnings\nwarnings.filterwarnings('ignore')\nfrom time import time","kernel":"python3","metadata":{"code_folding":[]},"no_halt":true,"pos":0,"start":1661540147671,"state":"done","type":"cell"}
{"cell_type":"code","end":1661540148815,"exec_count":2,"id":"ee402f","input":"np.random.seed(10101010) #for everything, everything, everything... (Courtesy of the Violent Femmes)\npop_size = 6 # should be even due to the way we'll implement crossover\nind_size = 3 #this is the number of genes in each individual\n\n#bounds are used for both real and integer problems. \n#For integer problems, the upper bound should be 1 over what you actually want\nbounds = [1,7]\n\n#each type of problem might use different types of populations. This one is a simple matrix of integers.\npop = np.random.randint(low=bounds[0], high=bounds[1], size =(pop_size,ind_size))\n\n#this is our objective function for this particular problem. Each problem requires a different objective function.\ndef obj_sumDice(x):\n    x = np.array(x) # force a numpy arrray here so that the math below works\n    return -np.sum(x)\n\n#compute the fitness by passing in the function and population\nfitness = ga.computeFitness(obj_sumDice, pop)\n\nfitness","kernel":"python3","metadata":{"hidden":true},"no_halt":true,"output":{"0":{"data":{"text/plain":"array([ -9., -13.,  -9., -15., -13.,  -7.])"},"exec_count":2}},"pos":2,"start":1661540148801,"state":"done","type":"cell"}
{"cell_type":"code","end":1661540148867,"exec_count":3,"id":"717236","input":"#calling np.sum directly without our wrapper function\nfitness = ga.computeFitness(np.sum, pop)\nfitness","kernel":"python3","metadata":{"hidden":true},"no_halt":true,"output":{"0":{"data":{"text/plain":"array([ 9., 13.,  9., 15., 13.,  7.])"},"exec_count":3}},"pos":4,"start":1661540148819,"state":"done","type":"cell"}
{"cell_type":"code","end":1661540149066,"exec_count":4,"id":"8c252f","input":"#negating np.sum for a maximization problem.\nfitness = np.negative(ga.computeFitness(np.sum, pop))\nfitness","kernel":"python3","metadata":{"hidden":true},"no_halt":true,"output":{"0":{"data":{"text/plain":"array([ -9., -13.,  -9., -15., -13.,  -7.])"},"exec_count":4}},"pos":6,"start":1661540148960,"state":"done","type":"cell"}
{"cell_type":"code","end":1661540149181,"exec_count":5,"id":"2d6808","input":"# problem data and fitness function - DO NOT CHANGE\nnp.random.seed(123)\ntot_num_items = 1000 # should be divisible by 4\nnum_items = int(tot_num_items / 4)\nnum_groups = 4\nvalues = np.random.randint(10,100,size=num_items)\nvalues = np.hstack([values,values,values,values])\nnp.random.seed()\n\ndef group_fitness(groups,values,num_groups):\n    # groups must be a numpy array with ind_size entries (only one individual)\n    sums = np.array([ sum( values[ groups == i] ) for i in range(num_groups) ])\n    return max(sums)-min(sums)","kernel":"python3","no_halt":true,"pos":11,"start":1661540149151,"state":"done","type":"cell"}
{"cell_type":"code","end":1661540191819,"exec_count":6,"id":"17d2e1","input":"## Solution Code for Genetic \n\n# genetic algorithm parameters\npop_size = 1000 # should be even due to the way we'll implement crossover\nind_size = tot_num_items # determines number of input variables for each individual\ntourn_size = 5 # tournament size for selection\ncx_prob = 0.8 # probability a pair of parents crossover to produce two children\nmut_prob = 0.1 # probability an individual mutates\nind_prob = 0.01 # probability each variable in an individual mutates\nnum_iter = 100 # number of genetic algorithm mutations\nupdate_iter = 10 # how often to display output\nnum_elite = 10 # number of elite individuals to save each generation\nfitness_fun = group_fitness # change this to the fitness function for your problem\n\n#np.random.seed(121)  # set seed here for reproducibility (you can change this number to explore)\n\ntime_start = time()  # record start time to compute time elapsed at the end\n\n#initialize population and fitness\npop = np.random.randint(low=0, high=num_groups, size = (pop_size,ind_size))\n\n#note how we're passing named parameters into the computeFitness function\nfitness = ga.computeFitness(fitness_fun, pop, values = values, num_groups = num_groups)\n\n# initialize stats and output\nstats, best_fitness, best_x = ga.initStats(fitness, pop, num_iter)\n\n#This is where the guts of the algorithm start\nfor iter in range(num_iter):\n    #sort the population\n    pop = ga.sortPop(pop, fitness)\n    \n    # tournament selection\n    selected_pop = ga.tournamentSelection(pop, tourn_size).astype(int)\n    \n    # one-point crossover (mating)\n    cx_pop = ga.onePointCrossover(selected_pop, cx_prob).astype(int)\n\n    # uniform int mutation\n    mut_pop = ga.uniformIntMutation(cx_pop, mut_prob, ind_prob, [0, num_groups]).astype(int) \n\n    # elitism\n    pop = ga.addElitism(pop, mut_pop, num_elite)\n    \n    # evaluate fitness on new populatoin\n    fitness = ga.computeFitness(fitness_fun, pop, values = values, num_groups = num_groups )\n\n    # collect stats and output to screen\n    stats, best_fitness, best_x = ga.updateStats(stats, fitness,best_x, pop, iter, update_iter)\n\ntime_elapsed = time() - time_start\n    \n#####################\n# Everything in the algorithm is done, and now we're just outputting the final result\n#####################\nprint(f\"The minimized maximum difference between value totals is {best_fitness:.0f}\")\nprint(f\"The total time elapsed is: {time_elapsed:0.2f}\")\n\nprint(f\"The total number of function evaluations is: {(num_iter+1)*pop_size:.0f}\")","kernel":"python3","metadata":{"code_folding":[]},"no_halt":true,"output":{"0":{"name":"stdout","text":"Iteration | Best this iter |    Best ever\n"},"1":{"name":"stdout","text":"        1 |      1.170e+02 |    1.170e+02\n"},"10":{"name":"stdout","text":"       90 |      1.500e+01 |    1.500e+01\n"},"11":{"name":"stdout","text":"      100 |      1.500e+01 |    1.500e+01\nThe minimized maximum difference between value totals is 15\nThe total time elapsed is: 42.55\nThe total number of function evaluations is: 101000\n"},"2":{"name":"stdout","text":"       10 |      4.800e+01 |    4.800e+01\n"},"3":{"name":"stdout","text":"       20 |      2.100e+01 |    2.100e+01\n"},"4":{"name":"stdout","text":"       30 |      2.100e+01 |    2.100e+01\n"},"5":{"name":"stdout","text":"       40 |      2.100e+01 |    2.100e+01\n"},"6":{"name":"stdout","text":"       50 |      1.500e+01 |    1.500e+01\n"},"7":{"name":"stdout","text":"       60 |      1.500e+01 |    1.500e+01\n"},"8":{"name":"stdout","text":"       70 |      1.500e+01 |    1.500e+01\n"},"9":{"name":"stdout","text":"       80 |      1.500e+01 |    1.500e+01\n"}},"pos":12,"start":1661540150175,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"2df032","input":"Because our fitness function is so simple, and because we know that we're always using numpy arrays, we could also just pass numpy's sum function directly to our helper function like this, to get the minimization fitnesses.","metadata":{"hidden":true},"pos":3,"type":"cell"}
{"cell_type":"markdown","id":"54be75","input":"# *Self-Assessment:  Genetic Algorithm for the Value Balancing Problem*","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"553004","input":"# *Self-Assessment:  Crossover probability*\n\n* *What happens if `cx_prob = 0`?* No mating occurs so there is no sharing of information between individuals.  This would result in a population of parallel random local searches.\n\n* *What happens if `cx_prob=1`?*  Every pair of individuals mates, this means that there is no chance that a very good solution survives more than one generation unless it happens to mate with a copy of itself.","metadata":{"heading_collapsed":true},"pos":8,"type":"cell"}
{"cell_type":"markdown","id":"63e043","input":"# *Self-Assessment: Mutation Parameters:*\n\n* *What is the effect of `mut_prob = 1`?*  Every individual is mutated.\n* *What is the effect of `mut_prob = 0`?*  No individuals are mutated so the genetic algorithm uses only mating to improve the population.\n* *What is the effect of increasing `ind_prob`?*  Larger values mean more changes in the individual.\n* *What would happen if you made `sigma` really large?*  The mutations could result in very large steps which could make the search behave erratically.  Mutated individuals might have very little in common with their parents.  Large exploration and small exploitation.\n* *What would happen if you made `sigma` really small?*  The steps would be very small so the search remains very local.  Small exploration and large exploitation.","metadata":{"heading_collapsed":true},"pos":9,"type":"cell"}
{"cell_type":"markdown","id":"7e7bfd","input":"# *Self-Assessment:  Exploring Tournament Selection*\n\n*What happens for smaller tournament sizes?*  You should notice that there is more diversity in the selected population and more high value fitness values get selected.  There are fewer repeats in the selected population.\n\n*For larger tournament sizes?* There is less diversity in the selected population and mostly low value fitness values get selected.  There are more repeats in the selected population.\n\n*For tournament size 1?* This yields the most diverse population with fewest repeats.\n\n*For tournament size the same as the population size?* The selected population contains only the individual with the lowest fitness value.  This means crossover will have no effect since all the individuals are the same.  Only the mutation operator will have an effect.\n\n*How does tournament size affect the exploration versus exploitation tradeoff?*. Small tournament sizes encourage more exploration and less exploitation while larger tournament sizes have the opposite effect.","metadata":{"heading_collapsed":true},"pos":7,"type":"cell"}
{"cell_type":"markdown","id":"c17c40","input":"But, if you try to put a negative sign in front of np.sum, you'll get an error. Numpy, though, has it's own negation function. We could call it like this to turn np.sum into a maximization function.","metadata":{"hidden":true},"pos":5,"type":"cell"}
{"cell_type":"markdown","id":"f552b3","input":"# Self-Assessment: Using Maximization with GA\nTo maximize, we need to negate the fitness function, because our genetic algorithm only minimizes. Negating the fitness function is simple. You simply add a negative sign before the return variable. Let's set up the same population used in the lesson and get the maximized fitness.\n","metadata":{"heading_collapsed":true},"pos":1,"type":"cell"}
{"id":0,"time":1661540134747,"type":"user"}
{"last_load":1661540134617,"type":"file"}