{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-8de4d650-961e-498f-abb1-15236adb27ba.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.5"},"toc":{"base_numbering":1,"nav_menu":{},"number_sections":true,"sideBar":true,"skip_h1_title":false,"title_cell":"Table of Contents","title_sidebar":"Contents","toc_cell":false,"toc_position":{"height":"calc(100% - 180px)","left":"10px","top":"150px","width":"285.312px"},"toc_section_display":true,"toc_window_display":true},"varInspector":{"cols":{"lenName":16,"lenType":16,"lenVar":40},"kernels_config":{"python":{"delete_cmd_postfix":"","delete_cmd_prefix":"del ","library":"var_list.py","varRefreshCmd":"print(var_dic_list())"},"r":{"delete_cmd_postfix":") ","delete_cmd_prefix":"rm(","library":"var_list.r","varRefreshCmd":"cat(var_dic_list()) "}},"types_to_exclude":["module","function","builtin_function_or_method","instance","_Feature"],"window_display":false}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1629847643349,"exec_count":3,"id":"f8e553","input":"# EXECUTE FIRST\n\n# computational imports\nfrom pyomo.environ import *\nimport pandas as pd\n\n# display imports\nfrom IPython.display import display, IFrame\nfrom IPython.core.display import HTML\n\n# for playing videos, customize height and width if desired\ndef play_video(vid_name, w = 640, h = 360):\n    vid_path = \"https://media.uwex.edu/content/ds/ds775_r19/\"\n    return IFrame( vid_path + vid_name + \"/index.html\", width = w, height = h )","kernel":"python3","metadata":{"code_folding":[0]},"pos":0,"scrolled":true,"start":1629847643342,"state":"done","type":"cell"}
{"cell_type":"code","end":1629847648513,"exec_count":4,"id":"a0fb87","input":"# execute to play video\nplay_video(\"ds775_lesson3_transportation-overview\")","kernel":"python3","output":{"0":{"data":{"text/html":"\n        <iframe\n            width=\"640\"\n            height=\"360\"\n            src=\"https://media.uwex.edu/content/ds/ds775_r19/ds775_lesson3_transportation-overview/index.html\"\n            frameborder=\"0\"\n            allowfullscreen\n        ></iframe>\n        ","text/plain":"<IPython.lib.display.IFrame at 0x7fc319672820>"},"exec_count":4}},"pos":6,"start":1629847648503,"state":"done","type":"cell"}
{"cell_type":"code","end":1629847778231,"exec_count":5,"id":"74f19d","input":"# execute for video\nplay_video(\"ds775_lesson3_transportation-pyomo-walkthrough\")","kernel":"python3","output":{"0":{"data":{"text/html":"\n        <iframe\n            width=\"640\"\n            height=\"360\"\n            src=\"https://media.uwex.edu/content/ds/ds775_r19/ds775_lesson3_transportation-pyomo-walkthrough/index.html\"\n            frameborder=\"0\"\n            allowfullscreen\n        ></iframe>\n        ","text/plain":"<IPython.lib.display.IFrame at 0x7fc3196729a0>"},"exec_count":5}},"pos":13,"start":1629847778223,"state":"done","type":"cell"}
{"cell_type":"code","end":1629847786204,"exec_count":6,"id":"af38fa","input":"# execute for video\nplay_video(\"ds775_lesson3_understanding-the-sums\")","kernel":"python3","output":{"0":{"data":{"text/html":"\n        <iframe\n            width=\"640\"\n            height=\"360\"\n            src=\"https://media.uwex.edu/content/ds/ds775_r19/ds775_lesson3_understanding-the-sums/index.html\"\n            frameborder=\"0\"\n            allowfullscreen\n        ></iframe>\n        ","text/plain":"<IPython.lib.display.IFrame at 0x7fc30f0024c0>"},"exec_count":6}},"pos":11,"start":1629847786197,"state":"done","type":"cell"}
{"cell_type":"code","end":1629847845878,"exec_count":7,"id":"f60f6f","input":"# execute for video\nplay_video(\"ds775_lesson3_balanced-vs-unbalanced\")","kernel":"python3","output":{"0":{"data":{"text/html":"\n        <iframe\n            width=\"640\"\n            height=\"360\"\n            src=\"https://media.uwex.edu/content/ds/ds775_r19/ds775_lesson3_balanced-vs-unbalanced/index.html\"\n            frameborder=\"0\"\n            allowfullscreen\n        ></iframe>\n        ","text/plain":"<IPython.lib.display.IFrame at 0x7fc30f002430>"},"exec_count":7}},"pos":16,"start":1629847845868,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":0,"id":"3b961a","input":"","pos":43,"type":"cell"}
{"cell_type":"code","exec_count":0,"id":"812025","input":"","pos":34,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"730d0b","input":"# self-assessment big M method solution\n\nfrom pyomo.environ import*\n\n### PROBLEM DATA ###\n\n# load data\ncanneries = ['can1', 'can2','can3']\nwarehouses = ['ware1','ware2','ware3','ware4']\nsupply = [75, 125, 100]\ndemand = [80, 65, 70, 85]\nbigM = 10000\nunit_ship_cost = [[464, bigM, 654, 867], [bigM, 416, 690, 791],\n       [995, 682, bigM, 685] ]\n\n# parse dictionaries\nsupply_dict = dict( zip( canneries, supply) )\ndemand_dict = dict( zip( warehouses, demand))\nunit_ship_cost_dict = { c: {w: unit_ship_cost[i][j] for j,w in enumerate(warehouses) } for i,c in enumerate(canneries)}\n\n### MODEL CONSTRUCTION ###\n\n# declaration\nmodel = ConcreteModel()\n\n# decision variables\nmodel.transp = Var(canneries, warehouses, domain=NonNegativeReals)\n\n# objective\nmodel.total_cost = Objective(expr=sum(unit_ship_cost_dict[c][w] * model.transp[c, w]\n                                      for c in canneries for w in warehouses),\n                             sense=minimize)\n\n# constraints\nmodel.supply_ct = ConstraintList()\nfor c in canneries:\n    model.supply_ct.add(\n        sum(model.transp[c, w] for w in warehouses) == supply_dict[c])\n\nmodel.demand_ct = ConstraintList()\nfor w in warehouses:\n    model.demand_ct.add(\n        sum(model.transp[c, w] for c in canneries) == demand_dict[w])\n\n### SOLUTION ###\nsolver = SolverFactory('glpk')\nsolver.solve(model)\n\n### OUTPUT ###\nprint(f\"Minimum Total Cost = ${model.total_cost():,.2f}\")\n\n# put amounts in dataframe for nicer display\nimport pandas as pd\ndvars = pd.DataFrame([[model.transp[c, w]() for w in warehouses]\n                      for c in canneries],\n                     index=canneries,\n                     columns=warehouses)\nprint(\"Number of truckloads to ship from each cannery to each warehouse:\")\ndvars","output":{"0":{"name":"stdout","output_type":"stream","text":"Minimum Total Cost = $176,000.00\n"},"1":{"name":"stdout","output_type":"stream","text":"Number of truckloads to ship from each cannery to each warehouse:\n"},"2":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ware1</th>\n      <th>ware2</th>\n      <th>ware3</th>\n      <th>ware4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>can1</th>\n      <td>75.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>can2</th>\n      <td>0.0</td>\n      <td>55.0</td>\n      <td>70.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>can3</th>\n      <td>5.0</td>\n      <td>10.0</td>\n      <td>0.0</td>\n      <td>85.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"      ware1  ware2  ware3  ware4\ncan1   75.0    0.0    0.0    0.0\ncan2    0.0   55.0   70.0    0.0\ncan3    5.0   10.0    0.0   85.0"},"exec_count":1,"output_type":"execute_result"}},"pos":24,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"94594e","input":"# basic transportation code\n\nfrom pyomo.environ import*\n\n### PROBLEM DATA ###\n\n# load data\ncanneries = ['can1', 'can2','can3']\nwarehouses = ['ware1','ware2','ware3','ware4']\nsupply = [75, 125, 100]\ndemand = [80, 65, 70, 85]\nunit_ship_cost = [[464, 513, 654, 867], [352, 416, 690, 791],\n       [995, 682, 388, 685] ]\n\n# parse dictionaries\nsupply_dict = dict( zip( canneries, supply) )\ndemand_dict = dict( zip( warehouses, demand))\nunit_ship_cost_dict = { c: {w: unit_ship_cost[i][j] for j,w in enumerate(warehouses) } for i,c in enumerate(canneries)}\n\n### MODEL CONSTRUCTION ###\n\n# declaration\nmodel = ConcreteModel()\n\n# decision variables\nmodel.transp = Var(canneries, warehouses, domain=NonNegativeReals)\n\n# objective\nmodel.total_cost = Objective(expr=sum(unit_ship_cost_dict[c][w] * model.transp[c, w]\n                                      for c in canneries for w in warehouses),\n                             sense=minimize)\n\n# constraints\nmodel.supply_ct = ConstraintList()\nfor c in canneries:\n    model.supply_ct.add(\n        sum(model.transp[c, w] for w in warehouses) == supply_dict[c])\n\nmodel.demand_ct = ConstraintList()\nfor w in warehouses:\n    model.demand_ct.add(\n        sum(model.transp[c, w] for c in canneries) == demand_dict[w])\n\n### SOLUTION ###\nsolver = SolverFactory('glpk')\nsolver.solve(model)\n\n### OUTPUT ###\nprint(f\"Minimum Total Cost = ${model.total_cost():,.2f}\")\n\n# put amounts in dataframe for nicer display\nimport pandas as pd\ndvars = pd.DataFrame([[model.transp[c, w]() for w in warehouses]\n                      for c in canneries],\n                     index=canneries,\n                     columns=warehouses)\nprint(\"Number of truckloads to ship from each cannery to each warehouse:\")\ndvars","metadata":{"hidden":true},"output":{"0":{"name":"stdout","output_type":"stream","text":"Minimum Total Cost = $152,535.00\n"},"1":{"name":"stdout","output_type":"stream","text":"Number of truckloads to ship from each cannery to each warehouse:\n"},"2":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ware1</th>\n      <th>ware2</th>\n      <th>ware3</th>\n      <th>ware4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>can1</th>\n      <td>0.0</td>\n      <td>20.0</td>\n      <td>0.0</td>\n      <td>55.0</td>\n    </tr>\n    <tr>\n      <th>can2</th>\n      <td>80.0</td>\n      <td>45.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>can3</th>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>70.0</td>\n      <td>30.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"      ware1  ware2  ware3  ware4\ncan1    0.0   20.0    0.0   55.0\ncan2   80.0   45.0    0.0    0.0\ncan3    0.0    0.0   70.0   30.0"},"exec_count":2,"output_type":"execute_result"}},"pos":14,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"7bea51","input":"machines = ['mac1', 'mac2', 'mac3', 'macD']\nsupply = dict(zip(machines, [1, 1, 1, 1]))\n\nlocations = ['loc1', 'loc2', 'loc3', 'loc4']\ndemand = dict(zip(locations, [1, 1, 1, 1]))\n\nbigM = 1000\ncost_list = [[13,16,12,11],[15,bigM,13,20],[5,7,10,6],[0,0,0,0]]\ncost = {\n    machines[m]: {locations[l]: cost_list[m][l]\n                   for l in range(len(locations))}\n    for m in range(len(machines))\n}\n\n# throw an error if total supply and demand do not match\nassert (sum(supply.values()) == sum(demand.values()))\n\nmodel = ConcreteModel()\n\nmodel.assign= Var(machines, locations, domain=NonNegativeReals)\n\nmodel.total_cost = Objective(expr=sum(cost[m][l] * model.assign[m, l]\n                                      for m in machines for l in locations),\n                             sense=minimize)\n\nmodel.supply_ct = ConstraintList()\nfor m in machines:\n    model.supply_ct.add(\n        sum(model.assign[m, l] for l in locations) == supply[m])\n\nmodel.demand_ct = ConstraintList()\nfor l in locations:\n    model.demand_ct.add(\n        sum(model.assign[m, l\n                        ] for m in machines) == demand[l])\n\n# solve and display\nsolver = SolverFactory('glpk')\nsolver.solve(model)\n\n# display solution\nprint(f\"Minimum Cost per hour = ${model.total_cost():,.2f}\")\n\n# put amounts in dataframe for nicer display\ndvars = pd.DataFrame([[model.assign[m, l]() for l in locations]\n                      for m in machines],\n                     index = machines,\n                     columns=locations)\nprint(\"Machine assignments to locations:\")\ndvars","metadata":{"hidden":true},"output":{"0":{"name":"stdout","output_type":"stream","text":"Minimum Cost per hour = $29.00\nMachine assignments to locations:\n"},"1":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>loc1</th>\n      <th>loc2</th>\n      <th>loc3</th>\n      <th>loc4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>mac1</th>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>mac2</th>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>mac3</th>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>macD</th>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"      loc1  loc2  loc3  loc4\nmac1   0.0   0.0   0.0   1.0\nmac2   0.0   0.0   1.0   0.0\nmac3   1.0   0.0   0.0   0.0\nmacD   0.0   1.0   0.0   0.0"},"exec_count":3,"output_type":"execute_result"}},"pos":31,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"6736d6","input":"from pyomo.environ import *\nimport numpy as np\nimport pandas as pd\n\n### PROBLEM DATA ###\n\ntasks = ['masonry','carpentry','plumbing','ceiling','roofing','painting','windows','facade','garden','moving','final']\ndurations = [35, 15, 40, 15, 5, 10, 5, 10 ,5 , 5, 0]\nnum_tasks = len(tasks)\n\ntask_duration_dict = dict( zip( tasks, durations ) )\n\n# for each task we have a list of tasks that must go after ... task:['these','tasks','after']\n# this is typed out for clarity\nprecedence_dict = {\n    'masonry': ['carpentry', 'plumbing', 'ceiling','final'],\n    'carpentry': ['roofing','final'],\n    'plumbing': ['facade', 'garden','final'],\n    'ceiling': ['painting','final'],\n    'roofing': ['windows', 'facade', 'garden','final'],\n    'painting': ['moving','final'],\n    'windows': ['moving','final'],\n    'facade': ['moving','final'],\n    'garden': ['moving','final'],\n    'moving': ['final']\n}\n\n\nM = ConcreteModel(name = \"Schedule\")\n\nM.start = Var(tasks, domain = NonNegativeReals)\n\nM.length = Objective( expr = M.start['moving'] + 5, sense = minimize )\n\nM.precedence_ct = ConstraintList()\nfor before in precedence_dict.keys():\n    for after in precedence_dict[before]:\n        M.precedence_ct.add( M.start[before] + task_duration_dict[before] <= M.start[after])\n        \n### Solution ###\nsolver = SolverFactory('glpk')\nsolver.solve(M)\n\n### Display ###\nprint(f\"Total Time = {M.length():,.0f}\\n\")\nfor t in tasks:\n    print(f\"Start {t} at {M.start[t]():.0f} and end at {M.start[t]()+task_duration_dict[t]:.0f}\")","output":{"0":{"name":"stdout","output_type":"stream","text":"Total Time = 90\n\nStart masonry at 0 and end at 35\nStart carpentry at 35 and end at 50\nStart plumbing at 35 and end at 75\nStart ceiling at 35 and end at 50\nStart roofing at 50 and end at 55\nStart painting at 50 and end at 60\nStart windows at 55 and end at 60\nStart facade at 75 and end at 85\nStart garden at 75 and end at 80\nStart moving at 85 and end at 90\nStart final at 90 and end at 90\n"}},"pos":39,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"0a22d4","input":"# transportation including capacity constraints\n\nfrom pyomo.environ import*\n\n### PROBLEM DATA ###\n\n# load data\ncanneries = ['can1', 'can2','can3']\nwarehouses = ['ware1','ware2','ware3','ware4']\nsupply = [75, 125, 100]\ndemand = [80, 65, 70, 85]\nunit_ship_cost = [[464, 513, 654, 867], [352, 416, 690, 791],\n       [995, 682, 388, 685] ]\nbigM = 1000\ncapacities = [[60,60,60,0],[60,60,60,60],[60,60,bigM,60]]\n\n# parse dictionaries\nsupply_dict = dict( zip( canneries, supply) )\ndemand_dict = dict( zip( warehouses, demand))\nunit_ship_cost_dict = { c: {w: unit_ship_cost[i][j] for j,w in enumerate(warehouses) } for i,c in enumerate(canneries)}\ncapacities_dict = { c: {w: capacities[i][j] for j,w in enumerate(warehouses) } for i,c in enumerate(canneries)}\n\n### MODEL CONSTRUCTION ###\n\n# declaration\nmodel = ConcreteModel()\n\n# decision variables\nmodel.transp = Var(canneries, warehouses, domain=NonNegativeReals)\n\n# objective\nmodel.total_cost = Objective(expr=sum(unit_ship_cost_dict[c][w] * model.transp[c, w]\n                                      for c in canneries for w in warehouses),\n                             sense=minimize)\n\n# constraints\nmodel.supply_ct = ConstraintList()\nfor c in canneries:\n    model.supply_ct.add(\n        sum(model.transp[c, w] for w in warehouses) == supply_dict[c])\n\nmodel.demand_ct = ConstraintList()\nfor w in warehouses:\n    model.demand_ct.add(\n        sum(model.transp[c, w] for c in canneries) == demand_dict[w])\n    \nmodel.capacity_ct = ConstraintList()\nfor c in canneries:\n    for w in warehouses:\n        model.capacity_ct.add( model.transp[c,w] <= capacities_dict[c][w])\n\n### SOLUTION ###\nsolver = SolverFactory('glpk')\nsolver.solve(model)\n\n### OUTPUT ###\nprint(f\"Minimum Total Cost = ${model.total_cost():,.2f}\")\n\n# put amounts in dataframe for nicer display\nimport pandas as pd\ndvars = pd.DataFrame([[model.transp[c, w]() for w in warehouses]\n                      for c in canneries],\n                     index=canneries,\n                     columns=warehouses)\nprint(\"Number of truckloads to ship from each cannery to each warehouse:\")\ndvars","metadata":{"hidden":true},"output":{"0":{"name":"stdout","output_type":"stream","text":"Minimum Total Cost = $153,990.00\nNumber of truckloads to ship from each cannery to each warehouse:\n"},"1":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ware1</th>\n      <th>ware2</th>\n      <th>ware3</th>\n      <th>ware4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>can1</th>\n      <td>20.0</td>\n      <td>55.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>can2</th>\n      <td>60.0</td>\n      <td>10.0</td>\n      <td>0.0</td>\n      <td>55.0</td>\n    </tr>\n    <tr>\n      <th>can3</th>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>70.0</td>\n      <td>30.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"      ware1  ware2  ware3  ware4\ncan1   20.0   55.0    0.0    0.0\ncan2   60.0   10.0    0.0   55.0\ncan3    0.0    0.0   70.0   30.0"},"exec_count":5,"output_type":"execute_result"}},"pos":20,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"1fe3f6","input":"from pyomo.environ import*\n\n### PROBLEM DATA ###\n\n# load data\nmachines = ['mac1', 'mac2', 'mac3']\nsupply = [1 for m in machines] # gives [1,1,1]\nlocations = ['loc1', 'loc2', 'loc3', 'loc4']\ndemand = [1 for l in locations] # gives [1,1,1,1]\nbigM = 1000\ncost = [[13,16,12,11],[15,bigM,13,20],[5,7,10,6]]\n\n# parse into dictionaries\nsupply_dict = dict( zip( machines, supply) )\ndemand_dict = dict( zip( locations, demand))\ncost_dict = {m: {l: cost_list[i][j] for j,l in enumerate(locations)} for i,m in enumerate(machines)}\n\n### MODEL CONSTRUCTION ###\n\n# declaration\nmodel = ConcreteModel()\n\n# decision variables\nmodel.assign = Var(machines, locations, domain=NonNegativeReals)\n\n# objective\nmodel.total_cost = Objective(expr=sum(cost_dict[m][l] * model.assign[m, l]\n                                      for m in machines for l in locations),\n                             sense=minimize)\n\n# constraints\nmodel.supply_ct = ConstraintList()\nfor m in machines:\n    model.supply_ct.add(\n        sum(model.assign[m, l] for l in locations) == supply_dict[m])\n\nmodel.demand_ct = ConstraintList()\nfor l in locations:\n    model.demand_ct.add(\n        sum(model.assign[m, l\n                        ] for m in machines) <= demand_dict[l])  # note we are using <= for larger set\n\n### SOLUTION ###\nsolver = SolverFactory('glpk')\nsolver.solve(model)\n\n### OUTPUT ###\nprint(f\"Minimum Cost per hour = ${model.total_cost():,.2f}\")\n\n# put amounts in dataframe for nicer display\ndvars = pd.DataFrame([[model.assign[m, l]() for l in locations]\n                      for m in machines],\n                     index = machines,\n                     columns=locations)\nprint(\"Machine assignments to locations:\")\ndvars","metadata":{"hidden":true},"output":{"0":{"name":"stdout","output_type":"stream","text":"Minimum Cost per hour = $29.00\nMachine assignments to locations:\n"},"1":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>loc1</th>\n      <th>loc2</th>\n      <th>loc3</th>\n      <th>loc4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>mac1</th>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>mac2</th>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>mac3</th>\n      <td>1.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"      loc1  loc2  loc3  loc4\nmac1   0.0   0.0   0.0   1.0\nmac2   0.0   0.0   1.0   0.0\nmac3   1.0   0.0   0.0   0.0"},"exec_count":5,"output_type":"execute_result"}},"pos":33,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"701fd3","input":"M.precedence_ct.pprint()","output":{"0":{"name":"stdout","output_type":"stream","text":"precedence_ct : Size=24, Index=precedence_ct_index, Active=True\n    Key : Lower : Body                                   : Upper : Active\n      1 :  -Inf : start[masonry] + 35 - start[carpentry] :   0.0 :   True\n      2 :  -Inf :  start[masonry] + 35 - start[plumbing] :   0.0 :   True\n      3 :  -Inf :   start[masonry] + 35 - start[ceiling] :   0.0 :   True\n      4 :  -Inf :     start[masonry] + 35 - start[final] :   0.0 :   True\n      5 :  -Inf : start[carpentry] + 15 - start[roofing] :   0.0 :   True\n      6 :  -Inf :   start[carpentry] + 15 - start[final] :   0.0 :   True\n      7 :  -Inf :   start[plumbing] + 40 - start[facade] :   0.0 :   True\n      8 :  -Inf :   start[plumbing] + 40 - start[garden] :   0.0 :   True\n      9 :  -Inf :    start[plumbing] + 40 - start[final] :   0.0 :   True\n     10 :  -Inf :  start[ceiling] + 15 - start[painting] :   0.0 :   True\n     11 :  -Inf :     start[ceiling] + 15 - start[final] :   0.0 :   True\n     12 :  -Inf :    start[roofing] + 5 - start[windows] :   0.0 :   True\n     13 :  -Inf :     start[roofing] + 5 - start[facade] :   0.0 :   True\n     14 :  -Inf :     start[roofing] + 5 - start[garden] :   0.0 :   True\n     15 :  -Inf :      start[roofing] + 5 - start[final] :   0.0 :   True\n     16 :  -Inf :   start[painting] + 10 - start[moving] :   0.0 :   True\n     17 :  -Inf :    start[painting] + 10 - start[final] :   0.0 :   True\n     18 :  -Inf :     start[windows] + 5 - start[moving] :   0.0 :   True\n     19 :  -Inf :      start[windows] + 5 - start[final] :   0.0 :   True\n     20 :  -Inf :     start[facade] + 10 - start[moving] :   0.0 :   True\n     21 :  -Inf :      start[facade] + 10 - start[final] :   0.0 :   True\n     22 :  -Inf :      start[garden] + 5 - start[moving] :   0.0 :   True\n     23 :  -Inf :       start[garden] + 5 - start[final] :   0.0 :   True\n     24 :  -Inf :       start[moving] + 5 - start[final] :   0.0 :   True\n"}},"pos":41,"type":"cell"}
{"cell_type":"markdown","id":"08b21f","input":"*The homework includes a problem in which you transport multiple products from suppliers to customers.  This brief section gives you a couple of hints about how to set that up.*\n\nTo move toward making a more realistic problem we consider a transportation problem in which multiple products are transported from suppliers to customers.  To accomplish this our decision variables will need to be indexed by three sets:  product, supplier, and customer.  Like this:  \n\n```model.transp[ product, supplier, customer ]```\n\nYou can think of this as a three-dimensional array which in turn can be thought of as a stack of two-dimensional arrays:\n\n<img src=\"./images/threeD_array.png\" width = \"400\">\n\nImage from <a href=\"http://c-programmingbooks.blogspot.com/2011/11/three-dimensional-array-in-c.html\">c-programmingbooks.blogspot.com</a>\n\nThe 0th 2D array corresponds to the first product while the rows and columns of that array correspond to suppliers and customers respectively.  According to the picture, 4 units of product 1 are shipped from supplier number 1 to customer number 2.  To find the cost of shipping the products we have to sum the cost per unit times the number of units over all the elements in the three dimensional array, like this:\n\n```sum(cost[p,s,c] * model.transp[p,s,c] for p in products for s in suppliers for c in customers)```\n\nA supply constraint means that total amount of each product shipped from each supplier must match the supply available.  \n\n```\nfor p in products:\n    for s in suppliers:\n        sum( model.transp[p,s,c] for c in customers) == supply[p,s] )\n```\nIn the picture above this corresponds to summing each row of the stacked 2D arrays to make sure it matches the supplied amount.\n\nIf limited capacity is available for shipping from each supplier to each customer we have to add up the total amount of all products to be sure it isn't too large:\n```\nfor s in supplier:\n    for c in customer:\n        sum( model.transp[p,s,c] for p in products ) <= capacity )\n```\n\nSuppose we are solving an inventory problem for a large retail chain in which the suppliers are warehouses or distribution centers and the customers are the individual retail stores or outlets.  Each warehouse only serves a subset of the stores to minimize shipping costs.   We won't need decision variables for those routes that are infeasible so we'll use Technique 3 to reduce the number of decision variables.  You will explore a multi-product problem in the homework.","metadata":{"hidden":true},"pos":27,"type":"cell"}
{"cell_type":"markdown","id":"0e7c65","input":"A common application for constraint programming is to generate feasible schedules of workers to shifts, sports league play schedules, processing jobs to machines, etc.  We will use a linear programming approach to solve some scheduling problems but another commonly used tool is constraint programming which is discussed briefly in textbook section 12.9.","pos":36,"type":"cell"}
{"cell_type":"markdown","id":"0f2f14","input":"## Prototypical Assignment Problem","metadata":{"heading_collapsed":true},"pos":29,"type":"cell"}
{"cell_type":"markdown","id":"200909","input":"### *Self Assessment: Unbalanced Transportation Problem*","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"20e6b2","input":"It often happens in transportation problems that due to problems or prohibitive costs, shipping is not available on along certain routes.  In the previous example the route between cannery 1 and warehouse 4 was infeasible which was handled by setting the maxiumum capacity on that route to zero.  \n\nThere are at least three approaches to dealing with infeasible routes:\n\n1.  Enforce infeasible routes by setting the maximum capacity to be zero on those routes like in the previous example.  To make a route have unlimited capacity simply set the maximum capacity to be a larger value than any amount that will be transported along that route. This approach was demonstrated in the example just above.\n\n2.  If there is a mix of only infeasible and unlimited routes then it is possible to \"trick\" the model into making some routes infeasible by setting the cost to be a very large number for the routes that should be infeasible.  This is sometimes called the \"big M\" method where the cost on infeasible routes is set to a very large number M.  We'll show that approach in the next example.  *We describe this method because it's in the textbook, but in practice it's probably best to use one of the other approaches as both are more robust.*\n\n3.  Assume that the amounts shipped on infeasible routes are zero and eliminate decision variables for those routes.  This approach may be necessary for very large problems with many infeasible routes (a sparse problem) to reduce the number of decision variables in the solution.  Details of this approach are beyond the scope of our course.\n","pos":22,"type":"cell"}
{"cell_type":"markdown","id":"21cc77","input":"Mathematically we can frame the problem as below (identical to page 324).  Just below this cell is a video that discusses this formulation.\n\nLet $C$ be the set of canneries and let $W$ be the set of warehouses.\n\nDecision Variables:  let $x_{c,w}$ be the number of units shipped from cannery $c \\in C$ to warehouse $w \\in W$\n\nConstants:  \n- $q_{c,w}$ is the shipping cost per unit between cannery $c \\in C$ and warehouse $w \\in W$\n- $d_w$ is the number of units demanded by warehouse $w \\in W$\n- $s_c$ is the number of units supplied by cannery $c \\in C$\n\nObjective Function:  minimize $ Cost = \\displaystyle \\sum_{c \\in C} \\sum_{w \\in W} q_{c,w} x_{c,w}$\n\nConstraints:\n- Supply: $ \\displaystyle \\sum_{w \\in W} x_{c,w} = s_c, \\mbox{ for each } c \\in C$\n- Demand: $ \\displaystyle \\sum_{c \\in C} x_{c,w} = d_w, \\mbox{ for each } w \\in W$\n- Nonnegativity: $x_{c,w} \\geq 0$ for each $c \\in C, w \\in W$","metadata":{"hidden":true},"pos":10,"type":"cell"}
{"cell_type":"markdown","id":"347b87","input":"#### Integer Solutions Property","metadata":{"heading_collapsed":true,"hidden":true},"pos":7,"type":"cell"}
{"cell_type":"markdown","id":"48459d","input":"This is the same as the supply and demand self-assessment problem from Lesson 2 except that the demand has been reduced at one of the medical centers to produce an unbalanced problem.\n\nThe Medequip Company produces precision medical diagnostic equipment at two factories. Three medical centers have placed orders for this month’s production output. The table below shows what the cost would be for shipping each unit from each factory to each of these customers. Also shown are the number of units that will be produced at each factory and the number of units ordered by each customer.\n\n<table>\n    <tr>\n        <th style=\"border-right:thin solid;border-bottom:thin solid;\"> &nbsp; </th>\n        <th style=\"border-bottom:thin solid;\"> Customer 1</th>\n        <th style=\"border-bottom:thin solid;\"> Customer 2</th>\n        <th style=\"border-bottom:thin solid;\"> Customer 3</th>\n        <th style=\"border-left: thin solid;border-bottom:thin solid;\"> Output</th>\n    </tr>\n    <tr>\n        <td style=\"border-right:thin solid;\"> <b>Factory 1</b> </td>\n        <td> \\$600 </td>\n        <td> \\$800 </td>\n        <td> \\$700 </td>\n        <td style=\"border-left:thin solid;\"> 400 units </td>\n    </tr>\n    <tr>\n        <td style=\"border-right:thin solid;\"> <b>Factory 2</b> </td>\n        <td> \\$400 </td>\n        <td> \\$900 </td>\n        <td> \\$600 </td>\n        <td style=\"border-left:thin solid;\"> 500 units </td>\n    </tr>       \n    <tr>\n        <td style=\"border-top:thin solid;border-right:thin solid\"> <b>Order size</b> </td>\n        <td style=\"border-top:thin solid;\"> 300 units </td>\n        <td style=\"border-top:thin solid;\"> 200 units </td>\n        <td style=\"border-top:thin solid;\"> 300 units </td>\n        <td style=\"border-left:thin solid; border-top:thin solid;\"> &nbsp; </td>\n    </tr>\n</table>\n\nFind the minimum total shipping cost two different ways:\n\n1. Introduce a dummy (extra) distribution center with demand of 2100 to balance supply and demand and set all costs to zero for shipping to the dummy center.  You can use the standard balanced code for this approach.\n\n2. Adjust the supply constraint so that the total amount shipped at each mill is less than or equal to ($\\leq$) the supply amount at the distribution center.","pos":18,"type":"cell"}
{"cell_type":"markdown","id":"4a29d8","input":"### Mathematical Formulation","metadata":{"heading_collapsed":true,"hidden":true},"pos":9,"type":"cell"}
{"cell_type":"markdown","id":"52ce30","input":"### Incorporating Route Capacities\n\nThere may be limits on how much can be shipped along some or all of the routes (edges of the graph).  Suppose our capacities are limited as per the following table.\n\n<img src=\"images/prototype_capacity_table.png\" width=\"600\">\n\nIn this case we have limited the capacity on most routes to 60 truckloads, but one route has effectively unlimited capacity, and one is infeasible with zero capacity.  For the unlimited route we set the capacity to be very large so the amount shipped is not restricted. The code below illustrates how to incorporate these route capacities.","pos":19,"type":"cell"}
{"cell_type":"markdown","id":"5ab879","input":"<font size=16>Lesson 03: Linear Programming Applications</font>\n\nTo familiarize you with some linear programming applications as well as to get additional practice at abstract modeling we will present three different applications in this lesson:\n\n* transportation problems - moving goods from \"suppliers\" to \"demanders\"\n* assignment problems - assigning tasks to workers\n* scheduling problems - creating a schedule of minimal length from multiple events","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"5e08d5","input":"## Transporting Multiple Products","metadata":{"heading_collapsed":true},"pos":26,"type":"cell"}
{"cell_type":"markdown","id":"73a950","input":"### *Self-Assessment: Big M Method*\n\nConsider the example above where three of the routes are rendered infeasible as shown in the table below:\n\n<img src=\"images/prototype_infeasible_table.png\" width=\"600\">\n\nStart with the code above that is labeled \"basic transportation code\".  Set the costs along the infeasible routes to be $M = 10000$ and solve the linear program.  Does your solution have zero amounts along the infeasible routes?  The minimum cost should now be higher than before.  Why does that make sense?","pos":23,"type":"cell"}
{"cell_type":"markdown","id":"76e8cf","input":"## Prototypical Transportation Example from Textbook","metadata":{"heading_collapsed":true},"pos":4,"type":"cell"}
{"cell_type":"markdown","id":"7864d8","input":"This problem is described completely on page 348 of the textbook.  We're including it here as an example to show how to solve it using Pyomo.  In short, we're assigning 3 machines to 4 locations.  Because this is imbalanced, a 4th dummy machine is added.  Each machine has an hourly cost that depends on the location.  Machine 2 cannot be used in location 2 and there is no cost associated with assigning the dummy machine to any location since this just means that no machine is installed at that location.  The mathematical formulation is identical to that of the transportation problem using a supply and demand of 1 at each machine and location. The cost table is shown here for convenience:\n\n<img src=\"images/assign_machine_location.png\" width=\"600\"> $$ $$\n\n\nThe $M$ will be a very large value (\"big M\") to prevent an assignment of machine 2 to location 2.\n\nHere is a Pyomo solution that uses a dummy machine to match the sizes of the two sets:","metadata":{"hidden":true},"pos":30,"type":"cell"}
{"cell_type":"markdown","id":"82f19e","input":"To study and understand this model it might be helpful to print out the constraints:","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"830cdd","input":"### Pyomo Solution Walkthrough\n\nHere is a video that walks through the Pyomo solution for the prototype example.  The code is below the video.","metadata":{"hidden":true},"pos":12,"type":"cell"}
{"cell_type":"markdown","id":"884bf6","input":"Note that these constraints have been rearranged by Pyomo.  The first says:\n$$- \\infty < x_{\\mbox{masonry}} + 35 - x_{\\mbox{carpentry}} \\leq 0$$\n\nWe can ignore the lower bound and rearrange this to get:\n$$x_{\\mbox{masonry}} + 35 \\leq x_{\\mbox{carpentry}}.$$\n\nNote that the remaining constraints can be rearranged similarly.","pos":42,"type":"cell"}
{"cell_type":"markdown","id":"8ca002","input":"# Transportation Problems","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"92a816","input":"### Balanced vs Unbalanced Transportation Problems\n\nIn the video below we present two approaches for dealing with unbalanced transportation problems in which the total supply exceeds the total demand.\n\n**Is balancing necessary?**  Generally the only reason to balance a transportation problem is make use of a special purpose solver for the linear program that is faster than the regular approach (the simplex method), but this isn't necessary except for **very** large problems.  This specialized algorithm can be read about in the textbook. ","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"a15906","input":"Transportation problems are characterized by moving goods or services from a set of \"suppliers\" to a set of \"demanders\".  The worker-days problem we encountered in Lessons 1 and 2 can be thought of as a transportation problem.  the \"suppliers\" are the workers, the \"demanders\" are the days of the week on which workers must be scheduled, and the objects that are supplied are the hours of labor supplied by each worker.  The Self Assessment problem about the Medequip Company near the end of Lesson 2 is also a transportation problem where diagnostic equipment is supplied to customers who \"demand\" it.","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"a2abc4","input":"### Dealing with Infeasible Routes","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"a74a72","input":"For transportation and assignment problems *if the amounts supplied and demanded are integer valued, then the solutions will always be integers.*\n\nThis is super important because it allows us to use the Simplex method or other LP solvers to achieve integer valued solutions even if we allow real numbers for the decision variables.  If we restrict the decision variables to be integer valued, then the the solution procedure is much more computationally intensive.  We'll discuss this in a later lesson about Integer Programming.","metadata":{"hidden":true},"pos":8,"type":"cell"}
{"cell_type":"markdown","id":"af5350","input":"We have a housebuilding problem in which there are 10 tasks of fixed size, each of which needs to be assigned a starting time in such a way as to minimize the total time.  Moreover, there are precedence constraints wherein some tasks must be completed before others are started.  The table below summarizes the durations and precedence constraints: \n\ntask | duration | must be done before\n---- | ---- | ----\nmasonry | 35 | carpentry, plumbing, ceiling\ncarpentry | 15 | roofing\nplumbing | 40| facade, garden\nceiling | 15 | painting\nroofing | 5 | windows, facade, garden\npainting | 10 | moving\nwindows | 5 | moving\nfacade | 10 | moving\ngarden | 5 | moving\nmoving | 5 |\n\nIn this example it's pretty clear that the final task will be \"moving\", but in general we may not know which task is the final task.  To let the code determine the final task we add an artificial task called \"final\" that takes zero duration and we arrange the precedence constraints so that every task occurs before the final task.  Like this:\n\ntask | duration | must be done before\n---- | ---- | ----\nmasonry | 35 | carpentry, plumbing, ceiling, final\ncarpentry | 15 | roofing, final\nplumbing | 40| facade, garden, final\nceiling | 15 | painting, final\nroofing | 5 | windows, facade, garden, final\npainting | 10 | moving, final\nwindows | 5 | moving, final\nfacade | 10 | moving, final\ngarden | 5 | moving, final\nmoving | 5 | final\nfinal | 0 | \n\nTo set up a linear program we introduce variables that represent the start time of each task:  $x_{\\mbox{masonry}}, x_{\\mbox{carpentry}}, \\ldots, x_{\\mbox{final}}.$    Since the final task has zero duration, $x_{\\mbox{final}}$ will be the same as the total time to complete all of the tasks.  To minimize the total time we simply minimize the value of $x_{\\mbox{final}}$ and the objective function is simply \n$$ Z = x_{\\mbox{final}}.$$  \n\nTo arrange the constraints consider the finish time for each task.  For example, masonry takes 35 days so its finish time is $x_{\\mbox{masonry}} + 35$.  We also know that masonry must be completed before carpentry so that the finish time for masonry is less than or equal to the start time for carpentry:\n$$x_{\\mbox{masonry}} + 35 \\leq x_{\\mbox{carpentry}}.$$  The other precedence constraints are similar.\n\nHere is what that looks like in Pyomo:","pos":38,"type":"cell"}
{"cell_type":"markdown","id":"ce77ff","input":"### *Self-Assessment: Unbalanced assignment problem without dummies*\n\nSolve the prototypical assignment problem above without introducing any dummy machines or locations.  You'll need to slightly adjust one or more constraints.","pos":32,"type":"cell"}
{"cell_type":"markdown","id":"d72246","input":"# Scheduling Problems","pos":35,"type":"cell"}
{"cell_type":"markdown","id":"da235a","input":"## A Housebuilding Example","pos":37,"type":"cell"}
{"cell_type":"markdown","id":"e014e3","input":"# Assignment Problems\n\nWe like to think of an assignment problem as a transportation problem in which we are transporting objects to destinations.  Assigning workers to jobs can be transporting workers to jobs where each worker has a supply of 1 and each job has a demand of 1.  If the number of workers doesn't match the number of jobs then we can either:\n\n1.  Add dummy workers or dummy jobs with zero cost to make the number of workers and jobs the same.  The advantage to a balanced problem is that a faster specialized algorithm can be used than if the problem is unbalanced.\n\n2.  For the larger set of jobs or workers change the supply or demand constraint to use \"$\\leq$\" instead of \"$=$\".\n\nThe second approach works with any linear program solver, but doesn't match the efficiency of the special algorithm approach.  However, the increased inefficiency isn't necessary except for **very** large assignment problems.","pos":28,"type":"cell"}
{"cell_type":"markdown","id":"ebb257","input":"Revisit the worker scheduling problem from the textbook (3.4-15).  Start with the code above and modify it using Technique 3 to eliminate unneeded decision variables.  Your new solution should have 18 decision variables instead of 30 and the overall answer should be the same.","metadata":{"hidden":true},"pos":25,"type":"cell"}
{"cell_type":"markdown","id":"eff624","input":"You should read the complete details of this problem beginning on page 319 of the textbook.  In short we want to transport truckloads of canned peas from canneries to warehouses while minimizing the total shipping cost.  The supply (Output), demand (Allocation), and shipping cost per truckload are shown in this table:\n\n<img src=\"images/prototype_cost_table.png\" width=\"600\">\n\nWe'll use this example to demonstrate the main concepts in transportation problems.\n\n### Features of Transportation Problems","metadata":{"hidden":true},"pos":5,"type":"cell"}
{"id":0,"time":1629847559159,"type":"user"}
{"last_load":1629847556216,"type":"file"}