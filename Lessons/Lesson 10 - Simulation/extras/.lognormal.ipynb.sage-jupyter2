{"backend_state":"init","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.9"},"toc":{"base_numbering":1,"nav_menu":{},"number_sections":true,"sideBar":true,"skip_h1_title":false,"title_cell":"Table of Contents","title_sidebar":"Contents","toc_cell":false,"toc_position":{},"toc_section_display":true,"toc_window_display":false}},"trust":false,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"fe8011","input":"","pos":10,"type":"cell"}
{"cell_type":"code","exec_count":10,"id":"9cf4f1","input":"import numpy as np\nnp.random.seed(123)\nx1 = np.random.normal(loc = 8, scale = 3, size = 10)\nexp_x1 = np.exp(x1)\nprint(exp_x1)","output":{"0":{"name":"stdout","output_type":"stream","text":"[1.14790438e+02 5.93992180e+04 6.96696864e+03 3.24959627e+01\n 5.25420684e+02 4.22654192e+05 2.05435570e+00 8.23251805e+02\n 1.32960687e+05 2.21357445e+02]\n"}},"pos":2,"type":"cell"}
{"cell_type":"code","exec_count":13,"id":"98eec9","input":"np.random.seed(123)\nx2 = np.random.lognormal( mean = 8, sigma = 3, size = 10)\nprint(x2)\nprint(np.log(x2))","output":{"0":{"name":"stdout","output_type":"stream","text":"[1.14790438e+02 5.93992180e+04 6.96696864e+03 3.24959627e+01\n 5.25420684e+02 4.22654192e+05 2.05435570e+00 8.23251805e+02\n 1.32960687e+05 2.21357445e+02]\n[ 4.74310819 10.99203634  8.84893549  3.48111586  6.26419924 12.95430961\n  0.71996227  6.71326211 11.79780878  5.39977879]\n"}},"pos":6,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"713764","input":"print(np.log(exp_x1))","output":{"0":{"name":"stdout","output_type":"stream","text":"[ 4.74310819 10.99203634  8.84893549  3.48111586  6.26419924 12.95430961\n  0.71996227  6.71326211 11.79780878  5.39977879]\n"}},"pos":4,"type":"cell"}
{"cell_type":"code","exec_count":9,"id":"298a1b","input":"m = 8 \ns = 3\nmu = np.log( m**2 / np.sqrt(s**2 + m**2)); \nsig = np.sqrt( np.log( 1 + s**2/m**2) );\nx = np.random.lognormal( mean = mu, sigma = sig, size = 1000)\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.distplot(x)\nprint(np.mean(x))\nprint(np.std(x))","output":{"0":{"name":"stdout","output_type":"stream","text":"7.976618073692172\n2.761749387482237\n"},"1":{"data":{"image/png":"c31aada2f1a29dfe2b2233bb1872eff7d39763a3","text/plain":"<Figure size 432x288 with 1 Axes>"},"exec_count":9,"metadata":{"needs_background":"light"},"output_type":"execute_result"}},"pos":8,"type":"cell"}
{"cell_type":"markdown","id":"16667a","input":"# A note on lognormal distributions","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"1802f2","input":"Notice that these are exactly the same random numbers as we generated using the first approach.  Suppose we want the lognormal distribution to have mean $m$ and standard deviation $s$ then we need to reverse engineer the parameters $\\mu$ and $\\sigma$ for the underlying normal distribution:\n\n$$ \\mu = \\log\\left( \\frac{m^2}{\\sqrt{s^2 + m^2}} \\right)$$\n$$ \\sigma = \\ \\sqrt{ \\log\\left( 1 + \\frac{s^2}{m^2} \\right)}$$\n\nYou can find these formulas in a variety of places, including <a href=\"https://en.wikipedia.org/wiki/Log-normal_distribution\">Wikipedia</a>.\n\nTo generate a sample of 1000 observations from a lognormal distribution with mean 8 and standard deviation 3 we could do this:","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"8f8552","input":"Notice those numbers can't possibly come from a distribution whose mean is 8, but if we were to take the log of those numbers:","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"9f8d97","input":"When we use the lognormal normal distribution to generate random values like\n\n```\nnp.random.lognormal( mu, sigma)\n```\n\nWe're actually specifying the mean and standard deviation for the underlying normal distribution and then taking the exponential of of those random numbers.  So the logarithm of our random numbers will have mean `mu` and standard deviation `sigma`.  To see how this works lets compute a sample of 10 random numbers two different ways. We're going to specify $\\mu = 8$ and $\\sigma =3$.  We'll reset a random number seed each time to see how the results compare.  First we'll generate 10 normally distributed random numbers and apply the exponential function.","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"a4aa6a","input":"Those numbers could come from a distribution with mean 8.  When we specify a random variable is lognormal distributed with mean $\\mu$ and standard deviation $\\sigma$ it means that the logarithm of the random variable follows a normal distribution with the specified parameters.  \n\nThe second method for generating the lognormal random numbers is to just use the lognormal distribution from numpy:","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"b91b46","input":"Of course the mean and standard deviation of the **sample** aren't exactly 8 and 3, respectively but that is just the usual sampling variability.","pos":9,"type":"cell"}
{"id":0,"time":1648492095857,"type":"user"}
{"last_load":1648492095975,"type":"file"}